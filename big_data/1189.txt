Mining Association Rules from a Collection of XML Documents using Cross Filtering Algorithm 
ece.skku.ac.kr 
Abstract 
Jun Shin Juryon Paik and Ungmo Kim Department of Computer Engineering Sungkyunkwan University 300 Chunchun-dong Jangan-gu Suwon Gyeonggi-do 440-746 Republic of Korea 
Since numerous data have been represented and exchanged by XML the ability to extract useful knowledge from XML data is needed There are several attempts to 
001   
crashjun wise96 umkim 
mine Association Rules from XML data However they mostly rely on legacy relational database with an XML interface so that ef\336ciency and simplicity are challenging issue In this paper,HILoP\(Hierarchical layered structure of PairSet is introduced The use of this data structure prevent from multiple XML data scans to mine Association Rules from a Collection of XML Documents Also Cross 336ltering algorithm is introduced to mine frequent patterns the algorithm reduces the number of candidate set The perfor 
mance evaluation result shows that this mechanism is powerful enough to represent both simple and complex structured association relationships inherent in XML data 
Due to the wide availability of huge amounts of data and the imminent need for turning such data into useful information and knowledge Data mining technology has been spotlighted More precisely the ability to extract useful knowledge from XML data is needed because numerous data have been represented and exchanged by XML Thought there 
1 Introduction 
are some proposals to exploit XML within the knowledge discovery tasks most of them rely on legacy relational database with an XML interface In addition mining knowledge in XML world is faced with more challenges than in the traditional well-structured world because of the inherent 337exibility of XML about structure and semantics 
This research was supported in part by university IT research center project ITRC funded by the Korean Ministry of Information and Communication and by Korea Science  Engineer-ing Foundation R01-2004 
001 
000-10755-0 As a result of data mining the knowledge can be represented in many different ways such as clusters decision trees decision rules and so on Among them association rules ha v e been pro v ed that it is ef fecti v e i n d is co v e ring interesting relations in massive amounts of data Extracting association rules from native XML documents called 323XML association rules\323 was 336rst introduced by Braga et al In mi ni ng area mos t s t udi es adopt an Apriori-like candidate set g eneration-and test approach However candidate set generation is still costly especially 
when there exist a large number of patterns and/or long patterns I n t hi s p aper  H ILoP HIerarchi cal Layered S t r ucture of PairSet is introduced It can signi\336cantly reduce the number of rounds for candidate-tree-item-pruning besides it can simplify each round by avoiding time-consuming tree item join operations This paper also introduces Cross 336ltering algorithm which reduces the number of candidate set These two components play main roles of our concept The outline of this paper is as follows We review some closely related works in Section 2 Section 3 de\336nes as 
sociation rules in the context of relational databases and discusses the notions of association rules for XML In section 4 the details of HILoP including some basic concepts needed to implementation are presented In section 5 we describe the Pseudo code of Cross Filtering Section 6 shows a result of performance evaluation and explains about it Finally section 7 concludes and discuss the future work 
Agrawal et al.[1 h ad 336r st in tr o d u ced th e p r o b l em o f mining association rules Since them numerous works have 
2 Related Works 
been done in various directions Methods for mining association rules from relational data have been well developed In t h e y ga v e A p ri ori a nd A p ri ori T i d A l gori t h ms  These Algorithms for discovering large itemsets make multiple passes over the data There are many Apriori-like al 


 which denotes the percentage of transactions in freq freq freq that also contain the items A rooted tree is a directed acyclic graph where 1 there is a distinguished vertex called the root that has no entering edges 2 every other vertex has exactly one entering edge 3 there is a unique path from the root to any other vertex Every XML document is represented by a rooted labeled tree For brevity we call a rooted labeled tree as simply a tree in the rest of this paper  Association rules were 336rst introduced by Agrawal et al.[1 to an aly z e c u s to m e r h ab its in r e tail d a tab a ses Asso ciation rule is an implication of the from X  which measures the percentage of transactions in  X X X Y X Y X  u v T Y G V L N N i 1 1 007 in 90 of the cases and that this rule holds in 5 of the transactions The problem of mining association rules from a set of transactions ii X V E   where the rule 2 2 002 E  Association rules are characterized by two measures  the Y De\336nition 1 De\336nition 2 De\336nition 3 De\336nition 4 and and and Xand   t  005 006 3 Background Concepts T  u  XML Association Rule An XML association rule is an implication of the form X D E 006 004 containing the items be a collection of XML documents and let  gorithms and such works are too many to enumerate In addition several query languages have been proposed to assist association rule mining such as 4  Some works are focusing on developing a standard model to represent the knowledge extracted from the data using XML Recently tools for extracting association rules from XML documents have been proposed in Thes e approaches are from the view point of a XML query language so that it causes the problem of language-dependent association rules mining On the other hand h as proposed as algorithm to construct a frequent tree by 336nding common subtrees embedded in the heterogeneous XML data Because candidate set generation is costly How to reduce the procedure is a key issue in this area In The y proposed a method for mining frequent patterns without candidate generation p ropos ed a met hod t o a v oi d mul tiple XML data scans to mine Association Rules Y are subsets of the set containing 323 with con\336dence 0.9 and support 0.05 The rule states that customers who buy that contains both items u,v  More formally given the function be the number of documents in Y Y alsobuy 3.1 Association Rules for Relational Data F F F i i j Suppose that there is an association rule 323 004D T       sup In this subsection we brie\337y review some notations of tree model and describe the basic concepts of association rules for XML data shortly called 323XAR\323 consists of generating all the association rules that have support and con\336dence greater than two user-de\336ned thresholds minimum support wede\336ne X of items  to node freq\(X 001 001 Arule that contains the items in   I   T    003 Y 005 T F n F n which satis\336es the following two conditions Y s a fregment of a tree T=\(N,E denoted by F X X Let X The items in XAR have hierarchical tree structures as indicated by the 336rst clause of the de\336nition It is worth X 005 Y 002 I I D D D D D D D D 002 D  b D D F 004 002 n Y Y  001 V Y Y   1 T X Y X X X X With the above de\336nitions we formally de\336ne XML association rules and related measurements Let  To help the speci\336cation of complex association rule mining tasks a number of query languages have been proposed In particular introduced the MINE RULE operator an extension of SQL speci\336cally designed for modelling the problem of mining association rules from relational data  within a set of Note that in the de\336nition of fragment we require that there be a path from node are likely to contain also the items in bread butter min min butter milk milk transactions Y states that the transactions in tree T for any edge  body support support T if and only if  occurring in a fragment F De\336nition 2 preserves the ancestor relation but not n ecessarily the parent relation T I L E T i  forsomej n Y 001 for vertex and edge labels and a labeling funcion N and for all edges F   Y is an ancestor of vinT con\336dence con\336dence that assigns labels to vertices and edges I    u,v  an edge set E an alphabet head bread conf Labeled Graph consists of a vertex set Fragment\.We say that a tree F Titem The basic construct unit in XAR is referred to as titem tree-structured item Since any part of an XML document is fragment any fragment can be a titem       001 001 0   004F 004F  the 002 002 006 006   which measures the percentage of transactions in  and minimum con\336dence 3.2 Association Rules for XML Data 


tid tid tid m X X j j 2   T is 0.66  respectively Example   We denote frequent fragment set and candidate fragment set by and     where pointing out that each of the fragments contains only one basic root node The second clause of the de\336nition requires that in an XAR titems are independent each other conf idence De\336nition 5 De\336nition 6 De\336nition 7 De\336nition 8 De\336nition 9  is de\336ned as a set of pairs  thekey 1 1 1 2 3 here P P P F C P belongs to all of three trees     has a ancestor-descendant relationship with others in Fig 1\(a For example we know that the key 325news\325 in I I n j m n j m tid conf We devised HILoP as a tool to mine simple/complex association rules from XML documents HILoP allows the speci\336cation of complex mining task be compact and intuitive Towards this goal there is an important component That is a specially devised data structure called PairSet In this section we describe the technique used to mine data structureguided XML association rules Our mining process proceeds in three phases The 336rst phase is to transform each tree-structured data into hierar chical structure PairSets The second phase is to manipulate PairSets and to re\337ect the min sup The third phase is to mine XML association rules from the PairSets by re\337ecting the two association measures  in which thr key belongs We employ hash technique to keep all the necessary information of each key\325s parent node into a hash table to facilita te the mining of association rules in later This will be used to 336nd out weather a key  222 222   223 224\223 224\223 224 223 224\223 224  223 224\223 224 222 223 224 223 224 222 223 224 205 222 223 224 205 Figure 1 A set of XML documents in At this point note that there may exist some nodes labeled with the same names in 001 001 001  The right side of Fig 2 illustrates the two classes frequent fragment set and candidate fragment set derived from PairSets in the left side The given Same as the association rules for relational data the problem of mining association rules for XML data consists of generating all XARs greater than min     004 005 004 005 006 006 for some X  This is so obvious Thus for each key we need to identify the list of trees be a collection of node labels assigned on the nodes at depth d in every tree in PairSet A PairSet Frequent Fragment Set\iven a PairSet X X I Y Y   I list list list list 004 is a list of tree indexes in which T support Y are de\336ned as Key Let D D D D 013 013  Y Y Y 006                  4.1 Transforming Tree-Structured XML Documents into PairSets be as set of titems Given a set of XML documents min  We assume that depth of root node is 0 We call each member in  the support and con\336dence of an XML association rule X belongs 004 by a key sup and a pair  a pair in and I i I i K K k k K k k T T sup 4HILoP 002 002 and  1 1 1 1 Fig.1 shows that an example of XML documents The left side of Fig 2 shows a collection of PairSet transformed from sup and min  The time complexity for generating PairSets is O\(n where n is the total number of nodes in trees A collection of PairSets can be classi\336ed into two classes which are frequent fragment set and candidate fragment set To classi\336ed them we refer to a minimum support Y Y X X X X X k       T X i J i X i j i d d d d d d d d d d d d d Frequent Key Given some user-de\336ned min I T T Y  for some  freq freq freq min sup  327|D f     D 002 D D D D 004 D 004 D D D  D is called frequent if is called frequent fragment set tid is a key in if its key is frequent Otherwise it is called candidate fragment set 


The initial frequent fragment sets\(depicted in the right side of Fig.2 are derived solely by considering a min   224\223 ij 4.2 Manipulating the Data Stored in PairSet Structure k  We denote this feasible edge by For node labels obtained after the second phase in subsection 4.2 we only uses the node label in 336nal frequent sets to min XARs There are three considerations during this correlating phase First we instantiate every symbol  This stems from the fact that association relationships between keys have to conform the  Given the current candidate fragment sets this step is to eliminate the pairs which are already included in the previous frequent fragments sets As result of this step we can reduce signi\336cantly the number of pairs in candidate fragments set Step 2\(Merging phase Union Given the current candidate fragment sets this step is to obtain a new frequent fragment set Since our PairSet is hierarchical structure it is not necessary to generate a dditional candidate fragments by using join operations It is enough to search only the candidate fragment sets are computed to 336ne new pairs of frequent fragment sets without using join operation t t k f 0 1 0 1 0 224\223 sup over the absolute depth of node labels These frequent fragment sets do not have competent fragments to min XML association rules because both tre e characteristic and fragment property\(De\336nition 2 are not re\337ected in those initial frequent fragment sets The tree characteristic stems from the fact that same labels can be placed several times throughout a XML tree To handle those features we introduce an algorithm called C k k e k k 224\223  be as set of initial frequent fragment sets and be a set of initial candidate fragment sets The i               Cross-Filtering  Let    at depth d conversely speaking whatever a node label is it can be placed at depth d without any restriction Second although all pairs in each frequent fragment set satisfy a and  and  The support has to be computed at the relationships called edges between keys of different frequent fragment sets is an ancestor of 1,2 d 223 223 223 let  cross-\336ltering cross-\336ltering  be a pair in 224\223 k i k j s j th round for i  pair in a Initial Pair Set  1 vs 1 through 1  CS D     are greater than     b Frequent and Candidate PairSet FS FS    consists of the following two steps Step 1\(Pruning phase Difference by De\336nition 2 The up sup sup sup sup F F F C C C C F F F C C F F t t  Assume that both here 224\223 in the frequent fragment sets with a 325*\325 Because the meaning of an empty frequent fragment set at depth d is that there is no any other node label satisfying the  not all of fragments being generated from the sets satisfy the 222    222   222 223 224 223 224 222  223 224 223 224 222    222 223 224 224 224 224  223 224 222  222 223 224 224\223 d d i 212 i  and i vs i 212 i vs i 212 i i j j k i k j i i j min min min min min   D 327                4.3 Correlating Concrete Contents with Structures     Figure 2 PairSets Generation from a set of XML trees in 


 again instead of that the user may call CrossFilter with new FS FS FS FS r F r C FS r FS FS FS FS 006 FS FS FS is computed as are generated by incrementally appending edge s and hierarchically calculating the supports in other words calculating the supports of edges Third we need to compute the con\336dence of between titems Then this con\336dence is compared with a layer by layer 5 D D r D r D D D  004 006  004 006 D I I I into  in   itis straightforward to generate both simple and complex XML association rules from sup sup sup sup sup sup sup sup sup sup sup sup t t min min min min min min min min min min min min min min min maxDepth A Set of Trees are derived from a set of XML documents  There is no any other additional burdensome process to re\337ect the varying and and and simultaneously makes the and and f     Algorithm 1 Algorithm 2 ij ij ij ij e k  e e k k I I I CandidateP airSet freq freq freq however this case the user are not required executing to mine all the XML association rules that have support and con\336dence greater than or equal to two user-de\336ned thresholds Let  Step\(1 3 seperates PairSet into FrequentSet and CandidateSet as shown in Figure 2 Step 4 11 is adjusting phase among keys that have same value but located in different levels Once a key is determined not to be frequent the key is pushed to the next level\(Step 11 Since the deeper the depth is the more expensive its commotional cost this algorithm is recommended to be used in applications with limited depth of trees The remaining job is to make ancestor-descendant or parent-child relationships between keys in Frequent Fragment Set As mentioned in Section 4.1 we employ hash technique to complete this job Once the frequent fragment sets support of an edge is computed as  13 return 0tomaxDepth 4 Given CrossFilter has only one full scan in this phase to make the All the experiments are performed on a 2.4GHz Pentium 4 PC machine with 1GB main memory running on Mi 4 for d:=1 to depth 5 for each key in key 7 for l d-1 to 0 8 for each key in key  are mined from the both equation 1 and 2 Following Theorem 1 is derived We have already proved it in  Given a set of XML documents 1 1 2 1 2 2 2 1 2 1 Set of all frequent HILoP 1 2 maxDepth is a preprocessing phase It scans Set of all frequent HILoP 1 for d 0 to depth 2 Separate are mined from the D D D    10 336nd additional key,tlist pairs satisfying in accordance with     Theorem 1 1 2 As a result of the Mining we have Fig.3 All the XML association rules that have support and con\336dence greater than or equal to two thresholds which are 3 6 9 without changing whole CrossFilter satisfying XAR XAR XAR allofXML association rules conforming to any    k k k k D key.tlist key.tilst key.tlist key.tilst key.tlist support support support support    I  3 for i                             D Input Input      t t t P F C P P F C P F C F C F F F C F F C F C C C C C C key key PairSet PairSet PairSet PairSet FrequentPairSet and a collection of frequent fragments sets Output Output i j i j p q i j min CF CF CF CF conf idence key.tlist       j j m j q X     i i k k i p k k k k k k d d d d d 212 d d d 212 d d l d d l d d 212 d d 212 d d 212 d 5 Algorithm    be a set of titems Assume that be titems consisting of 1 edge The con\336dence of Based on Section 4 we have the following algorithm for Cross-\336ltering algorithm conf conf conf conf associated if hence it takes O\(N Sometimes it will be necessary changing which is de\336ned in Section 4 AR   001 6 Evaluation e 1 1 1 1 1 k I I I 001 C C I t t t 003   002 002 006 003 003 003   003  003 003 006    11 remove the pairs from both pq Makethe e                              not associated if  Finally all of titems satisfying the        7 return      12 


Figure 3 Association Rule Mined from 25 crosoft Windows XP All the programs are written in JAVA The 336gure 4 shows the running time where the number of trees grows from 100 to 12000 and the b An XML Association Rule Figure 4 Running Time 0   are 0.05 0.01 0.07 and 0.3 each The data sets were generated by using the method tree generato r described in T he parameters used in the tree generation include number of labels N=100 the parameter of probability 002  003  and the maximum fan-out of a node in a tree f=5  Figure 4 and 5 show the results of the simulation As the minsup increases more time is taken during cross 336ltering however as the minsup exceeds a certain point,in here minsup=0.05 the running time is decreased As the minsup decreases the number of frequent trees in the 336nal result is increased as illustrated 336gure 5 This paper focuses on rule detection from a collection of XML documents describing the same type of information Hence each of XML documents corresponds to a database record and possesses a tree structure Accordingly we extend the notion of associated item to an XML tree and build up associations among trees rather items Compared to previous works the work reported in this study aims to provide 1 a data structure model for mining XML association rules which can deal with associations among both contents and structures of XML data 2 techniques for the data structureguided mining of association rules from large XML data and 3 query language-neutral association rule mining A data structure called 323HILoP\323 and Cross-\336ltering algorithm are introduced The proposed mechanism can avoid multiple data scan so that the process of mining complex  the maximum depth d=3  the maximum number of perturbation 2 min 222 223 224 224 224 224 224 224 222 223 224 222  222 223 224 223 224 223 223 223 223 223 sup D Figure 5 Number of frequent nodes a Final Frequent Fragment Sets  7Conclusion 


References 1 R  A g r a w al T  I m ielin sk i an d A  N  S w a m i M in in g a ssociation rules between sets of items in large databases In Proc of the ACM SIGMOD International Conference on Management of Data pp.207-216 1993 2 D B r a g a  A C am p i  S  C er i M Klem ettin en  a n d P  L Lanzi Mining association rules from xml data In Proc of the 4th International Conference on Data Warehousing and Knowledge Discovery\(DaWaK\32502 volume 2454 of LNCS Springer pp.21-30,2002  R A gra w al and R  S ri kant  F as t A l gori t h ms for M i n ing Association Rules In Proc of the 20th International Conference on Very Large Data Bases pp.478499 1994 4 T  I m i elin sk i a n d A V i r m an i MSQL  A q u e r y lan guage for database mining 1999 5 R M e o G P s a i l a  a n d S  C e r i An e wS Q L l i k e o p e r a tor for mining association rules In  pp 1-12 ACM Press 05 2000  J uryon P a i k  H ee Y oung Y oon U ngmo K i m A ne w method for Mining Association Rules from a collection of XML Documents.In Proc of ICCSA 32505 Ubiquitous Web Systems and Intelligence Workshop UWSI 2005 volume 3481 LNCS Springer pp.936-945 2005  R  M eo G  P s a i l a  a nd S  C e ri  A n e xt ens i on t o S Q L f or mining association rules Data Mining and knowledge Discovery 2\(2 pp.195-224 1998 Intl Conference on Management of Data usionWorkshop\32502  pp.122-133 1996  A  T ermi er  M C  R ous s e t a nd M.S e bag Mi ni ng X M L data with frequent trees In DBF  pp.87-96 2002  J  H an J  P ei  a nd Y  Y i n Mi ni ng frequent pat t e rns without candidate generation In W.Chen J Naughton and P A Bernstein editors 2000 ACM SIGMOD The VLDB Journal XML association rules is signi 336cantly simpli\336ed comparing to previous approaches We have been trying to apply this method to practical cases such as Service Discovery in Ubiquitous Environment Also our current and future research in this area focuses on adapting Ontology-based mining techniques because XML i s semi-structured so that it can describe one thing by different expressions shortly we may miss important information\(frequent keys 


In Figure 5 for the same reason as  results for the Partitioning algorithm is not shown It is still the slowest comparing the total running time This is because it generates too many candidate frequent itemsets from the dense dataset Together with the data structures the candidate sets use up main memory and virtual memory s used In Figure 5 a the time used for disk I/O\222s of the Aggressive algorithm is still remarkably less than the time used for disk I/O\222s of the Basic Algorithm We can again notice that the CPU time of the Basic Algorithm is less than that of the Aggressive algorithm This is because Kosarak is a dense dataset so the FP-array technique does not help a lot In addition calculating the statistics takes an amount of time To test the effectiveness of the techniques for grouping items we run Diskmine on T100I20D100K and see how close the estimation of the FP-tree size for each group is to its real size We still set the main memory size as 128 megabytes the minimum support is 2 When generating the projected databases items were grouped into 7 groups the total number of frequent items is 826 As we can see from Figure 6 a in all groups the estimated size is always slightly larger than the real size Compared with the Basic Algorithm which constructs an FP-tree for each item from its projected database the Aggressive algorithm almost fully uses the main memory for each group to construct an FP-tree                 Estimation size vs. Real size 0 20 40 60 80 100 120 140 160 1234567 Group Memo ry M eg ab yt es  Estimated size  Real size a   Scalability 0 100 200 300 400 500 600 700 200 400 600 800 1000 1200 1400 1600 1800 2000 NO. of Transactions \(k Time s  CPU Disk I/O b Figure 6 Estimation Accuracy and Scalability of Diskmine As a ivide-and-conquer algorithm one f the most important properties of Diskmine is its good scalability We ran Diskmine on a set of synthetic datasets In all datasets the item number s set as 10000 items the average transaction length as 100 and the average pattern length as 20 The number of the transactions in the datasets ried from 200,000 to 2,000,000 Datasets size ranges from 100 megabytes to 1 gigabyte Minimum support was set as 1.5 and the available main memory was 128 megabytes Figure 6 b shows the results In the 036gure the CPU and the disk I/O time is always kept in a small range of acceptable values Even for the datasets with 2 million transactions the total running time is less than 1000 seconds Extrapolating from these 036gures using formula 4 we can conclude that a dataset the size of the Library of Congress collection 25 Terabytes could be mined in around 18 hours with current technology 5 Conclusions We have investigated several divide-and-conquer algorithms for mining frequent itemset from secondary memory We also analyzed the recurrences and disk I/O\222s of all algorithms We then gave a detailed divide-and-conquer algorithm which almost fully uses the limited main memory and saves a numerous number of disk I/O\222s We introduced many l techniques used in our algorithm Our experimental results show that our algorithm successfully reduces the number of disk access sometimes by orders of magnitude and that our algorithm scales up to terabytes of data The experiments also validate that the estimation techniques used in our algorithm are accurate Future extensions of this work will include mining maximal and closed frequent itemsets as well as exploring disk layout for various datastructures for instance for candidate sets since there are some situations where Apriori indeed outperforms the FP-tree based methods References  R C Agarw al C C Aggarw al and V  V  V  Prasad Depth 036rst generation of long patterns In KDD\32500  pages 108\226 118 2000  R Agra w al T  Imielinski and A N Sw ami Mining association rules between sets of items in large databases In ACM SIGMOD\32593  pages 207\226216 Washington D.C 1993  R Agra w a l and R Srikant F ast algorithms for mining association rules In VLDB\32594  pages 487\226499 1994  R Agra w a l and R Srikant Mining sequential patterns In ICDE\32595  pages 3\22614 1995  B Goethals and M J Zaki Adv ances in frequent itemset mining implementations Introduction to 036mi03 In Prodeeding of the 1st IEEE ICDM Workshop on Frequent Itemset Mining Implementations FIMI\32503  ov 2003  G Grahne and J Zhu Ef 036ciently using pre\036x-trees in mining frequent itemsets In 1st IEEE ICDM Workshop on Frequent Itemset Mining Implementations FIMI\32503 Nov 2003  J Han J Pei Y  Y in and R Mao Mining frequent patterns without candidate generation A frequent-pattern tree approach Data Mining and Knowledge Discovery  8:53\226 87 2004  M Kamber  J  Han and J Chiang Metarule-guided mining of multi-dimensional association rules using data cubes In Knowledge Discovery and Data Mining  pages 207\226210 1997  H Mannila H T o i v onen and A  I  V erkamo Disco v ery of frequent episodes in event sequences Data Mining and Knowledge Discovery  1\(3 1997  A Sa v asere E Omiecinski and S B Na v athe An ef 036cient algorithm for mining association rules in large databases In VLDB\32595  pages 432\226444 1995  H T o i v onen Sampling lar ge databases for association rules In VLDB\32596  pages 134\226145 Sep 1996  M Zaki and K Gouda F ast v ertical mining using dif fsets In ACM SIGKDD\32503  Washington DC Aug 2003 Proceedings of the Fourth IEEE Internati onal Conference on Data Mining \(ICDM\22204 0-7695-2142-8/04 $ 20.00 IEEE 


are computed from the transactions without taking into account the other attributes When multiple mdis are obtained, one of them is focused and the transactions in the mdi is retained. Next, the identiProceedings of the The 2005 Symposium on Applications and the Internet Workshops \(SAINT-W  05 0-7695-2263-7/05 $20.00  2005 IEEE Figure 2. Trie data structure Figure 3. Time complexity cal process is applied to   and this recursively continues in depth ?rst search \(DFS   is computed, the process continues again from  until the mdi of every              c o n v e r g e s   T h e  m d i s  a l w a y s  c o n v e r g e to these of the mdr  because the denseness is a MINT measure. After the convergence, the search is backtracked to the next mdr  The computation of mdis in each step requires       t i m e  a t  m o s t   I n  t h e  w o r s t  c a s e   o n l y  o n e t r a n s a c t i o n  i s  d r o p p e d  i n  e a c h  s t e p   a n d    s t e p s  r e q u i r e d until the mdis converge. Thus         H o w e v e r   t h i s  d o e s not likely occur. Practically, only a portion of the transact i o n s  a r e  r e t a i n e d  i n  e a c h  s t e p   L e t          b e  a n  e x pected rate of transactions retained in each step the required steps for convergence. The process to search an mdr stops at the latest when the number of retained transa c t i o n s     b e c o m e s  l e s s  t h a n   By solving the equation       w i t h   is        A c cordingly, the expected time complexity of this most expensive process is         4. Performance Evaluation The performance of QARMINT has been evaluated through both arti?cial data and real bench mark data Sets of arti?cial data have been generated under various conditions. The characteristics of the computation time is simlilar to the conventional Basket Analysis except for       T h e  t i m e  m o d e r a t e l y  i n c r e a s e s  w h e n s of all attributes are increased. This is because wider permissible ranges increases the number of mdrs. Figure 3 shows the dependency of the computation time on the n u m b e r  o f  t r a n s a c t i o n      T h e  c u r v e  a l m o s t  f o l l o w s  t h e  r e lation         The real bench mark data  Labor relations Database  in UCI Machine Learning Repository [3] was analyzed by QARMINT. It contains 57 instances, 8 numeric attributes and 8 categorical attributes and many missing values. We ignored the attributes of missing values in each instance and transformed the data into transactions. Though the size 


and transformed the data into transactions. Though the size of this data is quite small, we found many interesting QARs associated with the labor conditions under      and      w h i c h  i s  1 0   o f  t h e  m a x i m u m  a n d  m i n i mum values of each  in the data. The following two are examples                                                                                                                  These rules indicate that the workers having longer durat i o n  c o n t r a c t s  a n d  e v a l u a t i n g  t h e i r  l a b o r  c o n d i t i o n  a s   admit longer working times and less wage increase. These evaluations indicate the suf?cient tractability and the practical applicability of QARMINT 5. Conclusion The mathematical characterization and the extension of the Basket Analysis presented in this paper are expected to provide variety of new approaches of data mining. Their potential has demonstrated by a novel approach called QARMINT for complete mining of generic QARs within a low time complexity. We are implementing QARMINT in a more ef?cient algorithm and evaluating its performance in near future Acknowledgement This research has conducted under the support of JSPS Kiban Kenkyuu \(B 2 References 1] R. Agrawal and R. Srikant. Fast algorithms for mining association rules. Proc. of 20th Int. Conf. on Very Large Data Bases VLDB  499, 1994 2] R. Srikant and R. Agrawal. Mining quantitative association rules in large relational tables. Proc. of 1996 ACM SIGMOD Int. Conf. on Management of Data, pages 1  12, 1996 3] U. C. I. \(UCI http://www.ics.uci.edu/ mlearn/MLRepository.html, 2004 4] J. Wijsen and R. Meersman. On the complexity of mining quantitative association rules. Data Mining and Knowledge Discovery, 2\(3  281, September 1998 Proceedings of the The 2005 Symposium on Applications and the Internet Workshops \(SAINT-W  05 0-7695-2263-7/05 $20.00  2005 IEEE 


0-7695-2263-7/05 $20.00  2005 IEEE pre></body></html 


n M L N n t n t n t n t L M L t L t L tt L t kkkk kkkk kkk kkkk kkkkkkkkP VK VK VK VK PP       kkP t 31 where L  s the error covariance associated with the state estimate t i    kkLX  tt kkk P1  00 0  0                     s s sss s s sss s s sssss N n t n t n 


n t n N n t n t n t n N n t n t n t n t n t n c t L kkkkkk kkkkk kP VKVK VKVK  32 4. Simulations One has run simulations comparing the sequential implementations of MSJPDA algorithm and the new algorithm here. A typical multisensor multitarget tracking environment is assumed in the simulations. According to article [1,3], One known that the performance of sequential MSJPDA is better than the performance of parallel MSJPDA. Therefore, the performance of parallel MSJPDA algorithm will not be compared here There are three sensors, which are fixed in three platforms. Regarding the 2nd sensor as fusion centre situation of the other sensors are: =?-500m?-500m 0m??N =?-500m? 500m?0m??The distance error of each sensor is: =300m, =200m, =100m?The bear error of each sensor is 0.03rad, =0.02rad, =0.01rad?The of sample is T=1s?The nonparametric model of clutter is used in the simulations, and expected number of false measurement is m=1.8 1 sN 3 s 1r 2 2r 3 3r 1 Simulations have been run for racking two targets. The true initialization state of the targets is X1?[-29500m,400m/s,34500m,-400m/s X ?[-26250m,296m/s,34500m,-400m/s]'? 2 The two targets will cross above 31seconds later. To evaluate tracking performance, 50 Monte Carlo runs were performed for three case of the target detection probability Pd=0.97 ? Pd=0.76 ? Pd=0.58. In every run, the total simulation time is 140 steps 


simulation time is 140 steps            Figure 1  RMS position error in case of Pd=0.97          Figure 2  RMS velocity error in case of Pd=0.97       Figure 3  RMS position error in case of Pd=0.76 567 Proceedings of  the Fourth International Conference on Machine Learning and Cybernetics  Guangzhou, 18-21 August 2005         Figure 4  RMS velocity error in case of Pd=0.76         Figure 5  RMS position error in case of Pd=0.58          Figure 6  RMS velocity error in case of Pd=0.58  Table 1 The emanative times comparison for sequential MSJPDA and SD-CMSJPDA algorithm  Pd N A  0.97 0. 76 0.58 Sequential MSJPDA 2 11 17 SD-CMSJPDA 0 3 5 Pd denotes detection probability, N denotes emanative 


Pd denotes detection probability, N denotes emanative times, A denotes the kind of algorithm Table 1 shows the summation of emanative times for sequential MSJPDA and SD-CMSJPDA algorithm in 50 Monte Carlo simulations. From table 1 , it is shown that the stability of SD-CMSJPDA is better than that of sequential MSJPDA as the detection probability varied Figure 1,2 show the RMS errors for position and velocity in case of Pd=0. 97, respectively; Figure 3,4 show the RMS errors for position and velocity in case of Pd=0.76 respectively; Figure 3,4 show the RMS errors for position and velocity in case of Pd=0.58, respectively. From the figures we can see that the average RMS position error is lower for the SD-CMS JPDA algorithm. We also see that the state estimation precision of sequential MSJPDA get worse as the detection probability decreases The reasons for these simulation results lies:1 state estimation precision will get worse when the detection probability decrease;2 algorithm is to process measurement from each sensor using single sensor JPDA algorithm sequentially. Therefore the estimation error from each sensor will be accumulated Moreover, the sequential MSJPDA algorithm can  t improve the joint detection probability of the multisensor system The estimation error of the SD- CMSJPDA  algorithm will not be accumulated for it processes the measurement from each sensor directly in the mean time .What  s more the new method can greatly improve the joint detection probability of the multisensor system. Therefore, the tracking performance of SD-CMSJPDA algorithm is better than that of sequential MSJPDA. Algorithm All of the simulations are run in the personal computer with a 2.0G CPU and a 256M memory. The average cost time per step is 0.0251 in the sequential implementations of MSJPDA algorithm. And the average cost time per step is 0.0282 in the sequential implementations of MSJPDA algorithm. According to the results we can see that there is few difference in real time between the new method and the sequential   MSJPDA when there is not so many sensors and targets 568 Proceedings of  the Fourth International Conference on Machine Learning and Cybernetics  Guangzhou, 18-21 August 2005  5. Conclusion In order to solve the problem of multisensor multi target tracking, a new centralized multisensor  joint probabilistic data association  algorithm is proposed in this paper. The simulation results shows that the tracking performance of the new algorithm is better than that of the sequential MSJPDA algorithm The computational complexity of the new method will increase as the number of sensors and targets grow Therefore, how to improve the real time of SD- CMSJPDA algorithm will be pay attention References 1] He You, Wang Guohong, Lu Dajin, Peng Yingning Multisensor Information Fusion With Application[M Publishion House of Electronics Industry. 2000, Beijing.  [11] B..Zhou and N.K.Bose Multitarget  Tracking in Clutter:Faste Algorithms for Data Association .IEEE Transaction on Aerospace and Electronic Systems 1993,29\(2 2] Bar-shalom,Y\(Ed Applications and Advances,2: Norwood,MA Artech  House, 1992 3] L.Y. Pao, C.W.Frei. A Comparison of Parallel and Sequential Implementation of a Multisensor Multitarget Tracking Algorithm. Proc. 1995 American Control Conf. Seattie, Washington,June 1995 1683~1687 


4] K. Chang, C. Chong, Bar-Shalom, Joint Probabilistic Data Association in Distributed Sensor Networks IEEE Transactions on Automatic Control, AC-31\(10 octobre 1986 5] Bar-shalom, Multitarget Multisensor Tracking Advanced Application ,:YBS Publishing, 1990 6] Bar-shalom, Multitarget Multisensor Tracking Principles and Techenices ,:YBS Publishing, 1995 7] Hu Wenlong, Mao shiyi, Multisensor Data Association Based on Combinatorial Optimization[J]. Journal of Systems Engineering and Electronics . 1997 NO.1,1~9 8] Pattipati K R, Passive Multisensor Data Association Using a New Relaxation Algorithm.In Multitarget-Multisensor Tracking: Advanced and Applications,Y.Barshalom,Norwood,MA:Aretech,199 0 9] Deb S,et al, An S-Dimentional Assignment Algorithm for Track Initiation ,Proc. Of the IEEE Int. Conf Systems Engineering, Kobe, Japan,Sept 1992 527~530 10] Deb S,et al, A Multisensor-Multitarget Data Association Algorithm for Heterogeneous Sensors[J].IEEE Trans. on AES 1993 ,29 \(2 560~568 12] Bar-shalom,Y.,and Fortmann,T.E  Tracking and Data Association  New York:Academic press,1988 13] J,A,Roecher and G.L.Phillis,Suboptimal Joint Probabilistic Data Association .IEEE Transaction on Aerospace Electronic Systems.1993,29\(2 14] J,A,Roecker,A Class of Near Optimal JPDA Algorithm IEEE Transaction on Aerospace and Electronic Systems,1994,30\(2 15] Han Yanfei, Analysis and Improvement of Multisensor Multitarget Probabbilistic Data Association Filting Algorithm[J].  Journal of Systems Engineering and Electronics, 2002, Vol.24, 36~38  569 pre></body></html 


dense data sets for evaluating pattern mining algorithms These two data sets are obtained from IBM Almaden at http://www.almaden.ibm.com/cs/quest/demos.html. Recently, theMAFIA algorithm [6] was proposed to ef?ciently discover maximal frequent patterns. As shown in their paper, MAFIA can be several orders better than some alternatives, such as DepthProject, for mining maximal frequent patterns. Hence, we chose MAFIA as the base line for our performance evaluation. Finally, please note that only the size-2 patterns are generated in the ?rst BFS phase Experimental Platform We implemented the MHP algorithms using C++ and all experiments were performed Proceedings of the 16th IEEE International Conference on Tools with Artificial Intelligence \(ICTAI 2004 1082-3409/04 $20.00  2004 IEEE on a Pentium III    MHz PC machine with    megabytes main memory, running Linux Redhat 6.1 operating system 5.2. A Performance Comparison 100 1000 10000 100000 1e+06 1e+07 1e+08 1e+09 1e+10 1e+11 0.02 0.025 0.03 0.035 0.04 0.045 0.05 0.055 0.06 N um be r o f C he ck ed P at te rn s Support threshold Mafia Min_Conf=0 Min_Conf=0.1 Min_Conf=0.3 Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 


Figure 4. The Number of Checked Patterns on the Pumsb* Data Set 10 100 1000 10000 100000 0.02 0.025 0.03 0.035 0.04 0.045 0.05 0.055 0.06 R un T im e s ec  Support Threshold Mafia Min_Conf=0 Min_Conf=0.1 Min_Conf=0.3 Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 5. The RunTime Comparison on the Pumsb* Data Set Figure 4 shows the number of patterns that MHP and MAFIA have to check during the pattern mining process on the pumsb* data set. As can be seen, for MHP, the number of checked patterns is increased with the decrease of the h-con?dence threshold. However, the number of checked patterns of MHP can be signi?cantly smaller than that of MAFIA even if a low h-con?dence threshold is speci?ed To check a pattern, we need to count the support of the patterns. Counting the support of a pattern is the most timeconsuming task during the pattern mining process, since we need to retrieve all the transactions which include one of its sub-pattern, or for Ma?a, retrieve all the bit of the bitmap of this pattern [6]. Therefore, an algorithm is more ef?cient if smaller number of patterns need to be checked 100 1000 10000 100000 1e+06 1e+07 1e+08 1e+09 0.1 0.2 0.3 0.4 0.5 0.6 0.7 N 


um be r o f C he ck ed P at te rn s Support Threshold Mafia Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 6. The Number of Checked Patterns on the Pumsb Data Set 10 100 1000 10000 0.1 0.2 0.3 0.4 0.5 0.6 0.7 R un T im e s ec  Support Threshold Mafia Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 7. The RunTime Comparison on the Pumsb Data Set The runtime comparison of MHP and MAFIA on the Pumsb* data set is shown in Figure 5. In the ?gure, we can observe that the runtime of MHP can be signi?cantly reduced with the increase of h-con?dence thresholds. Also the runtime of MHP can be several orders of magnitude less than that of MAFIA even if the h-con?dence threshold is as low as 0.3. The reason is that the number of checked patterns of MHP is sign?cantly smaller than that of MAFIA Similar results are also obtained from the pumsb data set as shown in Figure 6 and Figure 7. For the pumsb data set the number of checked patterns of MHP is much smaller 


than that of MAFIA and the runtime of MHP can be significantly less than that of MAFIA 5.3. The Effect of the MHP Algorithm on Finding Maximal Hyperclique Patterns Figure 8 and Figure 9 show the number of maximal patterns identi?ed byMHP andMAFIA on Pumsb* and Pumsb data sets respectively. As can be seen, the number of maximal hyperclique patterns identi?ed by MHP can be orders of magnitude smaller than the number of maximal frequent patterns identi?ed by MAFIA. In other words, the number Proceedings of the 16th IEEE International Conference on Tools with Artificial Intelligence \(ICTAI 2004 1082-3409/04 $20.00  2004 IEEE 100 1000 10000 100000 1e+06 1e+07 1e+08 1e+09 0.02 0.025 0.03 0.035 0.04 0.045 0.05 0.055 0.06 N um be r o f C ou nt ed P at te rn s Support Threshold Mafia Min_Conf=0 Min_Conf=0.1 Min_Conf=0.3 Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 8. The Number of MFI/MHP Patterns in the Pumsb* Data Set 100 1000 10000 100000 1e+06 


1e+07 1e+08 0.1 0.2 0.3 0.4 0.5 0.6 0.7 N um be r o f C ou nt ed P at te rn s Support Threshold Mafia Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 9. The number of MFI/MHP Patterns in the Pumsb Data Set of maximal hyperclique patterns is much easier to manage than that of maximal frequent patterns. Indeed, in realworld applications, it is dif?cult to interpret several million maximal frequent patterns. However, it is possible to interpret the results of maximal hyperclique pattern mining In addition, due to the memory limitation, we cannot extract maximal frequent patterns with MAFIA on the Pumsb data set if the support threshold is less than 0.4, as shown in Figure 7. In contrast, MHP can identify maximal hyperclique patterns when the support threshold is 0.1, if we set the h-con?dence threshold to 0.5. In other words, MHP has the ability to identify patterns which can be dif?cult to identify for MAFIA. Hence, MHP can better explore the pattern space and ?nd interesting patterns at low levels of support 6. Conclusions and Future Work In this paper, we present a two-phase Maximal Hyperclique Pattern \(MHP best features of both the BFS strategy and the DFS strategy. More speci?cally, we adapted DFS pruning methods such as equivalence pruning, to an apriori-like approach In addition, we proved the correctness and completeness of the MHP algorithm. Finally, our experimental results show that the MHP algorithm can be several orders of magnitude faster than standard maximal frequent pattern mining algorithms and has the ability to identify patterns at extremely low levels of support in dense data sets There are several directions for future work. First, in 


this paper, we only generate the size-2 patterns in the BFS phase. It will be interesting to investigate the impact on the performance if the ?rst phase is stopped at a deeper level Also, the projection is a very ef?cient method for ?nding patterns, especially for parallel implementation of pattern mining algorithms [1]. We plan to adapt the projection ideas into our algorithm and design an ef?cient parallel algorithm for mining maximal hyperclique patterns References 1] R. Agarwal, C. Aggarwal, and V. Prasad. A Tree Projection Algorithm For Generation of Frequent Itemsets. pages 350 371, Feb 2001 2] R. Agrawal, T. Imielinski, and A. Swami. Mining Association Rules between Sets of Items in Large Databases. In Proc. of the ACM SIGMOD Conference on Management of Data, pages 207216,May 1993 3] R. Agrawal and R. Srikant. Fast Algorithms for Mining Association Rules. In Proc. of the 20th Intl Conference on Very LargeData Bases, 1994 4] R. Bayardo. Ef?ciently mining long patterns from databases In Proc. of the ACM SIGMOD Conference, 1998 5] R. Bayardo and R. Agrawal. Mining the Most Interesting Rules. In Proc. of the ACM SIGKDD Conference, 1999 6] D. Burdick, M. Calimlim, and J. Gehrke. Ma?a: AMaximal Frequent Itemset Algorithm for Transactional Databases. In Proc. of IEEE Conf. on Data Engineering, 2001 7] Y. Huang, H. Xiong, W. Wu, and Z. Zhang. A Hybrid Approach for Mining Maximal Hyperclique Patterns. In In Technical Report UTDCS-34-04, Department of computer science, University of Texas - Dallas, 2004 8] J.Han, J.Pei, and Y. Yin. Mining Frequent Patterns without Candidate Generation. In Proc. of the ACM SIGMOD International Conference on Management of Data, 2000 9] M.J.Zaki and C.Hsiao. ChARM: An ef?cient algorithm for closed itemset mining. In Proc. of 2nd SIAM International Conference on Data Mining, 2002 10] R.Rymon. Search through Systematic Set Enumeration. In Proc. Third Intl Conference on Principles of Knowledge Representation and Reasoning, 1992 11] H. Xiong, M. Steinbach, P.-N. Tan, and V. Kumar. HICAP: Hierarchial Clustering with Pattern Preservation. In Proc. of 2004 SIAM International Conference on Data Mining \(SDM 12] H. Xiong, P.-N. Tan, and V. Kumar. Mining Strong Af?nity Association Patterns in Data Set with Skewed Support. In Proc. of the Third IEEE International Conference on Data Mining \(ICDM Proceedings of the 16th IEEE International Conference on Tools with Artificial Intelligence \(ICTAI 2004 1082-3409/04 $20.00  2004 IEEE 





