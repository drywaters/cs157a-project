The WCCI 2008 Simulated Car Racing Competition Daniele Loiacono Julian Togelius Pier Luca Lanzi Leonard Kinnaird-Heether Simon M Lucas Matt Simmerson Diego Perez Robert G Reynolds Yago Saez Abstract 227 This paper describes the simulated car racing competition held in association with the IEEE WCCI 2008 conference The organization of the competition is described along with the rules the software used and the submitted car racing controllers The results of the competition are presented followed by a discussion about what can be learned from this competition both about learning controllers with evolutionary 
methods and about competition organization The paper is coauthored by the organizers and participants of the competition I I NTRODUCTION In conjunction with the IEEE World Congress on Computational Intelligence WCCI 2008 we organized a simulated car racing competition where the goal was to learn or otherwise develop a controller for a car in the TORCS opensource racing game This paper describes the motivations for holding the competition the software developed the rules applied the entries submitted and the competition results There are several reasons for holding competitions as part 
of the regular events organized by the computational intelligence community A main motivation is to improve benchmarking of learning algorithms Benchmarking is frequently done using very simple testbed problems that might or might not capture the complexity of real-world problems When researchers report results on more complex problems the technical complexities of accessing running and interfacing to the benchmarking software might prevent independent validation of and comparison with the published results Here competitions have the role of providing software interfaces and scoring procedures to fairly and independently evaluate competing algorithms and development methodologies 
Another strong incentive for running these competitions is that it motivates researchers Existing algorithms get applied to new areas and the effort needed to participate in a competition is or at least should be less than it takes to come up with the results for and write a completely new paper Competitions might even bring new researchers into the computational intelligence 002elds both academics and non-academics One of the reasons for this especially for games-related competitions is that it simply looks cool Daniele Loiacono and Pier Luca Lanzi are with the Department of Computer Science Politecnico Di Milano Italy Julian Togelius is 
with IDSIA Galleria 2 6298 Manno-Lugano Switzerland Leonard Kinnaird-Heether and Robert G Reynolds are with Wayne State University USA Simon M Lucas is with the University of Essex Colchester CO4 3SQ United Kingdom Matt Simmerson is an independent researcher residing in New Zealand Diego Perez and Yago Saez are with the Universidad Carlos III de Madrid Madrid Spain emails loiacono@elet.polimi.it julian@idsia.ch lanzi@elet.polimi.it lkinnaird@wayne.edu sml@essex.ac.uk mattsimmerson@gmail.com akilascartas@gmail.com reynolds@cs.wayne.edu yago.saez@uc3m.es In 2007 simulated car racing competitions were organized as part of the IEEE Congress on Evolutionary Computation 
CEC and Computational Intelligence and Games Symposium CIG These competitions used a graphically and mechanically simpler game Partly because of the simplicity of the software these competitions enjoyed a good degree of participation The organization submitted entries and results of these competitions were recently published in This competition was similar to the 2007 competitions in its overall idea and execution but there are several important differences The main difference is that we decided to build the event around a much more complex car racing game the open-source racing game TORCS While the main reason for using this game was that the more complex car simulations 
especially the possibility for having many cars at the track at the same time with believable collision handling poses new challenges for the controllers to overcome other reasons included the possibility of convincing e.g the game industry that computational intelligence algorithms can handle 223real\224 games and not only academically conceived benchmarks and the increased attention that a more sophisticated graphical depiction of the competition generates see 002gure 1 Fig 1 The TORCS game II C OMPETITION SETUP In what follows we will describe the TORCS game the 
modi\002cations we did to allow communication with the game clients the clients and their interfaces example controllers and training software and the rules of the competition A The TORCS game The Open Racing Car Simulator TORCS is a stateof-the-art open source car racing simulator It falls somewhere between being an advanced simulator like recent 


Fig 2 The architecture of the API developed for the competition commercial car racing games and a fully customizable environment like the ones typically used by computational intelligence researchers for benchmark purposes From one hand TORCS features a sophisticated physics engine that takes into account many aspects of the racing car e.g collisions traction aerodynamics fuel consumption etc as well as a 3D graphics engine for the visualization of the races On the other hand TORCS was not been only conceived as a free alternative to commercial racing games but it was speci\002cally devised to make it as easy as possible to develop your own car controller In fact the controllers are implemented as separated software modules so that it is easy to develop a new controller and to plug it into the game In addition TORCS does not only provide a complete and complex game environment but it also provides a lot of game content i.e several tracks car models and controllers etc resulting in a countless number of possible game situations B Competition-speci\002c software modi\002cations In order to develop their car controllers the competitors have been provided with a speci\002c software interface developed on a client/server basis Figure 2 shows the architecture of such interface The controllers run as external programs and communicate with a customized version of TORCS through UDP connections Each controller perceives the racing environment through a number of sensor readings which would re\003ect both the surrounding environment the tracks and the opponents and the current game state and they could invoke basic driving commands to control the car The complete list of sensors is reported in Table I and includes range\002nders to perceive the nearby track limits as well as the distance of nearby opponents the current speed the engines RPM the current gear the fuel level etc we refer the interested reader to the software manual of the competition for additional details T able II reports all the driving commands besides the rather typical driving commands i.e the steering wheel the gas pedal the brake pedal and the gear change a meta-command is available to reset the state of the race from the client-side Controllers had to act quickly on the basis of the most recent sensory information to properly control the car a slow controller would be inherently penalized since it would be working on lagged information To make it easy to enter the competition TABLE I D ESCRIPTION OF AVAILABLE SENSORS    Name  Description    angle  Angle between the car direction and the direction of the track axis    curLapTime  Time elapsed during current lap    damage  Current damage of the car the higher is the value the higher is the damage    distFromStartLine  Distance of the car from the start line along the track line    distRaced  Distance covered by the car from the beginning of the race    fuel  Current fuel level    gear  Current gear 1 is reverse 0 is neutral and the gear from 1 to 6    lastLapTime  Time to complete the last lap    opponents  Vector of 18 sensors that detects the opponent distance in meters range is within a speci\002c 10 de grees sector each sensor covers 10 degrees from 031 2 to  031 2 in front of the car    racePos  Position in the race with to respect to other cars    rpm  Rumber of rotation per minute of the car engine    speedX  Speed of the car along the longitudinal axis of the car    speedY  Speed of the car along the transverse axis of the car    track  Vector of 19 range 002nder sensors each sensors represents the distance between the track edge and the car Sensors are oriented every 10 degrees from 031 2 and  031 2 in front of the car Distance are in meters within a range of 100 meters When the car is outside of the track i.e pos is less than 1 or greater than 1 these values are not reliable    trackPos  Distance between the car and the track axis The value is normalized w.r.t to the track width it is 0 when car is on the axis 1 when the car is on the left edge of the track and 1 when it is on the right edge of the car Values greater than 1 or smaller than 1 means that the car is outside of the track    wheelSpinVel  Vector of 4 sensors representing the rotation speed of the wheels   a client with simple APIs as well as a sample programmed controller were provided for C and Java languages and for Windows Mac and Linux operative systems C Rules and organization In brief the goal of the competition was to learn or otherwise design a controller which could be able to race for a certain number of laps on a set of three unknown tracks alone or against other controllers Altough the aim of the competition was to encourage the application of computational intelligence techniques to the design of car controllers in TORCS also human programmed controllers were accepted as entries Thus the competitors were free either to use the APIs and the sample controller provided to develop their controllers or they could develop their own solution from scratch The only constraint was to submit a 002nal controller that follows the same communication protocol de\002ned in the client provided To evaluate the performance of the submitted controllers we measured the distance raced 


TABLE II D ESCRIPTION OF AVAILABLE EFFECTORS    Name  Description    accel  Virtual gas pedal 0 means no gas 1 full gas    brake  Virtual brake pedal 0 means no brake 1 full brake    gear  Gear value    steering  Steering value 1 and 1 means respectively full left and right that corresponds to an angle of 0.785398 rad    meta  This is meta-control command 0 do nothing 1 ask competition server to restart the race   by each controller within 10000 game tics corresponding to 200s of simulated time Then a tournament of competitive races among the best performing controllers was set to elect the winner of the competition and to validate that controllers perform well also in the presence of other cars The evaluation of the submitted controllers was run by the organizers just before the 2008 IEEE World Congress on Computational Intelligence more details on the evaluation process are provided in a later section The set of TORCS tracks used for the 002nal evaluation was not known in advance by the competitors to promote the submission of controllers with a reliable performance on a large range of tracks in spite of controllers tuned on a small set of tracks III S UBMITTED CONTROLLERS A Leonard Kinnaird-Heether and Robert Reynolds The controller was designed from scratch using Java The initial phase of the development of the controller focused on creating a simple untrained system that could navigate the track without getting stuck or crashing too often This initial stage provided a basic framework for the controller that governed three basic behaviors acceleration steering shifting and error correction Acceleration is based on setting target speeds These target speeds are governed by a set of speed limit variables that will be discussed in depth later in this section Simply put the controller will tell the car to accelerate if its current speed is less than the target speed not accelerate if the current is less than or equal to 10 mph over the target speed and brake if the current speed is greater than 10 mph over the target speed These instructions are in the form of rules The Cultural Algorithm is used in the second phase to learn these rules for given tracks Steering is performed by 002nding the furthest distance to the edge of the track by using the distance readings gained from communication with the server The angle that corresponds to the furthest distance is then used as the current steering angle normalized to 002t with a range of 1 This calculation is made in every game turn thus reducing the chance of oversteering The controller will modify the turning angle as the car passes through a turn This is due to the fact that the angle corresponding to the furthest distance to the edge of the track will tend to move toward 0 degrees\(straight as the turn progresses In this way the controller 002nds an adequate if not the best method of navigating a turn In addition to this there is also a function that attempts to return the car to the center of the track when it is driving in a straight line This function helped smooth out some problems that occurred during turning but caused a small problem later in the training of the controller Shifting is done based on readings retrieved from the server for the current Revolutions Per Minute\(RPM reading for the car When the RPM reading reaches a certain point the controller will send a signal to either shift up or down In the implementation the controller was required to wait a short period of time after shifting before deciding whether or not to shift again in order to avoid oscillation Error correction in the controller falls into three categories whether or not the car is stuck whether or not the car is off the track and whether or not the car is going in the wrong direction If the car does not move farther than a speci\002ed distance over one game turn the controller increments a counter to indicate that the car may be stuck When this counter reaches a certain level the controller directs the car to drive in reverse for a number of game turns By doing this the car should have backed up far enough to be able to turn out of the situation that led it to get stuck If the car is detected to be beyond the boundary of the track the controller will direct it to slow down and turn in the direction that corresponds to the opposite side of the track If the controller detects that the car is traveling at an angle that is greater than 90 degrees from the track normal 0 degrees the controller indicates that the car is traveling in the wrong direction The controller then directs the car to reduce speed and turn in the direction that will provide it the fastest way of returning to the correct direction The reduction in speed is necessary to ensure that the car has enough room to successfully turn around If multiple error states are detected at the same time the controller handles them hierarchically The stuck state commands the highest priority followed by the wrong direction state and then the off the track state 1 Learning phase In our view race car driving is a social activity and the drivers behavior in terms of using the kinematic functions discussed above needed to re\003ect that activity In particular we viewed the race cars as forming a pack or swarm Thus the rules for acceleration that we used need to learn within a social context This was an ideal context for the use of Cultural Algorithms The Ja v abased Cultural Algorithm Toolkit CAT that uses an agentbased simulation environment REPAST was the framework in which the learning task was expressed The goal of the learning was to learn driving rules that are consistent with the two basic kinematic activities of agents moving in a swarm orientation relative to the swarm's direction and spacing between agents so that collisions are less likely These were implicit factors in the 002tness function used to train the driver Once the initial controller was completed the system had to be tailored so that it could interface with the cultural algorithms toolkit Though several methods were considered 


the decision was made to train the controller to optimize the speed during turns To accomplish this the concept of a speed limit as mentioned previously in this paper was introduced Essentially this concept provides that the controller will direct the car not to travel faster than a certain speed when navigating a turn with a speci\002c angle by setting its target speed equal to the current speed limit To accomplish this ten variables were introduced to the controller to hold the speed limit values These variables correspond to straight ahead turning 10 degrees 20 degrees and so on up to 90 degrees CAT requires that a testing program specify four things the dimensions of the problem the range of values that are acceptable for each dimension what type of numeric value each dimension uses and a 002tness function In this case the testing program de\002nes the dimension number as 10 corresponding to the number of speed limit variables The range of each dimension was determined to be because 300 mph is roughly the fastest that the speci\002ed car can safely travel on any track Since the controller communicates speed to TORCS as a 003oating point number the testing program was set to treat all values generated for each dimension as real numbers rather than as integers In a typical application of the CAT the 002tness function is an equation that can be quickly calculated In this case it was concluded that the best 002tness function for training the controller would be to use the distance traveled over a set number of game turns To get the 002tness function the TORCS system had to be used with the controller and the generated speed limit values To improve ef\002ciency whenever a new set of dimension values was tested the 002tness was stored in a list This way if the 002tness value for that speci\002c set of dimension values was ever needed again the testing program would not have to spend the time waiting for it to be calculated again Thus when all input values given to the controller were the same it would always return the same result 2 Race results In examining the videos of the race 002nal the social aspect of the learned behavior is clear Our driver tended to 002nd gaps in the pack and slip into them in order to maintain speed and direction Thus it used pack information implicitly in its driving rules The main weakness with the approach is that when it took the lead and extricated itself from the pack it no longer had the pack information to rely on to regulate its speed So it tended to over accelerate and spin out It was clear that when the driver had extricated itself from the pack that we needed to augment the driving rules and variables to compensate for this B Simon M Lucas Hacked controller The entry HackedController was based on a modi\002cation of the supplied SimpleSoloController SimpleSoloController referred to as the original controller for the rest of this section is able to drive around most tracks without crashing It does this by keeping close to the center of the track by not driving too quickly and by limiting the maximum steering angle to avoid excessive skidding On one of the Oval tracks it was possible to greatly improve its performance simply by increasing its target speed However if this was done without taking other compensating measures then there was too great a likelihood of crashing on more complicated tracks I did most of the testing on E-Track 3 as this has a good mix of shallow curves tight curves and straight sections On three runs the original controller scored an average 002tness of 4959 metres Two of the runs had a 002tness of over 5500 but on one run it crashed on a tight bend and scored only 3733  When SimpleSoloController crashes it often fails to recover and may waste the rest of a 002tness evaluation stuck against a barrier when simple reversing manoeuvre would free it The main approach I took to optimising a controller based on this was to increase the default top speed while adding in some measures to try to reduce the risk of crashing SimpleSoloController had a target speed of 100 km/h but increasing this without some compensating measures could be counter-productive The competition API provides an array of range-\002nder style sensors A simple approach was taken to summarise the information from these If any of the range-\002nders fell below their maximum value then the car went into a type of safety mode and set the target speed to 50 Furthermore if the current speed was greater than the breakSpeedLimit a newly created variable optimised to be 105 then the cars brakes were applied and acceleration set to false However if the range 002nders were all at maximum then this indicated a straight section immediately ahead and also that the car was heading close to straight along it Under these conditions the target speed was set to 250 Other changes were as follows If the car position deviates from the center of the track by more than trackPositionLimit then steering mode is engaged Under steering mode the target speed is reduced by a factor of two in the original controller from 100 to 50 and by a factor of 1.5 in the hacked controller from 250 to 167 The variable trackPositionLimit was set to 0.3 in the original and 0.15 in the hacked version with the effect that the car makes more effort to stay close to the centreline of the track In the original controller the target angle to the track is made equal to the track position In the hacked version this value is multiplied by a variable trackFac After optimisation this had value of 0.38 This means that smaller adjustments are made to the steering in order to reduce the risk of skidding If the selected steering angle is small  0.01 then it is set to zero in the original controller In the hacked version this was changed to 0.005 Its not clear whether this logic makes much difference for either controller but the thinking behind it is to prevent the car from constantly making tiny adjustments to the steering The 002nal signi\002cant change was to make the steering adjustment speed dependent In the original controller a steering adjustment was made that depended only on the distance from the center line of the track and the angle to that center line In the hacked controller the maximum steering angle reduced as the speed increased since setting a large steering angle at a high speed will most likely induce a skid and the hacked controller is not sophisticated enough to maintain control in a skid The variable steeringFac was 


introduced to adjust the slope of the line controlling the dependence of the steering on the speed The original intention with hacked controller was to extract the main variables into a vector and then use an evolutionary strategy to evolve the values of those However in order to meet the competition deadline there was insuf\002cient time for this and instead the values of the variables were optimised by hand The 002rst approach was to observe the behaviour of the car as it was being driven by the hacked controller and then to make adjustments to the variables to correct problems that were observed Due to the non-linear interactions of the variables and the excessive time spent watching the car in visual mode this approach proved to be ineffective Best results were obtained by running the simulation in results only mode which allows evaluations to be done much faster than real-time and therefore many more settings of the variables can be tried The approach taken was a kind of direct policy optimisation where variables were initially set based on intuition or taken from the SimpleSoloController Trials were made with each one adjusted by around 10 or 20 of its current value The 002tness of each setting was noted and I looked for patterns in values of variables or combinations of variables that worked well In total around 50 trials were made The variables adjusted in this way together with their 002nal values in parentheses were steeringFac\(0.35 trackFac\(0.38 breakSpeedLimit\(105 trackPositionLimit 0.15 On three trials on E-Track 3 this hacked controller scored 7815 7776 and 7811 giving an average of 7801 a signi\002cant improvement over the original controller In summary hacked controller represents a somewhat hastily designed effort to use the available sensor data to improve on the supplied SimpleSoloController The supplied controller was extended in the ways described above and a kind of manually operated evolutionary process was used to tune the parameters This was found to me more effective than tuning the parameters by trying to directly observe their effects on speci\002c aspects of the driving behaviour It would be interesting to try evolving these values using an evolution strategy to see whether the manually chosen parameters can be signi\002cantly improved on they probably can C Matt Simmerson NEAT controller The idea behind this controller was to evolve a neural network that controlled a racing car around many tracks equally well based on a set of input data provided by the racing environment The added complication for my controller was to evolve the network topology given no domain knowledge a priori 1 De\002ning the controllers The controller was trained using the NEAT algorithm that e v olv ed populations of neural networks and was created using the NEAT4j software an implementation of the NEAT algorithm The NEAT4j implementation allows for the initial selection of a sub set of 3 inputs of the available 29 sources of input data The 3 outputs controlled the power in the range the gear change in the range and the steering in the range  The throttle and brak e actions were Boolean so the power output node was used to apply throttle for 277 0.6 or apply the brake for 241 0.4 For the middle values then the neither the throttle or brake would be applied and hence the controller would coast The gear change would attempt to change up if the output node was 277 0.5 and change down otherwise The gears selected were limited to R N 1 2 3 4 5 As all the output nodes used a sigmoid acti v ation function the actual values created as the controller actions were scaled from to the appropriate range The subset of inputs from the table de\002ned above available for this controller were 1 Current speed 2 Angle to track axis 3 The 19 track sensors 4 Track position with respect to left and right edges 5 Current gear selection 6 The 4 wheel spin sensors 7 Current RPM All the inputs were scaled to be in the range or 0,1 depending on the sign of the input This prevents large input values completely swamping other smaller input signals The initial controllers were very simple with 3 randomly selected input nodes connected to one of the output nodes such that all output nodes were connected to exactly one input node but an input node could be connected to more than one output node 2 Controller evolution The NEAT algorithm in essence uses a genetic algorithm to create a neural network topology from a given genome Each genome consists of a set of node genes that describe an individual neuron and connection genes which describe a nodes connections The population size was just 100 as this was a reasonable compromise between evolution and the time it took for each epoch The mutation and crossover operators were those de\002ned by the NEAT algorithm The parent selector function was a tournament round where the allowed parents were pitted against each other with the winner taking the spoils i.e the 002ttest Recurrency was allowed in this experiment 3 Training the controllers The car was trained on just one track G3 which was not one selected for the initial valuation This track was selected as it had some varying turns i.e left right curve and also straights of varying lengths into the various corners Ideally for the sake of generalisation I would have liked to train the cars over several tracks however the current version of the TORCS environment prevented this 4 Controller evaluation The car was tested on the track for a maximum of 4000 steps equivalent to around 80 seconds real time If the car sustained more than 100 points of damage out of a maximum of 10000 the evaluation for that car was aborted The overall 002tness of the car was calculated thus F c  2 003 Dr  do  speedmax  C 1 1 Dr was the distance raced value reported by TORCS engine and could be both positive and negative 


2 d was the value reported by the TORCS engine and has a maximum value of 10000 3 o is a measure of how much the car stayed on the track This was necessary to prevent the car using the barriers as a guide with no damage penalty Until this variable was added it prevented any really successful controllers The edge of the track was represented by 1 left and 1 right The outside value was calculated as 0 if the car was in these limits and Abs\(track position 1 for values outside these edges 4 Max speed was calculated throughout the cars trial based on the speeds reported by the TORCS engine This was to try and reward fast cars early on that crashed as the name of the game is speed 5 C was used to ensure the 002tness value was always positive and was set to 10000 Negative values were created when cars went the wrong way round the track or had high-speed crashes near the start resulting in large damage Whilst the 4000 time steps used for evaluation represented 80 seconds real time the TORCS engine allowed a non-GUI version which was evaluated in around 3-4 seconds With the population was set to 100 each evolutionary epoch lasted 400 seconds The entry for Neat4J was selected from the winning phenotype from the 170th generation i.e nearly 19 hours on my dual core laptop This had a good level of performance over a number of different track types e.g oval twisty etc D Diego Perez and Yago Saez Rule-based controller The idea of this controller is to evolve a set or rules that drives a vehicle using sensors as input data The usage of sensors to obtain autonomous driving has been addressed by numerous researchers 9 10 11 as well as the use of evolutionary algorithms in this 002eld 13 14 1 Input data effectors and rules The input data is discretized from the values of four sensors  angle  discretized to where 0 means the smaller angles trackPos  with a discretization performed in a range where 0 means centered on the track and 1 the car near the edges speedX  in a range where 0 means lo wer speed than higher v alues and track  where only three of these sensors have been used front and inmediate sensors on right and left and discretized to a unique range where 0 means that a track edge has been detected beyond 20 meters 1 when the track edge is up to 20 meters and 2 in case no track edge is detected A key part of the design is the usage of symmetry for the 002rst two sensors This concept works using the absolute value of the sensor to match to the proper discretized value The objective of this approach is to avoid duplication of efforts by reducing the search space The effectors of the controller have been designed as follows throttle and brake  where both pedals have been codi\002ed in a common output to avoid non-sense values as full gas in both pedals simultaneously Hence a unique value is applied and both gas pressures are extracted from it steer  codi\002ed as a real number from 1 to 1 and discretized with a precision of 0,1 gear  which changing process consists on increasing the current gear when the rpm value is higher than 6000 and decreasing it if it is below 3000 The discretization and codi\002cation applied over the input data and effectors allows us to create a set of 120 rules where conditional part is composed by the sensors and the actions are formed by acceleration braking and steering These rules compose the base individual 2 Application of an evolutionary rule system Traditional random initialization of individuals used in evolutionary techniques do not work properly in this 002eld because it is almost impossible to obtain a con\002guration that drives the vehicle correctly by chance This is the reason of getting a base individual before evolve it to obtain better results The algorithm used to get this base individual is a generation of a subset of rules that allows the vehicle to end a lap minimizing the angle of the car with the track axis Each one of this rules is created by testing how each allowed combination of acceleration and steering behaves when the condition of the rule is triggered Once we get the base rule set the evolving individual is extracted from it taking all its rules Therefore the individual is composed by a set of rules each one of them formed by condition and effectors that need to be evolved to obtain the controller To evolve this individual the algorithm executes evolutionary steps until a stopping criteria is reached The evaluation of the individual is performed recording lap time and damage suffered setting the 002tness using a linear combination of both values with weights of 0.4 and 0.6 respectively in order to avoid over\002tting to the training circuit In this system we can not decide when a rule is better than another because the behaviour of the individual depends on the whole set of rules used Because of this selection operator has been designed as a random pick-up from the rules pool taking two of them to apply uniform crossover Finally mutation operator is performed over the new rule applying an addition of 006 1 unit to the left part and 006 0  3 to the effectors of the rule obeying limits and codi\002cation precision The next step in this algorithm consists of searching for a rule from the individual where its conditional part is most similar to the new rule This rule is extracted from the pool and the new one substitutes it The new set of rules is then evaluated and its 002tness is compared with the one calculated before inserting that new rule Only if the new rule set is worse the substituted one is retrieved and the new rule is eliminated Results have proved this algorithm to be effective reducing lap times of the base individual in few generations keeping the car damage almost nonexistent The usage of symmetry however brought a side effect that was not expected the car drives in a smoothly zig-zag trajectory centered on the circuit This is because a small steering value can center the vehicle on the track but not necessarily drive it parallel to the track axis Nevertheless the controller 


TABLE III R ESULTS OF THE FIRST STAGE OF THE EVALUATION PROCESS  T HE REPORTED ARE THE MEDIAN OVER 10 RUNS    Entry  Ruudskogen  Street-1  Speedway     Kinnaird-Heether et al  6716.7  3692.9  14406.9    Lucas  4134.2  5502.8  12664.5    Simmerson  5934.0  6477.8  12523.3    Perez et al  3786.9  2984.8  317.3    Tan et al  3443.5  2998-5  10648.2     C Sample Controller  4465.1  4928.8  7464.5    Java Sample Controller  5593.8  2963.2  5689.9   behaved in a reasonable way only with the exception of some speci\002c circuits the oval ones These circuits similar to Nascar tracks have banked curves which make the zig-zag movement completely uncontrollable E Chin Hiong Tan and Kay Chen Tan The entry submitted by Chin Hiong Tan and Kay Chen Tan was developed in a three-step process First the sensory information was aggregated and preprocessed second a parametrized controller based on simple rules was designed 002nally the parameters of controller were optimized using evolution strategies The resulting controller drives in the direction where the range\002nder sensors indicate the largest free distance with a speed dependent on that distance IV R ESULTS The entries were scored through a two stages process which involved three tracks available in TORCS the Ruudskogen the Street-1 and the D-Speedway The 002rst warm up stage was aimed at eliminating particularly bad performing controllers Each controller raced alone in each of the three tracks and its performance was measured as the distance covered in 10000 game tics approximately 200 seconds of actual game time For each of the three selected tracks we run each controller ten times The performance has been computed as the median the 50th percentile over the ten runs to avoid any issue about skewness Table III compares the performance of the 002ve controllers submitted to the one of the two sample programmed controllers provided by the organizers The results show that the controller submitted by Leonard Kinnaird-Heether and Robert Reynolds outperforms the other controllers in all the tracks but the Street-1 track As can be noted the performances of the controllers are highly different among the three tracks but they generally compare well to the performances of the sample controllers provided by the organizers In particular the entries submitted respectively by Leonard Kinnaird-Heether et al by Simon Lucas and by Matt Simmerson the 002rst three controllers reported in Table III performs consistently better than the sample controllers almost in all the three tracks As all the 002ve submitted controllers performed well on the 002rst stage none of them was eliminated from the second stage in which the controllers competed together in each of the three tracks In this stage the task consisted of completing three laps and each controller was scored based on its arrival order TABLE IV R ESULTS OF THE SECOND STAGE OF THE EVALUATION PROCESS  T HE SCORES REPORTED ARE THE MEDIAN OVER 10 RUNS    Entry  Ruudskogen  Street-1  Speedway  Total     Simmerson  10  10  6  26    Kinnaird-Heether et al  4  8  10  22    Lucas  6  6  8  20    Tan et al  5  5  5  15    Perez et al  5.5  4.5  5  14   using the same point system used in F1 10 points to the 002rst controller that completed the three laps 8 points to the second one 6 to the third one 5 to the fourth and 4 to the 002fth one Ten runs for each track were performed using as start grid a random permutation of the competitors in order to test the reliability of the controllers performance Then the score of a controller on one track was computed as the median of the scores obtained during the ten runs The 002nal score for each controller was 002nally computed as the sum of the points collected on each track Table IV shows the 002nal scoreboard Matt Simmerson won the competition with 26 points followed by Leonard Kinnaird-Heether et al with 22 points by Simon Lucas with 20 points by Tan Chin Hiong with 15 points and 002nally by Diego P 264 erez 14 points This results suggest that although the controllers submitted by Kinnaird-Heether and Reynolds is fast the one submitted by Simmerson is more reliable especially in the presence of other controllers Finally it is worthwhile to underline that the second stage of the evaluation process suggested that all the submitted controllers have poor overtaking and obstacle-avoidance capabilities whereas these features are very important to succeed in a racing competition Additional results and a video with the highlights of the competition are available on the webpage of the competition The reason Simmerson's controller won over KinnairdHeether and Reynold's was probably that the latter had been optimized for racing on tracks with smooth curves in the presence of other cars Simmerson's controller had been trained on the 223G3\224 track that included sharp turns like Ruudskogen but on its own Both of these controllers were optimized with stochastic algorithms and it stands to reason that such approaches outperform the hand-tuning used by Lucas V T HE FUTURE OF THE CAR RACING COMPETITION While this competition differed greatly from the competitions organized during 2007 in that a more sophisticated racing game was used there was also a great deal of continuity Not only in that some of the participants of the 2007 competitions also participated in the current competition but also in the similarity of rules and arrangements The organizers believe that this continuity is very important for the competition to be successful We need a high participation level to ensure that a broad spectrum of approaches are represented and regular repetitions of the competition to ensure that the participants have time 


to perfect their approaches Our aim is to ensure further continuity through holding a series of future competitions using gradual re\002nements of the rules and software used in the current competition The following improvement will be made to the software in time for the CIG competition 017 The installation process will be streamlined 017 Reliability will be improved 017 Support for multi-car and multi-track training will be added making it easier to apply co-evolution and incremental evolution 017 More sample controllers and trainers e.g temporal difference learning trainers will be supplied An amusing illustration of the need to improve reliability is that in an early version of the software it was possible to achieve the 002tness value of driving a whole lap simply by slowly driving up to and passing the start line the car starts 100 meters before that line then turning and passing the line again This 003aw is inherent in TORCS presumably because its developers never thought of anyone doing something so bizarre Evolutionary algorithms however are good at coming up with bizarre solutions and Matt Simmerson's algorithm quickly evolved a controller that exploited this bug A patch for this bug is now part of the software package A reviewer of the paper summarizing the previous car racing competitions pointed out that in its current form the competition is not only about learning algorithms It is certainly possible to hand-code a non-learning controller that outperforms the best CI-based controllers Indeed the best controllers that come with the TORCS game developed by the TORCS developers are non-learning and by far outperform all the controllers submitted to this competition so far though they often access information state information that is not directly available through the competition API Of course we hope that future editions of this competition will see CI-based contributions that perform better than the best hand-coded ones and there are no reasons why this should not happen Still it would be interesting to run a version of the competition that compared only the quality of the learning algorithm One way could be to de\002ne a standard e.g neural network-based controller architecture and then provide an interface for a learning algorithm to set the parameters for this controller optimally given a certain numbers of laps around an unknown track The participants would then submit an algorithm rather than a controller to be run and evaluated by the organizers of the competition Another interesting version of the competition would be one where the controllers where presented with a richer but more primitive state description in particular visual data This could come in the form of the full rendered 3D view through the controlled car's windscreen or a part of it Such a state description would ultimately give the controllers more information and thus allow for better driving but would also require more complex controllers Given the various interesting variations on the car racing concept that are possible our plan is to organize editions of the car racing competition in conjunction with several international conferences and at each conference hold both the competition in its original form and some variation on the concept like the ones suggested above VI C ONCLUSION We have described the organization rules and software of the car racing competition in the form it was organized in conjunction with IEEE WCCI 2008 Four out of 002ve participating teams described the architecture and training of their controllers We have also reported the scoring procedure and results of the competition and plans for future competitions We hope that this paper in addition to serving as a record of the competition will provide organizers of similar competitions with inspiration and insights and that the descriptions of the controllers will be useful for researchers working on learning vehicle control in general and for participants in future car racing competitions in particular R EFERENCES  J T ogelius S M Lucas H Duc Thang J M Garibaldi T Nakashima C H Tan I Elhanany S Berant P Hingston R M MacCallum T Haferlach A Gowrisankar and P Burrow 223The 2007 ieee cec simulated car racing competition,\224 Genetic Programming and Evolvable Machines  2008 A v ailable http://dx.doi.org/10.1007/s10710-008-9063-0  223The open raci ng car simulator  224 Online A v ailable http://torcs.sourceforge.net  223Softw are manual of the car racing competition 224 WCCI-2008 A v ailable http://cig.dei.polimi.it/wpcontent/uploads/2008/04/manual  v03.pdf  R G Re ynolds and M Z Ali 223Computing with the social f abric The evolution of social intelligence within a cultural framework,\224 IEEE Computational Intelligence Magazine  vol 3 no 1 pp 18\22630 2008  R G Re ynolds M Z Ali and T  Jayyouzi 223Mining the social f abric of archaic urban centers with cultural algorithms,\224 Computer  vol 41 no 1 pp 64\22672 2008  K O Stanle y  223Ef 002cient e v olution of neural netw orks through complexi\002cation,\224 Ph.D dissertation Department of Computer Sciences University of Texas Austin TX 2004  M Simmerson 223Neat4j homepage 224 2006 Online A v ailable http://neat4j.sourceforge.net  S Baluja and R Caruana 223Remo ving the genetics from the standard genetic algorithm,\224 in Proceedings of the international conference on machine learning ICML  1995  R Sukthankar  S Baluja and J Hancock 223Proto yping intelligent vehicle modules,\224 in Proceedings of the International Conference on Robotics and Automation ICRA  1997  J T ogelius and S M Lucas 223Ev olving controllers for simulated car racing,\224 in Proceedings of the Congress on Evolutionary Computation  2005  227\227 223Ev olving rob ust and specialized car racing skill s 224 in Proceedings of the IEEE Congress on Evolutionary Computation  2006  J Bernard J Gruening and K Hof fmeister  223Ev aluat ion of v ehicle/driver performance using genetic algorithms,\224 Society of Automotive Engineers  1998  D Floreano T  Kato D Marocco and E Sauser  223Coe v olution of active vision and feature selection,\224 Biological Cybernetics  vol 90 pp 218\226228 2004  J T ogelius and S M Lucas 223 Arms races and car races 224 in Proceedings of Parallel Problem Solving from Nature  Springer 2006  223The car racing competition homepage 224 WCCI-2008 Online Available http://cig.dei.polimi.it/?page  id=5 


Table 3 Compressed sizes and number of extracted itemsets f or the itemset selection algorithms Candidate Itemsets S ET P ACK S ET P ACK G REEDY K RIMP Dataset min-sup  sets c  T  c  T  c  T b    sets c  T  c  T  c  T b    sets  bits  sets anneal 175 8837 20777 89.9 103 20781 89.9 69 31196 53 breast 1 9920 5175 63.7 42 5172 63.9 49 4613 30 courses 55 5030 64835 84.9 268 64937 85.1 262 73287 93 mammals 700 7169 65091 83.4 427 65622 84.1 382 124737 125 mushroom 1000 123277 313428 70.9 636 262942 59.5 1225 474240 140 nursery 50 25777 314081 93.0 276 314295 93.1 218 265064 225 pageblocks 1 63599 11961 78.3 92 11967 78.3 95 10911 53 tic–tac–toe 7 34019 23118 92.0 620 23616 94.0 277 28957 159 large candidate family for mushroom  For comparison we use the same candidates for K RIMP  We also compare to S ET P ACK G REEDY  which required 1–12 minutes 7 minutes typically with an exception of 2 1 2 hours for mushroom  Comparing the results of this experiment Table 3 with the results of G REEDY P ACK in the previous experiment we see that the selection process is more strict now even fewer itemsets are regarded as interesting enough Large candidate collections are strongly reduced in number up to three orders of magnitude On the other hand the compression ratios are still very good The reason that G REEDY P ACK produces smaller compression ratios is because it is allowe d to consider any itemset Further the fact alone that even with this very strict selection the compression ratios are generally well below 90 show that these few sets are indeed of high importance to describing the major interactions in the data If we compare the number of selected sets to K RIMP  we see that our method returns in the same order as many itemsets These descriptions require far less bits than tho se found by K RIMP  As such ours are a better approximation of the Kolmogorov complexity of the data Between S ET P ACK and S ET P ACK G REEDY the outcomes are very much alike this goes for both the obtained compression as well as the number of returned itemsets However the greedy search of S ET P ACK G REEDY allows for much shorter running times 8 Discussion The experimentation on our methods validates the quality of the returned models The models correctly detect dependencies in the data while ignoring independencies Only a small number of itemsets is returned which are shown to provide strong compression of the data By the MDL principle we then know these describes all important regularities in the data distribution in detail ef\002ciently and witho ut redundancy This claim is further supported by the high classi\002cation accuracies our models achieve The G REEDY P ACK algorithm generally uses more itemsets and obtains better packing ratios than S ET P ACK  While G REEDY P ACK is allowed to use any itemset S ET P ACK may only use frequent itemsets This suggests that we may able to achieve better ratios if we use different candidates  for example low-entropy sets 16  The running times of the experiments reported in this work range from seconds to hours and depend mainly on the number of attributes and rows of the datasets The exhaustive version S ET P ACK may be slow on very large candidate sets however the greedy version S ET P ACK G REEDY can even handle such families well Considering that our curren t implementation is rather na¨\021ve and the fact that both methods are easily parallelized both G REEDY P ACK and S ET P ACK G REEDY are suited for the analysis of large databases The main outcomes of our models are the itemsets that identify the encoding paths However the decision trees from which these sets are extracted can also be regarded as interesting as these provide an easily interpretable view o n the major interactions in the data Further just consideri ng the attributes used in such a tree as an itemset also allows for simple inspection of the main associations In this work we employ the MDL criterion to identify the optimal model Alternatively one could consider using either BIC or AIC both of which can easily be applied to judge between our decision tree-based models 9 Conclusions In this paper we presented two methods that 002nd compact sets of high quality itemsets Both methods employ compression to select the group of patterns that describe all interactions in the data best That is the data is considere d symmetric and thus both the 0s and 1s are taken into account in these descriptions Experimentation with our methods 
596 
596 


showed that high quality models are returned Their compact size typically tens to thousands of itemsets allow fo r easy further analysis of the found interactions References 1 C  C  A g g a r w a l a n d P  S  Y u  A n e w f r a m e w o r k f o r itemset generation In Proceedings of the ACM SIGACTSIGMOD-SIGART symposium on Principles of Database Systems PODS  pages 18–24 ACM Press 1998 2 R  A g r a w a l  H  M a n n i l a  R  S r i k a n t  H  T o i v o n e n  a n d A  I  Verkamo Fast discovery of association rules In Advances in Knowledge Discovery and Data Mining  pages 307–328 AAAI 1996 3 S  B r i n  R  M o t w a n i  a n d C  S i l v e r s t e i n  B e y o n d m a r k e t baskets Generalizing association rules to correlations In ACM SIGMOD International Conference on Management of Data  pages 265–276 ACM Press 1997 4 S  B r i n  R  M o t w a n i  J  D  U l l m a n  a n d S  T s u r  D y n a m i c itemset counting and implication rules for market basket data In ACM SIGMOD International Conference on Management of Data  pages 255–264 1997 5 B  B r i n g m a n n a n d A  Z i m m e r m a n n  T h e c h o s e n f e w  O n identifying valuable patterns In IEEE International Conference on Data Mining ICDM  pages 63–72 2007 6 T  C a l d e r s a n d B  G o e t h a l s  M i n i n g a l l n o n d e r i v a b l e f r e quent itemsets In Proceedings of the 6th European Conference on Machine Learning and Principles and Practice of Knowledge Discovery in Databases  pages 74–85 2002 7 V  C h a n d o l a a n d V  K u m a r  S u m m a r i z a t i o n c o m p r e s s i n g data into an informative representation In Proceedings of the IEEE Conference on Data Mining  pages 98–105 2005 8 F  C o e n e n  T h e L U C S K D D d i s c r e t i s e d  n o r m a l i s e d A R M and CARM data library 2003 9 G  F  C o o p e r a n d E  H e r s k o v i t s  A B a y e s i a n m e t h o d f o r the induction of probabilistic networks from data Machine Learning  9:309–347 1992 10 T  C o v e r a n d J  T h o m a s  Elements of Information Theory 2nd ed John Wiley and Sons 2006 11 W  D u M o u c h e l a n d D  P r e g i b o n  E m p i r i c a l b a y e s s c r e e n i n g for multi-item associations In ACM SIGKDD Conference on Knowledge Discovery and Data Mining  pages 67–76 2001 12 C  F a l o u t s o s a n d V  M e g a l o o i k o n o m o u  O n d a t a m i n i n g  compression and kolmogorov complexity In Data Mining and Knowledge Discovery  volume 15 pages 3–20 Springer 2007 13 P  D  G r  u n w a l d  The Minimum Description Length Principle  MIT Press 2007 14 J  H a n  H  C h e n g  D  X i n  a n d X  Y a n  F r e q u e n t p a t t e r n mining Current status and future directions In Data Mining and Knowledge Discovery  volume 15 Springer 2007 15 J  H a n a n d J  P e i  M i n i n g f r e q u e n t p a t t e r n s b y p a t t e r n growth methodology and implications SIGKDD Explorations Newsletter  2\(2\:14–20 2000 16 H  H e i k i n h e i m o  E  H i n k k a n e n  H  M a n n i l a  T  M i e l i k  a i nen and J K Sepp¨anen Finding low-entropy sets and trees from binary data In ACM SIGKDD Conference on Knowledge Discovery and Data Mining  pages 350–359 2007 17 S  J a r o s z e w i c z a n d T  S c h e f f e r  F a s t d i s c o v e r y o f u n e x p ected patterns in data relative to a bayesian network In ACM SIGKDD Conference on Knowledge Discovery and Data Mining  pages 118–127 2005 18 S  J a r o s z e w i c z a n d D  A  S i m o v i c i  I n t e r e s t i n g n e s s o f frequent itemsets using bayesian networks as background knowledge In ACM SIGKDD Conference on Knowledge Discovery and Data Mining  pages 178–186 2004 19 A  J  K n o b b e a n d E  K  Y  H o  M a x i m a l l y i n f o r m a t i v e k itemsets and their ef\002cient discovery In ACM SIGKDD Conference on Knowledge Discovery and Data Mining  pages 237–244 2006 20 A  J  K n o b b e a n d E  K  Y  H o  P a t t e r n t e a m s  I n Proceedings of the 10th European Conference on Machine Learning and Principles and Practice of Knowledge Discovery in Databases  pages 577–584 2006 21 P  K o n t k a n e n a n d P  M y l l y m  a k i  A l i n e a r t i m e a l g o r i t h m for computing the multinomial stochastic complexity Information Processing Letters  103\(6\:227–233 2007 22 M  v a n L e e u w e n  J  V r e e k e n  a n d A  S i e b e s  C o m p r e s s i o n picks the item sets that matter In Proceedings of the 10th European Conference on Machine Learning and Principles and Practice of Knowledge Discovery in Databases  pages 585–592 2006 23 M  L i a n d P  V i t  a n y i  An Introduction to Kolmogorov Complexity and its Applications  Springer-Verlag 1993 24 R  M e o  T h e o r y o f d e p e n d e n c e v a l u e s  ACM Trans Database Syst  25\(3\:380–406 2000 25 A  J  M i t c h e l l J o n e s  G  A m o r i  W  B o g d a n o w i c z  B Krystufek P J H Reijnders F Spitzenberger M Stubb e J B M Thissen V Vohralik and J Zima The Atlas of European Mammals  Academic Press 1999 26 K  V  S  M u r t h y  On growing better decision trees from data  PhD thesis Johns Hopkins Univ Baltimore 1996 27 S  N i j s s e n a n d  E Fromont Mining optimal decision trees from itemset lattices In ACM SIGKDD Conference on Knowledge Discovery and Data Mining  pages 530–539 2007 28 N  P a s q u i e r  Y  B a s t i d e  R  T a o u i l  a n d L  L a k h a l  D i s c o vering frequent closed itemsets for association rules Lecture Notes in Computer Science  1540:398–416 1999 29 J  R i s s a n e n  F i s h e r i n f o r m a t i o n a n d s t o c h a s t i c c o m p l e xity IEEE Transactions on Information Theory  42\(1\:40–47 1996 30 A  S i e b e s  J  V r e e k e n  a n d M  v a n L e e u w e n  I t e m s e t s t h a t compress In Proceedings of the SIAM Conference on Data Mining  pages 393–404 2006 31 N  T a t t i  M a x i m u m e n t r o p y b a s e d s i g n i 002 c a n c e o f i t e m s e t s Knowledge and Information Systems KAIS  2008 Accepted for publication 32 N  T a t t i a n d H  H e i k i n h e i m o  D e c o m p o s a b l e f a m i l i e s o f itemsets In Proceedings of the 12th European Conference on Machine Learning and Principles and Practice of Knowledge Discovery in Databases  2008 33 J  V r e e k e n  M  v a n L e e u w e n  a n d A  S i e b e s  C h a r a c t e r i s i ng the difference In ACM SIGKDD Conference on Knowledge Discovery and Data Mining  pages 765–774 2007 34 J  V r e e k e n  M  v a n L e e u w e n  a n d A  S i e b e s  P r e s e r v i n g privacy through data generation In Proceedings of the IEEE Conference on Data Mining  pages 685–690 2007 
597 
597 


