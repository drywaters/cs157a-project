 1 A Reusable Architectural Pattern for Auto-Generated Payload Management Flight Software Alexander Murray 818-354-0111 Jet Propulsion Laboratory California Institute of Technology 4800 Oak Grove Drive Pasadena, CA  91109 alex.murray@jpl.nasa.gov Marcel Schoppers 818-354-9290 Jet Propulsion Laboratory California Institute of Technology 4800 Oak Grove Drive Pasadena, CA  91109 marcel.schoppers@jpl.nasa.gov Steve Scandore 818-353-5146 Jet Propulsion Laboratory California Institute of Technology 4800 Oak Grove Drive Pasadena, CA  91109 steve.scandore@jpl.nasa.gov  Abstract 227Mars Science Laboratory \(MSL\s next mission to Mars, will deploy a large Rover carrying a 
battery of eleven science inst ruments, representing a wide variety of payload types.  The Rover's flight software FSW\he task of monitoring, commanding, collecting managing and in some cases calibrating data from these instruments.  Though the instruments represent a large variety of requirements, complexity, data volumes, fault protection, and commanding logic, the FSW is designed to exploit the commonality among the instruments requirements in order to maximize reuse of software and to minimize design, implementation and testing effort.  To achieve this, we developed an architectural pattern in which all of the common features and patterns of behavior required to manage an instrument are supported, and clear adaptation points are identified and provided to allow 
expression of the unique be haviors needed for each instrument.  For each instrument there is a FSW module called an Instrument Manager \(IM\an instance of the common pattern.  The common IM architecture is expressed in the design as a FSW module called the Instrument Manager Framework \(IMF\along with a supporting library for handling instrument communications, the Instrument Manager Library \(IML The IMF module includes a code generator that reads specifications of the ground command set for an instrument their associated behaviors, and other internal behaviors \(e.g fault response behaviors\n spreadsheets, and produces a set of source code files containing implementations of these commands and behaviors, and their supporting types and variables.   The IML module also includes a code generator whic h transforms a spreadsheet 
specifying the set of commands that the instrument accepts into C code that parameterizes communications with the instruments.  We first describe the instrument management requirements on the Rover FSW, and then continue with an exposition of the IM architectur al pattern.  We conclude with some statistics on the efficiencies gained in the application of this pattern 1 2  T ABLE OF C ONTENTS  1  I NTRODUCTION 1  2  C OMMAND S ETS 3 
   1 978-1-4244-2622-5/09 25.00 \2512009 IEEE 2 IEEEAC paper #1110 Version 5, Updated December 29, 2009 3  T HE C OMMON P ATTERN  5  4  D ESIGN  6  5  E FFICIENCIES A ND S TATISTICS  9  
6  C ONCLUSIONS  10  A CKNOWLEDGMENTS  11  R EFERENCES  11  B IOGRAPHY  11   1  I NTRODUCTION  This paper seeks to describe an efficient design solution involving a reusable pattern for software to control the instruments of MSL.  We begin by describing those instruments to give the reader a sense of the problems we 
were trying to solve The MSL mission contains a rich set of instruments with a variety of science objectives.   We describe these briefly here.  More detail is available on the public website of    
200  Alpha Particle X-Ray Spectrometer \(APXS produce coarse or very fine analyses of the chemical composition of rock and soil, depending on the length of accumulation.  Produces spectra products 200  Chemistry and Camera \(ChemCam\ contains a laser, high-resolution camera, and telescope.  It fires laser at material under study, analyses the spectra of the resulting plasma to remotely \(at a distance of 1 to 9 meters\determine chemical composition of the material 
200  Chemistry and Mineralogy X-Ray Diffraction/XRay Fluorescence Instrument \(CheMin\ performs detection and analysis of minerals by firing its X-ray at samples collected by the Rover's robotic arm, and collecting diffraction and fluorescence measurements from the diffracted energy 
200  Dynamic Albedo of Neutrons \(DAN\will characterize the presence a nd distribution of water molecules in soil by generating neutron beams into the soil and detecting the energies of reflected neutrons 200  Mast Cameras \(MastCam\agers mounted on the Rover's mast, one high resolution for distance imaging, one medium resolution.  The cameras 


 2 can be operated in stereo or individually, and they can take video as well as single images.  They're equipped with filters for monochromatic images, have auto-focus capabilities, and have their own internal storage 200  Mars Descent Imager \(MARDI\ilar to the Mast Cameras in construction and capability, MARDI will take color video during the Rover's descent to Mars 200  Mars Hand Lens Imager \(MAHLI\ilar to the Mast Cameras but equipped with a very high resolution lens and white and ultraviolet light sources for night imaging, MAHLI will acquire images at resolutions in the microns 200  Radiation Assessment Detector \(RAD characterize the high-energy radiation environment at the surface or Mars, allowing an assessment of radiation hazards on any possi ble Mars microbial life or on future human astronauts 200  Rover Environmental Monitoring Station \(REMS will provide measurements of air and ground temperatures, humidity, pressure and ultraviolet radiation, in addition to wind speed and direction allowing the correlation of environmental changes with ultraviolet radiation 200  Sample Analysis at Mars \(SAM\ite of instruments: a gas chromatograph that will vaporize soil and rock samples and analyze the resulting gases; a mass spectrometer to search for carbon compounds in soil samples, and tunable laser spectrometer that will provide accurate measurements of the abundance of carbon, hydrogen, and oxygen in the atmosphere Some of these instruments such as the video cameras produce large amounts of data, while others produce lower data volumes at a much lower rate, such as APXS.   But by design, there are a number of features the instruments have in common 200  all communicate with the Rover on serial buses \(one per direction\ther high-speed or UART 200  all communicate using the same protocol involving command, command reply, and science data frames 200  all respond to and produce data frames in the same basic format, consisting of a header, an optional body and optional checksum 200  all use the same frame header format, which contains status flags and a condition code 200  there is a core set of condition codes that all of the instruments report, such as "nominal ", or "bad data 200  all respond a core set of commands \(called Instrument commands or ICMDs\ the Rover These similarities naturally lead to requirements for similarities in the Rover software that manages and communicates with each of these instruments.  On the other hand, the differences in terms of instrument communications are significant 200  each instrument has a set of unique status flags and condition codes, which required specific, instrumentunique responses by the Rover FSW 200  each instrument has a unique set of commands \(in addition to the common commands\hat the Rover must send in operating the instrument 200  the content and format of the data frame bodies from each instrument are unique 200  several instruments have unique needs to communicate with other parts of the flight system, such as the mast, or the sample arm These differences alone would preclude the same instrument management application from being used to control all of the instruments. But the largest and most complex source of requirements on the Rover FSW for managing the instruments is the set of Rover commands that is, commands sent to the Rover from the ground, called Spacecraft commands, or SCMDs that the Rover must support for each instrument Each SCMD may itself be a complex behavior consisting of many steps or actions.  For example, in processing a power SCMD to turn an instrument on the Rover must command the power switch to the instrument to close, send a series of commands to the instrument to ensure that it is ready for operations, and the report the instrument's status back to the ground.  And that is a simple example.   SCMDs used to set up and execute observations are typically much more complicated, involving actions ranging from changing discrete states to wait periods to creating and submitting science data products to the data management system for transport to the ground.  An action might be a single, atomic action such as setting a software variable, or it might be an asynchronous, multi-phase action, such as sending and receiving results from an ICMD, or it might be the invocation of another SCMD.    And these action sequences may involve iteration over a se t of actions, conditional subsequences of actions, or fault responses to ICMDs that fail or other unexpected conditions. In short, each SCMD may be itself an elaborate and complex behavior Moreover, unlike the ICMDs of which there is a common set among all the instruments as well as unique ones per instrument, each payload has its own completely unique set of SCMDs.  The sizes of these command sets vary, ranging from around a dozen to three times that, with the low 20\222s being typical 


 3  Figure 1 \226 Simplified Excerpt from one of the SCMD Spreadsheets  The SCMD set for each instru ment is specified in a spreadsheet, created by the flight system engineers and the flight software engineers working together.  We show a simplified example of what these spreadsheets look like in Figure 1 The challenge for us then was to find a way to develop these IMs in the most efficient way possible.  Looking at the set of IMs in a detailed manner, it seemed that they were so different that little common software could be employed they all process completely disjoint spacecraft command sets, and so behave in extremel y different ways.   But taking a more bird's eye view, these IMs can be seen as quite similar: each is a collection of behaviors, the behaviors being sequences of actions from the same, or at least largely overlapping, set of actions We use Unified Modeling Language \(UML\agrams throughout, and though the diagra ms are largely intuitive readers that want to understand the full detail of them should be familiar with the UML.  Reference is a good readable description of the language 2  C OMMAND S ETS  Spacecraft Commands For each instrument, we use sp readsheets to specify both the set of SCMDs - commands from the ground to the Rover affecting the instrument, and to describe the command set that the Rover FSW can send to the instrument \(the ICMD set The SCMD spreadsheet constitutes a model of the set of behaviors that the IM must im plement.  The format allows enumeration of the commands, and for each command, the list and types of parameters.  Then the body of each SCMD is defined as a set of actions:  Figure 1 shows a simplified example derived from one of these spreadsheets.  Command names appear in the first co lumn: we see some of the definition of the SOME_COMMAND command.   The SOME_COMMAND command has two parameters: the param_1 parameter, of type integer, and a param_2  parameter of type floating point.  The column labeled Rover Actions" lists the actions to be taken in processing the given command.  Note that the pull-down provides a list of actions, which has been made generic to avoid detail, but that includes simple programming constructs such as ifendif and in practice \(though not shown in our example other actions that may include sending a command to the instrument or executing the state machine of another SCMD 


 4  Figure 2 - Excerpt from the State Machine of the SOME_COMMAND Command Each of these commands is viewed and treated as a state machine.  Figure 2 shows part of the state machine implied by the spreadsheet ex ample of the command SOME_COMMAND.    Each action row in the spreadsheet's command definition corresponds to a state in the state machine.  This provides a well-defined transformation from the spreadsh eet to an automaton that can then be systematically expr essed in code.  However, the state machine shown leaves out a level of detail, because the actual states are compound states, meaning they are themselves little state machines.   For example, the state labeled ROW_9 has a "do" action "send I-CMD".   This means to send an instrument command to the instrument which may include parameters, but that isn\222t shown\  But sending an instrument command is itself a multi-step process involving messages sent back and forth between the Rover's computer and the instrument - or put another way, a state machine in itself.   This level of decomposition of the state machine does not show up in the spreadsheet, but is only visible at the detailed design level of the framework functions that are run to execute that action In addition to the SCMD set, th e spreadsheet defines a set of internal behaviors, each a stat e machine just as the SCMD behaviors are, but are not a ssociated with commands from the ground.  These behaviors exist either for use by other components of the MSL Rover FSW, or to factor out behavior snippets that are common to more than one SCMD state machine, a technique that requires that behaviors be able to execute other behaviors The SCMD code generator tran slates these behavior state machines into C.  The generated C code uses common framework functions to as large an extent as possible, as we describe below Instrument Commands Instrument commands or ICMDs, which are sent by the Rover computer to the instrument, are defined in a spreadsheet as well, called the ICMD spreadsheet.  The ICMD spreadsheet describe s the set of instrument commands, their IDs \(or op-codes\eter list for each, and transmission control parameters such as how many retries to take on error.  The ICMD code generator transforms these spread sheets into C code that is used by the Instrument Managers and the Instrument Manager Library to manage and control communications with the instrument 


 5 3  T HE C OMMON P ATTERN  As we described in the previous section, the requirements for an instrument manager module can be summarized as follows: provide the capability to execute a set of behaviors in the form of state machines, each state having effects involving command and control of the instrument collection and management of data from the instrument control of resources associated with the instrument, such as power switches or discretes, and monitor and/or report information about the instrument \(e.g. temperature readings With this view of the "typical" IM in mind, we can identify a set of common detailed software capabilities that any instrument manager must have 200  provide an execution environment that initializes and runs a set of state machines, controlling and managing the transitions of each 200  manage the interactions between state machine executions, e.g. when one st ate machine kicks off the execution of another 200  ability to process a message expressing an SCMD or internal behavior, and have that message initiate the execution of the associ ated state machine 200  ability to send commands to the instrument 200  ability to process responses from the instrument including missing or off-nominal responses 200  ability to send requests to other FSW modules \(e.g. a request to change the state of a switch 200  ability to process response message from other FSW modules \(e.g. a response to a power switch command 200  ability to accept spontaneous messages from other FSW modules \(e.g. fault protection commands requiring fast instrument shutdown 200  logic to manage the queueing and interleaving of different types of messages 200  functionality to submit instrument data products to the data management system We can also identify the featur es and details determined by the SCMD and ICMD spreadsheets uniquely for a particular IM 200  the specific set of SCMD and internal behavior messages that the IM must process 200  for each specific SCMD, the state machine associated with processing that message 200  the ability to send specific instrument commands 200  the ability to process instrument-unique responses including missing or off-nominal responses 200  to connect to or affect the correct communication bus or power switch or other resource associated with the particular instrument 200  the specific messages \(including parameters\o be sent to other FSW modules \(e.g. a switch ID in a power switch request 200  special cases of other resources to be managed, e.g. for the MastCams, the need to command mast movements To obtain a reusable design pattern for the IMs, we need a framework that can implement the common requirements and that also allows the adap tation and extension needed to handle the specific details and special cases for each IM Much of that adaptation and extension occurs at code generation time:  initialization c ode is generated to connect the IM to the correct serial port, and the set of SCMDs defined in the spacecraft comma nd spreadsheet determines what set of handler functions the code generator produces Further code generation steps \(used FSW-wide in MSL generate unique message types for each SCMD and internal behavior A good deal of the parameterization also happens at run time.   This happens in the form of common functions defined in the IMF or IML modules, that manage the execution of behaviors, or perform many of the actions specified for the SCMD beha viors.  For example, the execution environment at the top of the list of common capabilities is implemented in common functions. Sending a command to the instrument is done in a common function That function requires several parameters to adjust to the specific IM and ICMD: the op-code, a function to lookup processing parameters for that ICMD, such as whether or not to try to retry on failure, the identities of the type of response message that will be received, and others W e first take a look at the execution environment capability The design must provide an execution environment that allows state machines to be executed in response to messages, to spawn the executi on of other state machines and wait for their completion, and to send messages and wait for responses.  The logic of this execution environment, or Executive as we refer to it here, is shown in Figure 3, in which we represent the execution engine of an IM as a state machine 


 6  Figure 3 - The Behavior Execution Environment The initial state is Idle and further action is triggered by the receipt of messages.  Any of the messages represent an SCMD or the invocation of an internal behavior by some other FSW module.  If the message is sent to initiate the processing of an SCMD or an internal behavior,  the execution engine transitions directly to a state in which it is executing the appropriate behavior state machine \(the selection of the correct machine is not shown, but is established at compile time by associating message type IDs with C functions\ the state Executing the selected state machine is stepping through its transitions The executing state machine may pause, either to initiate and wait for the completion of another behavior, or to wait for a response message to a request that it sends.  Either of those events make the Executive transition to the Selecting  state, in which it decides which other behavior, if any, to initiate or resume.  If the pausing behavior wants to execute another behavior, that behavior will be chosen next, and the Executive transitions back to Executing.  Otherwise, the Executive transiti ons back to Idle An executing behavior may complete, either normally or in error.  That event also causes a transition from Executing to Selecting  If there are no behaviors waiting to be resumed, the Executive transiti ons back to Idle to await a command or response message When a message is received that is of a type known to be received in response to a reque st previously sent by an executing state machine, that st ate machine is expected to be in a paused state, waiting for the message.  The Executive searches for the in-pro cess behavior that sent the request.  If that behavior is found, the Executive transitions to Executing and that request-se nding state machine is resumed.  If the behavior is not found \(this is an "orphaned message transitions back to Idle issuing an error event as it does so The logic of this Executive state machine is the same for every IM.  The differences be tween IMs lay in the specific types of messages accepted \(and the set of behavior state machines that handle those messages 4  D ESIGN  In the MSL flight software ar chitecture, SCMDs arrive at the module responsible for processing them as a message on a queue, as do the responses in asynchronous operations such as commanding a power sw itch to a certain state or reading the content of a file.    Thus a more detailed version of a requirement to process an SCMD is to process a message of that type arriving on the queue 


 7  Figure 4 - A Run-Time View of a Typical Instrument Manager The diagram of Figure 4 shows a typical instrument manager module, which we call Imx in its run time context The diagram shows spacecraft commands arriving from the Command module, instrument commands sent to IML which serves as a go-between for the serial port driver and timer mechanisms, and thus ultimately the instrument itself all not shown\power switch commands being sent to and responses sent from the Power module.   The Imx module produces data products and submits them to the DataManagement module for storage and downlink.  The IM also sends timer requests to the Time module to arrange a wake-up message at a later time - this is the mechanism by which behaviors wait There are two possible types of response message from IML when Imx sends an ICMD: a timeout, which occurs if the instrument fails to respond, or a driver complete message indicating that a data transfer \(in or out\pleted The IM must be able to accept either of those messages Recall for a moment the Execu tive state machine of Figure 3: an executing behavior could send a request to another FSW module \(including IML\hen make the Executive transition to the Selecting state.  These transitions happen whenever Imx sends a message, e.g pwr_set_switch to another module.  The one exception to this in Figure 4 is the message create_data_product which is a synchronous message To see how this execution model is supported in the design see Figure 5, which shows a sketch of some key data structures generated for an IM from the SCMD spreadsheet Several of the key data structures are sets of elements  RunningBehaviors, ExpectedMessages ExpectedCompletions and ParameterBlocks are all container data structures For each executing behavior there is an entry in the RunningBehaviors container.  As the diagram shows, the list entry, of type BehaviorInstance  contains the current state and status of the behavior including a set of local variables of the behavior implementation function, as well as the pointer to the function itself Thus, given an object of type BehaviorInstance the Executive can run the behavior through the function pointer without using a hard-coded function call.  This anonymous invocation allows the same ex ecutive code to be used for every IM. The locals element of the behavior instance object, of type BehaviorLocals is necessary because the behavior implementation function is run multiple times for a single SCMD's processing, so true local variables would not survive from one run to the next, while the behavior instance structure persists across multiple runs of the implementation function Whenever a running behavior reaches a state in which it sends a message to another module \(e.g. sending an ICMD to the instrument\he behavior must  pause and wait for the response from that operation.  The execution framework handles this by allocating an entry in the ExpectedMessages  container.  This entry, shown in the diagram as type MessageExpecter contains the behavior instance of the waiting behavior and the unique ID of the message type that is being expected    


 8  Figure 5 \226 Sketch of some of the Key Data Structures of an Instrument\ Manager Using this data structure, the framework can locate and resume the behavior that is expecting a given message when a message of that type arrives. \(The messages themselves also carry information to identify the initiating behavior, so there is no ambiguity in the case where two behaviors make the same type of request at the same time, though this is rare\s search of this ExpectedMessages  container is the implementation of the FindingExpecter state in the Executive state machine of Figure 3 In many cases, a running behavior needs to execute another behavior, either another SCMD behavior or an internal behavior.  In that case, the first behavior allocates a new slot in the RunningBehaviors container, and writes it with metadata on the new behavior \(including the implementation function pointer\  Then that first behavior exits back to the Ex ecutive. The Executive then allocates an entry in the ExpectedCompletions container with identifying information for both behaviors, and then runs the subbehavior.  When the sub-behavior completes, the Executive searches the same container to find out if any behaviors are waiting for that sub-behavior to exit, and if so, resumes the expecting behavior, passing it the final state information of the sub-behavior The ParameterBlocks container is used in tandem with the RunningBehaviors set: whenever a behavior is running, a copy of its parameters \(which came in the message from the queue\s kept in the parameter block.  This ensures the integrity of the parameter list for the entire time that the behavior instance is in existence.  A parameter block has to be able to contain a full set of arguments to any one of the SCMDs and behaviors defined in this IM.   There is a specific structure type genera ted for each different message and the actual type put in the ParameterBlocks container is a C union of all of these specific types We mentioned "metadata" about behaviors.  This information defines and enumerates the SCMD and internal behaviors from the spreadsheets and is the key mechanism by which the framework is cu stomized for a specific IM Figure 5 shows another key data structure called BehaviorMetadata another container data structure, with each element of the container of type BehaviorInfo The behavior info element contains everything that the Executive needs to know to manage the execution of that behavior, in an anonymous way; that is, without knowing the actual implementation function name or the names of the constants that define the final or error states of the behavior state machine For each IM, an initialization function is generated that populates the BehaviorMetadata  container at initialization time, and it is never changed after that The process of initiating a be havior involves allocating a behavior instance object from the RunningBehaviors  collection, and then populating that behavior instance\222s behavior_id attribute with the unique ID of that behavior That value allows th e Executive to access the BehaviorInfo  element in BehaviorMetadata as it manages the execution of the behavior instance.  Fo r example, the Executive needs to check whether the behavior function has reached the final state or the error state when ever that behavior function returns to it.  This is done by consulting the final_state and error_state values in the BehaviorInfo element 


 9 Instrument Manager Library An important part of of the common IM design is contained in the Instrument Manager Library \(IML\ We mentioned that the IML module serves as an intermediary in communication between an instrument manager module and the serial port driver and tim ing mechanism.  One of the functions generated for the IM is an initialization function that registers a set of callback functions with the IML module.  These functions allow IML to route event messages from the serial driver and the timing module back to the IM IML functions control every step of the process of sending an ICMD to an instrument and receiving and processing replies.  This is done through a key data structure, called the command processor shown in Error! Reference source not found with type CmdProc This data structure contains not only information about buffers for storing command frames and command reply and science data frames going to and coming from the instrument, but also state variables about the process of completely executing an ICMD.  In processing an ICMD, the IML functions implement a state machine, us ing the command processor as the holder of state information Thus, the same software is reused to handle the instrumentRover communications for every IM 5  E FFICIENCIES A ND S TATISTICS  A significant part of the work of producing these Instrument Manager software modules involves developing the SCMD spreadsheet.   That is done as a collaboration between the system engineers and software engineers.   The spreadsheet with its sort of mini programming language, provides an excellent means of communication between the two groups it is not nearly at the level of detail of the actual software but it is detailed enough to let the writer express the logic of the behaviors in detail, and for readers to see and understand that detail The spreadsheets also evolve as we test the software and discover errors, or features that make operations awkward or as the instruments themselves change.  We have a process of regenerating the code, and then manually merging the changes into the actual tested code baseline The syntax and semantics of th e spreadsheet format are not precise enough to generate perfect C code, so a considerable amount of hand-coding has to be done to the generated code, though most of that is changing, rather than adding code It's hard to estimate the amount of hand-coding of the IMs But it is clear that a large percentage of the code is truly automatically generated.  We ve mentioned that there are certain code generation tools that all of MSL FSW uses \(as distinct from the code generation tools that process the SCMD and ICMD spreadsheets discussed in detail above These general code generation tools, called MSL Autocoder  tools in Table 1, generate the code that defines types of messages, handles queue defi nition and management, and handles dispatching of messages to the appropriate handler function.  The MSL Autocoder tools also generate type definitions and functions for creating data products with a particular format, code for reporting telemetry channels, and they produce code to maintain a set of persistent parameters that can be set by ground command and are stored in persistent storage.  The MSL Autocoder tools all take XML files as inputs The SCMD spreadsheet also defines data product formats telemetry channels, and persistent parameters, all in separate worksheets.  In addition to generating the behavior state machine implementation functions, the SCMD code generator produces XML files from these worksheets which are then used as inputs to the MSL Autocoder tools Table 1 lists lines of code counts for the IMs and the framework modules \(IMF, IML\s are physical C code line counts, that is, they are counts of all lines in the source files that are neither comments nor whitespace-only lines.  Table 1 has six columns of counts: the first is the module, the second the purely hand-coded line counts; the third is the count of lines of code generated by the SCMD code generator, the fourth those generated by the ICMD code generator, and the fifth the line count generated by the MSL Autocoder tools.  The last column is the total of all of these.   The hand-coded count does not attempt to estimate the work of completing the code generated by the  SCMD generator We don\222t have much data on how this compares to a handcoded system of instrument manager modules, but one data point is a controller module, NCAM, also in MSL, that controls a different set of stereo cameras.  That module is uses the main-line MSL autocoding tools, but the rest of it is hand-coded.   The MSL autocoded part of it is 15000 LOC and the hand-coded portion is 8150.  This module is roughly similar in terms of requirements to the MCAM module which also handles a pair of stereo modules\he ratio of MSL-autocoded lines in the two modules is multiplied by the hand-coded LOC of NCAM, then MCAM would be expected to have about 9370 LOC.  The fact that it has 20450 says that the autocoded code takes about 2.2 as many lines as hand coded to achieve the same functionality \226 not surprising But perhaps a more telling comparison is the lines of spreadsheet count as an analog for hand-coding: the MCAM spreadsheet has about 1500 rows \226 and these are truly hand\223coded\224.  If it takes roughly the same effort to write a line of code as it does to write a ro w of the spreadsheet, then the SCMD code generation is making us about 5 times more efficient That is certainly an overestimate.  For one thing, it doesn\222t take into account the manual work involved in merging 


 10 changes into the test source code after making changes in the spreadsheet, and this is not trivial Table 1.  Source Code Lines of Co de Counts for the Framework and IMs MODULE LINES OF CODE TOTALS  Hand-Code SCMD Generator ICMD Generator MSL Autocoder Subtotal IMF 3016  167 3183 IML 3160  844 4004 Framework total 6176  1011 7187 APXS 50 4980 171 7599 12800 CCAM 55 7935 249 20783 29022 CHMN 1232 5562 156 21250 28200 DAN 48 4352 249 4868 9517 MCAM 372 19948 135 17245 37700 MHLI 228 8597 132 10143 19100 MRDI 228 8012 132 10028 18400 RAD 152 2923 161 5344 8580 REMS 142 3283 193 7182 10800 SAM 46 6424 171 7259 13900 TOTALS 8729 72016 1749 112712 195206 6  C ONCLUSIONS  As the code counts demonstrate, our methodology of specifying and generating these software modules is very productive.  It did allow us to produce a great deal of functionality in a very short time.  We think we need to do more work to quantify this efficiency gain, which may spur a follow up study to do that Disadvantages This technique was not w ithout difficulties.  The spreadsheets do not provide a rich enough language to express all of the detail needed to produce correct C code If we had made it rich enough, it probably would have been unusable for the systems engineers.  Nonetheless, this required us to do hand-editing of the generated code in order to fix errors and to workaround complexities that couldn\222t be expressed in the spreadsheet.   Also, this led to a manual merge process when generating a new version of the code from a changed spreadsheet, in order to avoid reintroducing errors in the generated code into the tested code baseline.  However, we believe this could be improved by enriching the format of the spreadsheet and upgrading the code generator We think the IM pattern could be used more generally in FSW The framework we have devel oped allows the production of flexible and powerful software applications that are able to manage and coordinate the execution of a set of state machines.   This overall pattern could be quite general, and not limited to command, control, and communications of instruments.   With a substitution of the set of actions that 


 11 make up the state machine behaviors, this framework could be adapted for a large variety of applications The technique of using spreadsheets as a model  is effective The spreadsheets serve very effectively as a model of behavior of a non-trivial software application.  This methodology has proven very effective as a means of communication and collaboration among software and system engineers.  We feel this technique is promising in other situations where system and software engineers need to collaborate A CKNOWLEDGMENTS  We would like to thank our colleagues on the Flight Systems Systems Engineering team responsible for payload systems engineering on the MSL project, Daniel Limonadi Elisabeth Lamassoure Morse, Ian Harris, Justin Maki, and Karen Dragon for their excellent work in helping to develop the SCMD spreadsheets for the instruments The research described in this paper was carried out at the Jet Propulsion Laboratory, California Institute of Technology, under a contract with the National Aeronautics and Space Administration R EFERENCES   Jet Propul si on Laborat ory M a rs Sci e nce Laborat ory  website: http://mars.jpl.nasa.gov/msl  Jet Propul si on Laborat ory M S L Inst rum e nt s websi t e   http://mars.jpl.nasa.gov/msl/mission/sc_instruments.html 3 wler, \223UML Distilled  A Brief Gu id e to  th e Standard Object Modeling Language \(3rd Edition Addison-Wesley, Sept 15th, 2003 B IOGRAPHY  Alex Murray is a senior software engineer with the Jet Propulsion Laboratory, California Institute of Technology. He has most recently developed payload m anagement flight software for the MSL project Previously he led the development of the flight software for the Aquarius instrument.  He has led and done software development for flight ground, and simulation software for missions and for technology devel opment projects at JPL Previously he led and developed software for a variety of projects at TRW \(now Northrop-Grumman\, and he served as a system engineer for the European weather satellite agency, Eumetsat, as well as software engineer for the Dresdner Bank in Frankfurt, Germany.  His experience includes embedded and flight software development prototype and research developm ent, OS development, AI analysis and simulation tools, science and image processing applications, business and GUI applications, and databases. He holds BS and MS degrees in mathematics from The Ohio State University  Dr Marcel Schoppers completed his Artificial Intelligence PhD in 1989 while working full-time since 1984 in the field of reaction-planning for hybrid \(continuous and discrete feedback control of robots. In 1991 he started a 2-person business under contract to NASA Johnson Space Center, in the course of which he discovered that the demonstration of a revolutionary \223Universal Plan controller, capable of navigating robustly across 1.3 x 10^10 Boolean states, while consisting of only 1,900 lines of C, then required the support of 330,000 lines of C for stateestimation, servo control, physics simulation, and graphics No longer perplexed at why rese arch takes decades to reach markets, Dr Schoppers opted out of Artificial Intelligence academia, and in 1997 was hired by the NASA Jet Propulsion Lab, where he has since participated in design of the Mar Sample Return mission \(until it was cancelled design and implementation of the Mission Data System operations of the Mars Exploration Rovers, and design and implementation of the Mars Science Laboratory rover. The latter has brought him back to automatic generation of finite-state machines from specifications, now in a context of nearly 3,000,000 lines of C and in the enjoyable company of dozens of extremely competent systems- and software-engineers  Steve Scandore is a senior member of the Technical Staff at the Jet Propulsion Laboratory, California Institute of Technology. He has worked on a variety of projects at JPL. Steve has a diverse work experience ranging from system engineering of military command and control centers to low-level embedded software development He has previously led the development of Sharednet, a message oriented middleware \(MOM\  designed specifically for low bandwidth military applications. This MOM implementation was used to increase the interoperability of existing military applications in a tactical environment.  His other experience includes software design and development for the Multi-mission System Architectural Platform MSAP\ flight project. The MSAP goal is to establish a common architectural software and avionics platform for future JPL flight missions. Steve received BS and MS degrees in Electrical Engineering from California State University, Northridge. He is currently developing tools system infrastructure, and pay load flight software for the Mars Science Laboratory \(MSL\ project  


by themselves When they carry additional information data is coded the same way as in the variable communication primitive In the case of events an important fact that has to be taken into account apart from correct reception of the message by all subscribers is that latency due to reception and processing may be critical A typical solution to this problem is the reservation of time slots in both the processor and the network The publisher and subscriber services interact with other services always using the service container like in the variable case Finally this communication primitive is mapped by the service container over TCP or over UDP using a mechanism to acknowledge and resend lost packets This speci\002c retransmission mechanism in the application layer is more ef\002cient for event messages than the generic case provided by the TCP stack Remote invocation Most middleware implements some way of distributed computing based on the remote procedure call paradigm for example ONC RPC CORBA or Web Services However for some distributed embedded domains the data publicationsubscription or global data space paradigm seem more appropriate For this reason we provide a 002rst-class set of publishsubscribe communication primitives Nevertheless remote invocation is an intuitive way to model some sort of interactions between services Some examples can be the activation and deactivation of actuators or calling a service for some form of calculation Thus in addition to variables and events the services can expose a set of functions that other services can invoke or call remotely The functions exposed by a service can have an arbitrary number of parameters and optionally a return value This communication primitive implements two-way point-topoint communication between two services one acts as a client and the other as server The client service is always the initiator or the communication and the server service location is abstracted by the middleware However a difference from previous communication primitives is that the client service is not continuously subscribed nor connected to the server service Their relation is occasional and delimited by the time the invocation is executed During middleware initialization the services check that all the functions they need to properly accomplish their task are provided by one or more services available in the network Redundancy and fault-tolerance are managed by the middleware that can also redirect remote calls to server services statically or dynamically Static allocations of the client-server relationships are useful in critical services where resources like CPU time or network bandwidth are pre-allocated On the other hand runtime information can be used to redirect calls to non-critical services to the server where best performance is expected  For this load balancing techniques are used Upon service failure if another service is implementing the same functionality the middleware will detect the situation and redirect requests to the redundant service This allows the system to continue its mission although perhaps in a degraded mode If no service provides the requested function the middleware will warn the system to take the programmed emergency procedure In some cases both event and function primitives can be applied to realize a functionality In this case in our current implementation events seem faster than their function equivalent This communication primitive is generally mapped by the service container over TCP but UDP plus retransmission at the middleware level can be also used However this primitive is never mapped over broadcast or multicast given that is always a point-to-point communication File-based Transmission In our preliminary prototypes it has been discovered that some requirements of the mission are not ful\002lled by the proposed communication primitives In some cases there is the need to transfer with safety continuous media This continuous media includes generated photography images con\002guration 002les or services program code to be uploaded to the service containers Some modi\002cations could be done to the previous primitives to accept this sort of information transfer But 002nally a speci\002c primitive has been developed to treat this case given the huge performance bene\002ts that can be attained This primitive is used basically to transfer long 002le-structured information from a node to another and is implemented mapped directly over TCP Internal Implementation MAREA has been designed with interoperability and 003exibility in mind Their internals have been distributed in several layers allowing the addition of new components such as transports and codi\002cations MAREA has its components distributed in four layers Protocol Encoding Presentation and Transport This distribution loosely resembles the PEPt architecture from The transport layer is the lowest level layer on the MAREA stack It is on charge of sending and receiving data from the underlying network and to interface to the upper Encoding layer The MAREA middleware is message based so the transport layer is especially well suited for datagram based networking i.e UDP In the case of stream based communications the transport layer implementation has two options 12 


Figure 9  MAREA Internal Implementation The 002gure shows the internal delivery of data between components on the same local network a one stream can be opened for each message and after its sending the stream is closed b as the stream initialization usually require a long handshaking phase it is better for performance to reuse the established connections waiting for new messages to be send to the same destination through a unique stream In its current status MAREA offers an UDPTransport TCPTransport and PersistentTCPTransport They implement basic UDP and TCP transports for MAREA messages In the case of PersistentTCPTransport as the 002rst connection with other node is established it is cached in a table indexed by node All the following messages between the nodes that have established the connection are sent through this connection For this transport a speci\002c transport has been designed to dissect the stream into messages Basically each message is preceded by a header that indicates the length of the next message This way the receiving transport layer knows when a message is complete and it can pass it to the upper Encoding layer MAREA transport layer is not limited to IP based communication Although the most common connection between MAREA containers is IP over Ethernet or Wi-Fi other simpler networks are possible for example serial RF modems Each of these connections are represented in MAREA by an ITransport interface This interface provides access to the underlying device and allows to send and receive data and to get link status information i.e link quality expected bandwidth and latency This modular approach allows to easily add new datalinks to the system The encoding layer is on charge of transforming MAREA messages into byte arrays and vice versa Data received in the transport layer is cut into datagrams and sent to the upper encoding layer Here the received bytes are translated into a message that can be processed by the upper layers In a similar way when the Service container needs to communicate with other Service containers it forwards a Message to the encoding layer that transforms it into a coded byte array MAREA provides several coders and decoders to allow easy interoperability and devices/network adaptability Depending on the selected encoding the balance between codi\002cation latency and network bandwidth needed to transmit the encoded message can be modi\002ed Currently MAREA supports one optimized binary encoder and one text-readable XML encoder Finally the Protocol layer is on charge of scheduling the message depending on its priority and after that process it Control messages managing the discovery publication and subscription of services are managed on this layer while data messages are feed to the subscribed services All the services provide a common interface to get noti\002cations and data from the container and other services The service interface contains operations to manage the following operations Start This operation is invoked for all the initial services at container startup A service should respond to this call by allocating its needed resources and start performing its functionality Stop A service is asked to 002nish by receiving this call Container issues this call at system shutdown recon\002guration or during problem containment Run Usually a service requires a thread to perform its job The Run function contains the code to be executed by this main thread VariableChanged When a subscribed Variable primitive gets new data the container calls this function in the subscribed services The function acts as a callback returning the originating service and the sent data EventFired This is the equivalent callback but for Event primitives FunctionCall Finally Function primitives are noti\002ed by issuing this call in the producer service The service executes the indicated operation and returns the results to the container which will send them to the calling service 13 017 017 017 017 017 017 


The service container will issue this operations on the different services as they are initiated stopped or they receive new data from others services In addition the service container will contact with other containers in the local network to discover new services and manage remote publications and subscriptions More details about the protocol between containers are given in the next subsection Figure 9 shows three different views of a MAREA service container receiving and processing a message through its different layers In the leftmost 002gure we can see two service containers deployed over the same aircraft internal network More speci\002cally the Mission Control service noti\002es the Video Camera service to take an aerial photo by using a Variable communication primitive In the central 002gure we focus on what happens inside the service container and its layers First we found the Transport layer where the different transports keep the communication with other service containers Next we found the Encoding layer where the raw data received in a transport is decoded to be scheduled and processed in the upper Protocol layer In the rightmost 002gure the Mission Control noti\002es the Video Camera by using a Variable primitive so the VariableChanged callback is called for all the subscribed services in the container Then each service will react to the input according its functionality 6 G ROUND S EGMENT AND MANET O PERATION Adhoc networks are packet-based multi-node networks that are gaining popularity in other cooperative environments because they do not need a central point of organization like an access point in Wi-Fi networks and they can be selfcon\002gured as nodes appear and disappear If we add dynamism and mobility we reach the concept of MANET Mobile Adhoc Network 13 14 MANETs can extend a network more than the range of a single node range because their inherent multi-hoping capability allows the use of intermediate nodes to propagate packets to its destination Sensi\002re Support Terminal for Ground Squads One of the environments in which the technology has in\003uenced less is the forest 002re\002ghting techniques In this scenario it usually work small groups of 002remen squads organized all around a 002re truck The 002re truck commonly carries a GPS receiver and a radio unit to be in contact with a coordinating base station The Red-Eye system offers the ground squads a PDA system that can receive the set of hot-spots they have been tasked by the controller The PDA set feeds back the position of the squad given its attached GPS The PDA set can also be instrumented in order to feedback other information like temperature humidity level and wind speed and direction These data samples are designed to be sporadic because they need the proper placement of the sensors However the GPS position will be continuously transmitted The main advantage of using a MANET infrastructure is that information can get to the squads either directly from the Red-Eye helicopter of relayed from some other ground squad thus minimizing the 223out of coverage\224 situations Also having a continuous monitoring of the ground squads will improve their ef\002ciency as well as prevent dangerous situations in case of major changes in the evolution of the wild\002re These limited means generates some grave problems dif\002culty for knowing the location and state of the 002re brigades and lack of updated information for the decision taking This situation is make worse by the fact that communication is dif\002cult in these conditions Brigades usually work in zones of dif\002cult access and which lack adequate communication infrastructures They mostly use voice communication over radio and then is dif\002cult to transmit concretely 002re state or positions over the terrain We propose to alleviate these drawbacks by the usage of a distributed system For this application each 002reman will carry a personal digital assistant PDA device communicating with a central base station where all the information is centralized and keep a global vision of the situation The PDA is a small and light device secured to the 002reman arm This way the PDA does not disturb during the 002reman work and he can use the device with his free hand The functionalities provided by the device are receive and present information from the Base Station This include voice messages images picture or videos text messages maps and associated GPS coordinates It can also send these sort of messages Meanwhile the brigade is carrying the PDA its attached sensors are gathering useful information to the base station brigades realtime location temperature and humidity This way the base center can have an updated picture of the 002re and the effectives All the PDAs and the base station conform a mobile ad-hoc network or MANET Obviously this network does not guaranties a perfect coverage however it offers 003exibility and mobility while its coverage can be improved by using repeaters installed in the trucks or in the aerial means The PDA includes a service container and several services that implement the client application Client Application Sensor Module Storage Module and Map Database 017 Sensor module interact with the GPS receiver and the humidity and temperature sensors It can broadcast this data at regular intervals using the variables temperature  humidity and position  In case of an extreme temperature detected it can send an alarm to the base station using the event primitive 017 Storage module is a common component used in most of the applications following this architecture It represents a 14 


002le system where other components can store and retrieve information in a hierarchical way 017 The Map Database is a higher level of abstraction component that allows the storage and retrieval of geo-referenced information mainly maps All 002le-structured information i.e maps or images that is need to be sent to several brigades can be sent using the 002le transfer primitive of the middleware This primitive optimizes the bandwidth usage when multicast networks are used Communication Gateway In air-ground communications it is very common to use different links to support communication at different ranges and to provide redundancy in the case a link is down These pointto-point links usually do not support multicast and may have associated costs economical or power-consumption that restrict their usage to speci\002c situations or very important transmissions In this case the system should be intelligent enough to send the data through the most appropriate channel This decision should be based on the type and length of the data to send the current quality of the different links and the mission status At the same time the communication should be as much uniform and transparent to the services as possible in order to allow the deployment of the same services in different missions over different network relays MAREA has a speci\002c system called Communication Gateway that it is on charge of managing air-to-air and air-to-ground communications Their main purpose is to make the network transparent to the different services that use it Our middleware assumes a highspeed Ethernet-like network that interconnects the different service containers This local area network provides a very good bandwidth/cost ratio and very high reliability Communication Gateway requirements\227 The basic requirements that the Communication Gateway has to ful\002ll are 017 Support for several datalinks The vehicle will have several datalinks that the services should use in command and transparent manner New datalinks should be easily con\002gured to be used 017 Network hardware and protocol independence The services should not be modi\002ed because using one network technology or another The underlying network can use IP or not For example most RF modems provide a wireless RS-232 link this means no data transmission integrity no error correction and no retransmissions MAREA Transport component implementation should resolve this transport-speci\002c problematic while encapsulating and hiding these details to the rest of the system 017 Transparent handover between networks When a communication session has been established between two remote service containers changing from a datalink to other should be transparent to the services involved Imagine that we are using a high-throughput 802.11a WiFi connection to while the helicopter is near the ground station as the distance increases signal will decrease and the Communication Gateway will change to RF modem communication Established sessions will hand over from a datalink to the other 017 Prioritize traf\002c from different services When the available bandwidth is not enough for all the required data 003ows the Communication Gateway should prioritize the traf\002c from speci\002c services Other traf\002c can be discarded postponed its transmission or stored in persistent medium for later processing on ground For example command data should be prioritized always over telemetry data 017 Using simultaneously several networks for higher throughputs If a vehicle con\002guration provides several datalinks and in a speci\002c point of the mission there is a high throughput necessity and they are available the MAREA container should distribute the generated data through the different datalinks Imagine that we have two RF modem on different bands and we want to download to ground a high-resolution aerial photo by using the two RF modems simultaneously we will be able to 002nish the job in half the time 017 Security and encryption The MAREA protocol has some security checks but in general it has not need to cope with malicious services because the internal local network can be considered safe When the communications are done external to this network and using a wireless channel the possibilities that this channel can be attacked are highly increased Some effort is done in this area although the current implementation of the current gateway lacks these features System architecture\227 The idea of the communication gateway is to add a new layer on the stack that will manage the multiple datalinks and decide which to use for each data 003ow This process is dynamic as it depends on the links status Link status can change from available to unavailable in any moment of the mission on that case the Communication Gateway will be on charge to transparently handover the communications from one link to other One advantage of separating this functionality on an independent layer is that the service containers present on internal networks not needing handover and multiple network interface functionalities can remove completely this layer avoiding all the resources cost Communication Gateway layer is installed between the Protocol and Encoding layers just before deciding which encoding use It only processes output messages Input messages are bypassed and their differentiation is performed at the scheduling done by the Protocol layer Messages from high priority services are queued before An XML con\002guration 002le de\002nes which transports to use and which policies to apply to each sort of packets The packets are mainly classi\002ed by their producer and their consumer In addition to this static information the Communication Gateway receives dynamic information from the Transport layer mainly the link status of all the transports enabled The Transport components on the transport layer has been extended to be able to provide this information 15 


All information related to link status and interfaces are stored in a component called Network Manager The Network Manager it is on charge on relating addresses with its link status With this both dynamic and static information the Selector component decides to which interface send each Message Services and service container layers use speci\002c objects called TransportAddress to identify the recipient of a Message This object not only carries the address of the underlying speci\002c networks for example its IP address but also information about the encoding to use This TransportAddress will be used by the lower layers to select the appropriate encoding and interface Communication Gateway only needs to route the Message through the lower layers by changing the TransportAddress of the Message Figure 10  Communication Gateway architecture The 002gure shows the layers of the MAREA middleware interacting with Communication Gateway A general view of the architecture is shown in Figure 10 After being processed by the Protocol layer two packets arrive at the Communication Gateway With the information gathered from the Transport layer and stored in the Network Manager about the two Link available the Selector decides which route to use The XML con\002guration 002les de\002nes that the Messages from Service 1 are encoded in binary and sent through network 1 Wi-Fi while the Messages from Service 2 are encoded also in binary but sent through network 2 RF In addition to the Communication Gateway layer a speci\002c SerialTransport has been implemented to be able to use Radio Frequency Modems based on RS-232 interaces for example the Digi 2.4Ghz XStream module 7 C ONCLUSIONS AND F UTURE W ORK Having aerial resources working in a command and control over wild\002res may improve the overall extinguishing process Improving the awareness trough those monitoring systems may will maximize the ef\002ciency of the available resources and at the same time improve the safety of the personnel working on the 002re However the complexity of integrating these monitoring systems together with the traditional aerial resources is a complex and unsolved task The Red-Eye system is a partial solution to this task Its objective is to provide hot-spot detection over areas in which other aerial resources has been temporally removed It has been identi\002ed that this scenario may provide important bene\002ts in terms of ef\002ciency Red-Eye will allow aerial and ground resources to be employed on other 002re fronts by reducing the number of resources that need to be kept on the 002eld one a 002re front has been controlled Red-Eye works on top of a middleware speci\002cally designed for avionics MAREA provides a full distributed paradigm to the avionics designers Each avionics semantic is encapsulated into a service or piece of software which realizes a function Data communication between services are always conducted through the middleware The physical location of the services is transparent to the designers being MAREA responsible of the service discovery location and execution The main targets in the MAREA development process have been the communications ef\002ciency the transparent service location and the automatic selection of the physical link for the communications The communications ef\002ciency is de\002ned as the relation between the transfer speed and system cost The paper presents also the second layer the gateway This layer has information from the lowest layer about all the available links and their status The gateway using a con\002guration 002le decides the best physical channel Service ubiquity is the 002nal result for avionics designers A CKNOWLEDGMENTS This work has been partially funded by Ministry of Science and Education of Spain under contract CICYT TIN 200763927 This work has been co-\002nanced by the European Organisation for the Safety of Air Navigation EUROCONTROL under its CARE INO III programme The content of the work does not necessarily re\003ect the of\002cial position of EUROCONTROL on the matter R EFERENCES  223Upnp forum 224 http://www upnp.or g Online A v ailable http://www.upnp.org  Y  Kaufman C Justice L Flynn J K endall E Prins L Giglio D Ward W Menzel and A Setzer 223Potential global 002re monitoring from eos-modis,\224 Journal of Geophysical Research  vol 103 no 32 pp 215\226238 1992  L Giglio J Descloitres C Justice and Y  Kaufman 16 


223An enhanced contextual 002re detection algorithm for MODIS,\224 Photogrammetric Engineering and Remote Sensing  vol 87 pp 273\226282 2003  D Ro y  P  Le wis and C Justice 223Burned area mapping using multi-temporal moderate spatial resolution data a bi-directional re\003ectance model-based expectation approach,\224 Remote Sensing of Environment  vol 83 pp 263\226286 2003  223National inf ared opera tions historical perspecti v e 224 Remote Sensing Applications Center August 2004  223Designing and implementing a near real-time wildland 002re information system,\224 Jet Propulsion Laboratory California Institute of Technology 1989  J D Nichols 223Fire\003y system concept 224 in Proc SPIE Vol 1540 p 202-206 Infrared Technology XVII Bjorn F Andresen Marija S Scholl Irving J Spiro Eds  ser Presented at the Society of Photo-Optical Instrumentation Engineers SPIE Conference B F Andresen M Scholl and I J Spiro Eds vol 1540 Dec 1991 pp 202\226206  D Wright T  Y otsumata and N El-Sheimy  223Real time identi\002cation and location of forest 002re hotspots from geo-referenced thermal images,\224 International Archives of Photogrammetry Remote Sensing and Spatial Information Sciences  vol 35 no 2 pp 13\22618 2004 also AIAA Paper 89\2260269 Jan 1989  E P astor  C Barrado P  Ro yo J Lopez E Santamaria X Prats  and J M Batlle 223Red-eye A helicopter-based architecture for tactical wild\002re monitoring strategies,\224 in IEEE Aerospace Conference  Big Sky Montana IEEE 2009  J Lopez P  Ro yo E P astor  C B arrado and E Santamaria 223A middleware architecture for unmanned aircraft avionics,\224 in ACM/IFIP/USEUNIX 8th Int Middleware Conference  NewPort California Nov 2007  H Carr  223PEPt A minimal RPC architecture 224 in OTM 2003  Italy Nov 2003  A Ne yem S Ochoa and J Pino 223Supporting mobile collaboration with service-oriented mobile unit groupware Design implementation and use,\224 in Groupware Design Implementation and Use  vol LNCS 4154 2006 pp 228\226245  M T entori and J F a v ela 223 Acti vity-a w are computing in mobile collaborative working environments,\224 in Groupware Design Implementation and Use  vol LNCS 4715 2007 pp 337\226353  A Ne yem S Ochoa J Pino and M Bor ges 223Supporting group decision making and coordination in urban disasters relief efforts,\224 International Journal of Decision Systems  vol 16 no 2 pp 143\226172 2007 B IOGRAPHY  Enric Pastor is a Computer Science Engineer and holds Ph.D also in Computer Science from the Technical University of Catalonia Spain Currently he is an associate professor at the Castelldefels School of Technology His research background includes the development of CAD tools for the automatic design of synchronous and asynchronous circuits and CAV tools for the formal veri\002cation of concurrent systems He has published more than 30 journals and conference papers in these 002elds Dr Pastor is leading the ICARUS Intelligent Communications and Avionics for Robust Unmanned Aerial Systems Research Group completely focused on the development of systems that support and facilitate practical applications of UAS technology The ICARUS group is especially interested in developing wildland 002re monitoring tools and strategies both using UAS technology and classical vehicles The ICARUS group has published more that 25 research papers on UAS technology in the last three years Marc Sole holds a Ph D 2009 On Computer Sciences by the Technical University of Catalonia where he is also an Assistant Professor in the Computer Sciences Faculty of Barcelona His Ph.D thesis was focused on automated formal veri\002cation of timed concurrent systems Research interests include formal veri\002cation process mining data anonymization and UAS He belongs to the ICARUS research group Juan Lopez is an assistant professor at the Technical University of Catalonia Its main interests are embedded software architectures and unmanned aircraft systems design Currently he is working in middleware based avionics architectures for UAS 17 


Pablo Royo received a degree in Telecommunication Engineering from the Technical University of Catalonia Now he is an assistant professor at the Technical University of Catalonia His research interests include the Unmanned Aerial System design and their application in autonomous intelligent applications Cristina Barrado holds a Ph D on Computer Sciences by the Technical University of Catalonia where she is also an Associate Professor at the Castelldefels School of Technology Spain She has been teaching operating systems since 1990 and currently a course of Digital Avionics Systems Her Ph.D Thesis was focused on automatic extraction of low level parallelism on loops at compile time She belongs to the ICARUS Research Group which target is the research on Unmanned Aerial Systems their architecture their civil uses and their integration into the airspace 18 


216, Washington, DC, June, 1993 2] Richard A. Brualdi, Introductory Combinatorics, Prentice Hall, 1992 3] A. Barr and E.A. Feigenbaum, The handbook of Arti?cial Intelligence, Willam Kaufmann 1981 4] Margaret H. Dunham, Data Mining Introduction and Advanced Topics Prentice Hall, 2003, ISBN 0-13088892-3 5] Fayad U. M., Piatetsky-Sjapiro, G. Smyth, P. \(1996 From Data Mining to Knowledge Discovery: An overview. In Fayard, Piatetsky-Sjapiro, Smyth, and Uthurusamy eds., Knowledge Discovery in Databases AAAI/MIT Press, 1996 6] H Gracia-Molina, J. Ullman. &amp; J. Windin, J, Database Systems The Complete Book, Prentice Hall, 2002 7] T. T. Lee  Algebraic Theory of Relational Databases  The Bell System Technical Journal Vol 62, No 10, December, 1983, pp.3159-3204 8] T. Y. Lin  Deductive Data Mining: Mathematical Foundation of Database Mining  in: the Proceedings of 9th International Conference, RSFDGrC 2003 Chongqing, China, May 2003, Lecture Notes on Arti?cial Intelligence LNAI 2639, Springer-Verlag, 403-405 9] T. Y. Lin  Attribute \(Feature  The Theory of Attributes from Data Mining Prospect  in: Proceeding of IEEE international Conference on Data Mining, Maebashi, Japan, Dec 9-12, 2002, pp. pp.282-289 10] T. Y. Lin  Data Mining and Machine Oriented Modeling: A Granular Computing Approach  Journal of Applied Intelligence, Kluwer, Vol. 13, No 2, September/October,2000, pp.113-124 11] T. Y. Lin, N. Zhong, J. Duong, S. Ohsuga  Frameworks for Mining Binary Relations in Data  In: Rough sets and Current Trends in Computing, Lecture Notes on Arti?cial Intelligence 1424, A. Skoworn and L Polkowski \(eds 12] E. Louie,T. Y. Lin  Semantics Oriented Association Rules  In: 2002 World Congress of Computational Intelligence, Honolulu, Hawaii, May 12-17, 2002, 956961 \(paper # 5702 13  The Power and Limit of Neural Networks  Proceedings of the 1996 EngineeringSystems Design and Analysis Conference, Montpellier, France, July 1-4, 1996 Vol. 7, 49-53 14] Morel, Jean-Michel and Sergio Solimini, Variational methods in image segmentation : with seven image processing experiments Boston : Birkhuser, 1995 15] H. Liu and H. Motoda  Feature Transformation and Subset Selection  IEEE Intelligent Systems, Vol. 13 No. 2, March/April, pp.26-28 \(1998 16] Z. Pawlak, Rough sets. Theoretical Aspects of Reasoning about Data, Kluwer Academic Publishers, 1991 Proceedings of the Fourth IEEE International Conference on Data Mining \(ICDM  04 0-7695-2142-8/04 $ 20.00 IEEE pre></body></html 


than that of MAFIA and the runtime of MHP can be significantly less than that of MAFIA 5.3. The Effect of the MHP Algorithm on Finding Maximal Hyperclique Patterns Figure 8 and Figure 9 show the number of maximal patterns identi?ed byMHP andMAFIA on Pumsb* and Pumsb data sets respectively. As can be seen, the number of maximal hyperclique patterns identi?ed by MHP can be orders of magnitude smaller than the number of maximal frequent patterns identi?ed by MAFIA. In other words, the number Proceedings of the 16th IEEE International Conference on Tools with Artificial Intelligence \(ICTAI 2004 1082-3409/04 $20.00  2004 IEEE 100 1000 10000 100000 1e+06 1e+07 1e+08 1e+09 0.02 0.025 0.03 0.035 0.04 0.045 0.05 0.055 0.06 N um be r o f C ou nt ed P at te rn s Support Threshold Mafia Min_Conf=0 Min_Conf=0.1 Min_Conf=0.3 Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 8. The Number of MFI/MHP Patterns in the Pumsb* Data Set 100 1000 10000 100000 1e+06 


1e+07 1e+08 0.1 0.2 0.3 0.4 0.5 0.6 0.7 N um be r o f C ou nt ed P at te rn s Support Threshold Mafia Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 9. The number of MFI/MHP Patterns in the Pumsb Data Set of maximal hyperclique patterns is much easier to manage than that of maximal frequent patterns. Indeed, in realworld applications, it is dif?cult to interpret several million maximal frequent patterns. However, it is possible to interpret the results of maximal hyperclique pattern mining In addition, due to the memory limitation, we cannot extract maximal frequent patterns with MAFIA on the Pumsb data set if the support threshold is less than 0.4, as shown in Figure 7. In contrast, MHP can identify maximal hyperclique patterns when the support threshold is 0.1, if we set the h-con?dence threshold to 0.5. In other words, MHP has the ability to identify patterns which can be dif?cult to identify for MAFIA. Hence, MHP can better explore the pattern space and ?nd interesting patterns at low levels of support 6. Conclusions and Future Work In this paper, we present a two-phase Maximal Hyperclique Pattern \(MHP best features of both the BFS strategy and the DFS strategy. More speci?cally, we adapted DFS pruning methods such as equivalence pruning, to an apriori-like approach In addition, we proved the correctness and completeness of the MHP algorithm. Finally, our experimental results show that the MHP algorithm can be several orders of magnitude faster than standard maximal frequent pattern mining algorithms and has the ability to identify patterns at extremely low levels of support in dense data sets There are several directions for future work. First, in 


this paper, we only generate the size-2 patterns in the BFS phase. It will be interesting to investigate the impact on the performance if the ?rst phase is stopped at a deeper level Also, the projection is a very ef?cient method for ?nding patterns, especially for parallel implementation of pattern mining algorithms [1]. We plan to adapt the projection ideas into our algorithm and design an ef?cient parallel algorithm for mining maximal hyperclique patterns References 1] R. Agarwal, C. Aggarwal, and V. Prasad. A Tree Projection Algorithm For Generation of Frequent Itemsets. pages 350 371, Feb 2001 2] R. Agrawal, T. Imielinski, and A. Swami. Mining Association Rules between Sets of Items in Large Databases. In Proc. of the ACM SIGMOD Conference on Management of Data, pages 207216,May 1993 3] R. Agrawal and R. Srikant. Fast Algorithms for Mining Association Rules. In Proc. of the 20th Intl Conference on Very LargeData Bases, 1994 4] R. Bayardo. Ef?ciently mining long patterns from databases In Proc. of the ACM SIGMOD Conference, 1998 5] R. Bayardo and R. Agrawal. Mining the Most Interesting Rules. In Proc. of the ACM SIGKDD Conference, 1999 6] D. Burdick, M. Calimlim, and J. Gehrke. Ma?a: AMaximal Frequent Itemset Algorithm for Transactional Databases. In Proc. of IEEE Conf. on Data Engineering, 2001 7] Y. Huang, H. Xiong, W. Wu, and Z. Zhang. A Hybrid Approach for Mining Maximal Hyperclique Patterns. In In Technical Report UTDCS-34-04, Department of computer science, University of Texas - Dallas, 2004 8] J.Han, J.Pei, and Y. Yin. Mining Frequent Patterns without Candidate Generation. In Proc. of the ACM SIGMOD International Conference on Management of Data, 2000 9] M.J.Zaki and C.Hsiao. ChARM: An ef?cient algorithm for closed itemset mining. In Proc. of 2nd SIAM International Conference on Data Mining, 2002 10] R.Rymon. Search through Systematic Set Enumeration. In Proc. Third Intl Conference on Principles of Knowledge Representation and Reasoning, 1992 11] H. Xiong, M. Steinbach, P.-N. Tan, and V. Kumar. HICAP: Hierarchial Clustering with Pattern Preservation. In Proc. of 2004 SIAM International Conference on Data Mining \(SDM 12] H. Xiong, P.-N. Tan, and V. Kumar. Mining Strong Af?nity Association Patterns in Data Set with Skewed Support. In Proc. of the Third IEEE International Conference on Data Mining \(ICDM Proceedings of the 16th IEEE International Conference on Tools with Artificial Intelligence \(ICTAI 2004 1082-3409/04 $20.00  2004 IEEE 





