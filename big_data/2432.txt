Personalized Instructing Recommendati on System Based on Web Mining   Liang Zhang 1 Xiumin 1 Liu, Xiujuan Liu 2   1 Information & Engineering School of Hangzhou Normal University Hangzhou, Zhejiang, China 2 Mathematics & Information Engineering School of Jiaxing College, Jiaxing, Zhejiang, China zhl@hznu.edu.cn, zjrcxy2007@126.com  Abstract  A novel Personalized Instructing Recommendation System \(PIRS\ is designed for Web-based learning This system recognizes different patterns of learning style and Web using habits through testing the learning styles of students and mining their Web browsing logs Firstly, it processes the sparse data by Item-Based Top-N recommendation algorithm in the course of testing the learning styles. Then it analyzes the habits and the interests of the Web users through mining the frequent sequences in the Web browsing logs by AprioriAll algorithm. Finally, this system completes personalized recommendation of the learning content based on the learning style and the habit of Web usage Experiment shows that the recommendation model proposed in this paper, is not only satisfied with the urgent need of the users, but also feasible and effective Key words  Learning Style, Web Mining, Personalized Recommendation, AprioriAll Algorithm  1.  Introduction  With the popularization and rapid development of the Internet, Web-based learning has become a new trend for its freedom in time, space and its convenience in collaboration learning. However, with the explosive growth of the information on Web, the Internet is flooded with is tremendous ìtrashesî. The students do not know what to do while facing the miscellaneous information. So there is urgent need to the system to filter and recommend the information, which meet the need of the students There are many systems of personalized recommendation based on data mining technology at present. These systems mainly adopt three approaches for recommendation. Firstly, the systems combined the usersí rating of the learned content and their personal information to carry out collaborative recommendation such as literature [1 f ter ratin g o f W e b p a g e s m a d e  by students, the system gives recommendation to the students who share nearly the same interests based on their similar age, major and knowledge structure Secondly, the systems offered recommendation according to the content based on information filtering such as Personal WebWatche W e b P ers o n a lizer[3   GroupLens d Si t e Seer[5 T h ey off e red recommendation using the similarities between the sources and the usersí interesting, as well as the similarities among the usersí personal information Thirdly, the systems gave recommendation according to the userís sequences of accessing website. For example, WUM \(Web Utilization Miner i n e d the sequential pattern of Web log, which provided a integrated environment in cluding log preparation pattern inquiry and visualization interface WebMin pu t f o r w ard a po pu lar arch itectu r e of  Web logs mining to find association rules and sequential patterns from Web log automatically, which adopted a usage pattern mining technology including route analysis and association rules mining This paper proposes a method to test learning style through the psychology scale. By the reason of he sparse of collected data, it uses collaborative filtering algorithm based on item rating prediction to fill in the score of un-rated items, so as to evaluate the students learning styles as correctly as possible. Moreover, the system collects Web logs of different students to form a series of accessing sequence sets according to their learning styles. AprioriAll algorithm was used to find frequent sequences of these sets to obtain Web usage patterns of different learning style students. Hence, real time recommendation can be made to provide student possible Web pages of later click to improve their learning efficiency This paper is organized as follows: Section 2 is about the Architecture design of personalized instructing recommendation system. The realizing steps of PIRS is involved in Section 3. Section 4 describes the recommendation system and analyzes experimental results. Section 5 summarizes the paper, explains the existing problems and proposes the feasible solutions  2. Architecture of PIRS  A new design framework should be adopted in the mining process according to the architecture of WWW and the characteristics of E-learning. The author constructs a student model through mining behavior of studentsí browsing records \(recorded in serverís logs 
The 9th International Conference for Young Computer Scientists 978-0-7695-3398-8/08 $25.00 © 2008 IEEE DOI 10.1109/ICYCS.2008.115 2517 


and analyzes the learning styles of the students, shown in figure 1. When students register to the Website, their learning styles need to be tested firstly. There are always many un-rated items in psychology scale. PRIS uses the collaborative filtering algorithm based on item rating prediction to predict itemsí score which have not been rated, and then obtains the certain kinds of the studentsí learning styles after calculating the total score   User brower   Collaborative filte ring  pridicting un-rated items  Learning style  Testing learning s tyle  Web server Web log MFR AprioriAll Mining Frequent Sequences User model data Patterns Database Personalized recommendation system Log in Recommendation Register  Figure 1 Architecture of PIRS  When students login and browse the website, their access paths are recorded in Web server in the form of Web logs. For the purpose of filtering the noisy information, studentsí access paths are pre-process to the Maximal forward reference paths \(MFR\hen AprioriAll algorithm is used to mine frequent sequences of Web logs. Separating frequent sequences by learning styles, the system get individual interested model according to the learning styles. Web access pattern database records frequent sequences associated with the learning styles, which provides for personalized recommendation module later. If students access paths match the prefix of the frequent sequences belonging to their learning styles, the web pages which correspond to the later part of the sequences can be selected as recommendation web pages  3. Implementation of PIRS  3.1. Testing learning style  Learning style is the direction or preference of studentís learning method. It is a specific cognitive emotional and physiological behavior of the learner which implies personal learning method of the students. In order to test the learning style of the students accurately, this paper adopts Solomonís Style scale and Kolbís Scale. Because students may not rate all of the items of these two scales, the learning style canít be tested accurately after summing up the items scores of the target users As shown in figure 2, this paper adopts collaborative filtering algorithm based on item rating prediction to calculate the similarities among items. Hence, the neighbors of every un-rated item are found. The system predicts the un-rated itemsí scores by their neighbors scores and the similarities between them. By using item-based collaborative filtering algorithm, the system solves the emerging problems of the sparseness data Now, studentsí learning style can be tested more accurately  Scale items Rating or not Finding neighbors NO P ridic ting un-rated items Ca lcula ting Scale-Score Outputing learning style Yes  Figure 2 Procedure of Testing Learning Style  The studentsí rates are represented by matrix, as show in figure 3. The first column is the usersí name or ID, and the first row is the testing items of psychology scales. R ij represents the score of item-j rated by User-i User \\ Project Item-1 Item-2  Item-j  Item-m User-1 R11 R12  R1j   User-2 R21   R2j  R2m   User-i Ri1 Ri2  Rij    User-n  Rn2  Rnj  Rnm  Figure 3 Data Matrix of Studentsí Rates  Because of the lack the studentsí rating on some items, it is very common in the self-learning environment that the psychology scale cannot estimates the studentsí learning style accurately. Therefore it is necessary to fill the unfinished part of the matrix which means to rate the un-rated itemsí scores. The 
2518 


author accomplishes the rating on the unfinished part by two steps 1\ Calculating the similarities between two items Supposing all of the users U have simultaneously made the appraisal to Item-j1 and Item-j2, the similarities between Item-j1 and Item-j2 can be calculated by many kinds of arithmetic T h i s paper  uses Pearson-r to calculate, and its formula is shown as follows    12 1  2 si  1 2 22   12 1  2 RRR R jj uU uj uj mj j RR R R jj uU uU uj uj      1 Where 1 R uj denotes the rating of user U on itemj1 1 R j is the average rating of the j1-th item 2\ Calculating the un-rated itemís score According to the first step, the top-N most similar items of un-rated item are obtained. Assuming that user has not rated item-i, the following formula can be used to calculate the unknown score        Sim R all simillar items N iN uN P ui Sim all simillar items N iN  2 Finally, the recommendation system can get the summation of the studentsí rates on the scale, as well as the type of the studentsí learning style  3.2. Pattern Discovery and Personalized Recommendation  Finding out all sets of frequent sequence from learnersí access transactions of different styles is one of the main goals of the system to discover the Web using habit, which implies the factors of usersí interests. Here algorithm of AprioriAll is adopted to mine frequent sequences. Detail process of the implementation is described as follows 1\ Searching for frequent sequences  After extracting userís access sequences from Web log file of the server, PIRS pre-processes these sequences to MFR path. As shown in figure 4\(a\he field of Tid represents transaction number, Sid the type of learning styles, Tp the access path in the transactions. After that, AprioriAll algorithm is used to mining frequent sequences according to learning style respectively. Results are showed in figure 4\(b\here Ep represents the frequent sequences, which respond to different learning styles  Tid T1000 T1001 T1002 T1003 T1004 T1005 T1006 T1007 Sid S1 S1 S1 S1 S2 S2 S2 S2 Tp ABCDEFD ACEFG ABCEFG CEFG ABCDEF BCADEF ABCEF BCE Tid T1000 T1001 T1002 T1003 T1004 T1005 T1006 T1007 Sid S1 S1 S1 S1 S2 S2 S2 S2 Fp ACEFG BCEF  a\                                   \(b Figure 4 Mining Frequent Sequences 2\ Algorithm of AprioriAll The first step: is seeking for the frequent sequences For every candidate sequence c with length of i, the algorithm carries out the traversal of the transaction database to test whether its support value is greater than the threshold value, min_sup. All of the frequent sequences, which have lager support values than min_sup, constitute the frequent sequence set L i  For the purpose of finding longer frequent sequences the algorithm uses these sequences in collection L i to produce new longer sequences with length of i+1, as the candidates of longer frequent sequences. How to produce new longer candidate sequences is described in the second step The second step: is connecting step, carrying out 1 L k  and 1 L k  connection operation, such as connecting 1,2,3> and <1,2,4> to form <1,2,3,4> and <1, 2, 4, 3 two sequences The third step: is pruning step, carrying out the redundancy trim. After two sequences connected together, if any of its contiguous \(k-1\ubsequence is out of 1 L k  this sequence should be deleted Specific realization of AprioriAll algorithm is described as follows Input: transaction database D, Smallest support threshold value min_sup Output: all frequent sequences collection Lk of database D L 1 find_frequent_items of sequences\(D For \( k=2; L K-1 k C k AprioriAll-generate \( L K-1 min_sup For each candidate c C k  If c.support > min_sup then  L k L k U c  Return L= all L K   Procedure AprioriAll-generate \(L K-1 frequent \(k-1\; min_sup For each sequence l 1 L K-1  For each sequence l 2 L K-1  If \(l 1 1 l 2    l 1 2 l 2 2   l 1 k-2   l 2 k-2  l 1 k-1 l 2 k-1  t h e n   c= l 1  l 2  If has_infrequent_subset \(c, L K-1 en Delete c Else add c to C k   
2519 


Return C k   Procedure has_infrequent_subset \(c: candidate_k sequence; L K-1  frequent \(k-1  For each \(k-1\-subsequences of c If c  L K-1 then  Return true Else Return false  3\ Personalized recommendation  The students of different learning styles have different sets of frequent sequence. Recommendation can be carried out according to these frequent sequences, which can be implemented as follows Recommendation system uses fixed size of sliding window to cover on present userís access sequence for predicting next operating. Meanwhile, userís access sequence is continually changing within the sliding window. Assuming that the size of the sliding windows is size 4, userís present access sequence within the sliding window may be <A, B, C, D>. The next new ones will turn into the sequence of <B, C, D, E>. How can the recommendation system predict E from <A, B C, D>? It relays on frequent sequence sets of different learning styles. For example, if sequences of <A, B, C D, X> and <A, B, C, D, Y> are two frequent sequences whose learning style is the same with the user, then X and Y may be recommended to the user  4.  Analysis of the Experiment Results   In the fall 2007 semester, the system was used for the sophomore studentsí course of computer organization and architecture, in Hangzhou Normal University of China. After class, students may use this system to learn extra content of the course. By providing recommendation, students can browse Web pages more convenient than before, which meet their need and interesting   Figure 5 Comparison of Satisfaction Degree  To get subjective evaluation of this system, at the end of the course we administered a non-mandatory questionnaire that collected students' opinions about the main features of the system. Out of 63 students in 2 classes, 60 students filled the questionnaire. After processing the answers, we show the results in figure 5 From the convenience, it shows that more then 60% of students considered the system improved, meaning that it has help learning. Two principal features of systemís speed and accuracy were evaluated. 63% and 64% of the students are satisfied with the speed and accuracy respectively, but there is no more than 40% students approve the recommendation system when only considering frequent sequence Students enjoy the Next step recommendation, which greatly reduce searching time in self-learning Moreover, more then 50% of students considered the system is adaptive. The recommended information is also renewed as the learning styles are renewed. The studentsí learning styles are not limited to the only one which may prefer to some styles more or less. This system carries out many times of testing on students learning styles, updating the records when they changed  5.  Conclusions  This paper presents the architecture and mechanism of the personalized instructing recommendation system It has been shown that melting studentís learning style into recommendation strategy is useful to predict studentís next operating. AprioriAll algorithm is used to find frequent sequence of Web access pattern. The system has achieved a remarkable impact on student self-learning. Taking advantage of the system, the students have learned more content and browsed more Web pages they need. The high of the learning efficiency with the system resulted in the larger increase of their knowledge at the end of the course. In the future, technology of student model is worth studying deeply to improve the accuracy of learning style representation. For the sake of change of Web access path, adaptive and incremental mining method should be adopted to improve the system more flexibly  References  1  Ge Liang, Kong Weining, and Luo Junzhou Courseware Recommendation in E-Learning System. In Proc. of the 5th International Conference on Web-based Learning, 2006\(7\:19-21 2  Mladenic, D. Machine learning for better Web browsing. In: Proc. of Rogers, S., Iba, W., eds. AAAI 2000 Spring Symposium Technical Reports on Adaptive 
2520 


User Interfaces. Menlo Park, CA: AAAI Press, 2000 82~84 3  Mobasher, B., Cooley, R., Srivastava, J. Automatic personalization based on Web usage mining. In: Proc. of communications of the ACM, 2000, 43\(8\:142~151 4  Konstan, J., Miller, B., Maltz, D., et al. GroupLens Applying collaborative filtering to use net news. In Proc. of communications of the ACM, 1997 40\(3\:77~87 5  Rucker, J., Polanco, M.J. Siteseer: Personalized navigation for the Web. In: Proc. of communications of the ACM, 1997, 40\(3\:73~75 6  Myra Spiliopoulou, Luckas C. Faulstich. Wum: A Tool for Web Utilization Analysis. In: Proc. of EDBT Workshop at WebDBí98[M   L N C S 1590 Spr i ng e r  Verlag, l998.184~203 7  Myra Spiliopoulou, Carsten Poh 1e Lukas C Faulstich. Improving the Effectiveness of a Web Site with Web Usage Mining[M  In P r o c  o f W E BKDD  San, CA.1999 8  Osmar R. Zaiane, Man Xin, Jiawei Han. Discovering Web Access Patterns and Trends by Applying OLAP and Data Mining technology on Web Logs[A  I n  Pr oc   of  Advances in Digital Libraries Conference ADLí98 Santa Barbara, CA, USA.1998,4:19~26 9  Karypis G. Evaluation of Item-based Top-N Recommendation Algorithms[R  Min n e a polis  D e pt of  Computer Science, University of Minnesota, Technical Report: #00-046, 2000 10  Jiawei Han, Michelinc Kamber. Data Mining Concepts and Techniques[M Bei Ji n g   Ch i n a M ach i n e p r ess  2001.8:152~157 11  Sarwar B, Karypis G, Konstan J, Riedl J. Item-Based collaborative filtering recommendation algorithms. In Proc. of the 10th Int'l World Wide Web Conf. New York: ACM Press, 2001. 285~295  
2521 


Figure 4 A market basket analysis dataset Top left 100 item nodes from Apple  Eve Apple Juice to Yo-Ho Potato Chips are interconnected by 1,126 edges The edges signify that 1,126 pair of items are sold together The bird eye view offers a clue to strongly frequent itemsets such as f Pillsbury Cake Mix Pillsbury Biscuits Jiffy Muf\002n Mix g  Top right Node and edge query by mouse click on Pillsbury Cake Mix reveals all the edges connected to the item and the total edge weight Middle left Powerful zoom-in features reveal that Pillsbury Cake Mix has high support with other items such as the neighboring Pillsbury Biscuits Middle right Automatic rotation of the grid around Y axis with a deep perspective view like this gives the fun of a roller-coaster ride while visually exploring the dataset Bottom Examples of interactive edge pruning at minimum edge weight 17 left and 23 right in which 3-frequent itemsets f Pillsbury Cake Mix Pillsbury Biscuits Jiffy Muf\002n Mix g and f Pillsbury Cake Mix Pillsbury Biscuits Bigelow Apple  Cinnamon Herb Tea g are visually obvious 
465 


Figure 5 Top The US Presidential election 2004 dataset Left 25 Presidential candidates are in red boxes and 50 states are in gray spheres Edges are concentrated on Bush and Kerry signifying that they are the two leading candidates Total number of votes thrown to Bush and Kerry are queried by clicking the respective nodes Right States such as California Florida Georgia Illinois and Michigan show very close support for Bush and Kerry The red edge between Kerry and California reveals that Kerry has the largest number of votes in the nation from California Next 2 rows A publication coauthorship dataset of 968 authors and 3,470 coauthorship relationships The impact of edge weight threshold  022  on the coauthorship data Middle left 3470 edges at 022 0 Middle right 384 edges at 022 2 Bottom left 10 edges at 022 6 Pruning by edge threshold helps to focus on statistically signi\002cant relationships quickly Bottom right Exploration of outstanding edges leads to the discovery of S K Card's coauthorship i.e 72 in total by clicking the S K Card node 
466 


is turned into a wire framed sphere all the connected edges to the node are highlighted in white and the detailed information on the node is displayed With this dataset the user interaction functionality performed smooth This dataset is also used to test interactive 002ltering of nodes and edges and reverting of the previous 002ltering The bottom 2 002gures in Figure 4 shows edge pruning at two different edge weight thresholds 17 and 23 With this pruning function we were able to discover 3-frequent itemsets such as f Pillsbury Cake Mix Pillsbury Biscuits Jiffy Muf\002n Mix g  quickly 2004 US presidential election dataset This dataset is obtained from FEDERAL ELECTIONS 2004 by Federal Election Commission This dataset is bipartite of two distinct object classes 25 presidential candidates and 50 voting states The objects of the presidential candidate class appear in red cubes and the states are rendered in gray spheres as shown in Figure 5 An edge weight represents the number of popular votes thrown to a candidate from a state The number of votes for Bush Kerry and all others by state are shown in Figure 3 The perspective of each histogram is different such that the left represents total popular votes by candidate whereas the right is by state These two perspectives are uni\002ed into one in Round3D shown in Figure 5 From the Round3D view we can visually and textually inspect the total number of votes thrown by each state to each candidate and the total number of votes received by each candidate from each state For example from the top left 002gure in Figure 5 we 002nd that Bush and Kerry are the two top runners From the top right 002gure it is clear that California threw the largest number of votes in the nation and Florida is the second It is also shown that California is in favor of Kerry more than Bush Co-authorship datasets small and large Two coauthorship datasets in scienti\002c publication are tested with Round3D One is from the InfoVis 2004 contest 968 authors and 3,470 coauthorship and the other dataset is from CiteSeer 19,898 authors and 8,294 coauthorship Both datasets were tested well The bottom 4 002gures in Figure 5 shows global summaries of the coauthorship as well as the details of individual author in which the degree of coauthorship of most authors is relatively low One outstanding example is S K Card shown in the 002gure This fact is well observed in Figure 5 as edges are pruned by increasing edge weight threshold With the larger co-authorship dataset we experienced noticeable lagging in user interaction 5 Conclusion and Future Work The preliminary results from the proposed Round3D were pleasant and promising as an in-memory tool They also expose shortcomings in our current approaches Our biggest concern is scalability for a massive dataset We plan to overcome this issue by two ways First we will make nodes and edges light by storing all the information other than their unique IDs in a high performing standalone database and access the details on demand With this approach we also plan to offer a versatile SQL query interface Second we consider to present meta-relationships at a high-level view 002rst and low-level views later as needed References  J Abello and J K orn MGV  A System for V isualizing Massive Multidigraphs  IEEE TVCG  8\(1 Jan-Mar 2002  L A Adamic and E Adar  Friends and Neighbors on the Web Social Networks  July 2003  M C F  de Oli v eira and H Le vk o witz From V isual Data Exploration to Visual Data Mining A Survey IEEE TVCG  9\(3 Jul-Sep 2003  W  H Hsu A L King M S R P aradesi T  Pydimarri and T Weninger Collaborative and Structural Recommendation of Friends using Weblog-based Social Network Analysis In Proc of AAAI Spring Symposia  pages 55ñ60 March 2006  T H Huang and M L Huang Analysis and V isualization of Co-authorship Networks for Understanding Academic Collaboration and Knowledge Domain of Individual Researchers In Proc of the 3rd CGIV  pages 18ñ23 2006  D A K eim Designing Pix el-Orient ed V isualization T echniques Theory and Applications IEEE TVCG  6\(1 Jan-Mar 2000  D A K eim C P anse M Sips and S C North V isual Data Mining in Large Geospatial Point Sets IEEE CG&A  24\(5 Sep-Oct 2004  R K umar  P  Ragha v an S Rajagopalan and A T omkins The Web and Social Networks IEEE Computer  35\(11 36 Nov 2002  Y  Matsuo and M Ishizuka K e yw ord Extraction from a Single Document using Word Co-occurrence Statistical Information Int'l J on AI Tools  13:157ñ169 2004  M E J Ne wman Coauthorship net w orks and patterns of scienti\002c collaboration Proc of the National Academy of Sciences of USA  101\(1 April 6 2004  J O'Madadhain D Fisher  P  Smyth S White and Y B Boey Analysis and Visualization of Network Data using JUNG J of Statistical Software  VV 2005  T  C Sprenger  R Brunella and M H Gross H-BLOB a hierarchical visual clustering method using implicit surfaces In Proc of the Conf on Visualization  pages 61ñ68 2000  E T ejada and R Minghim Impro v ed V isual Clustering of Large Multi-dimensional Data Sets In Proc of the 9th Int'l Conf on Info Visualisation  pages 818ñ825 July 2005  P  C W ong P  Whitne y  and J Thomas V isualizing Association Rules for Text Mining In Proc of IEEE InfoVis  pages 120ñ123 Oct 1999 
467 


5 Related Work There exists extensive previous work on both the mining of software repositories and on the use of clustering algorithms in software engineering This discussion focuses on the most similar and recent work in the area of software evolution Mining Software Repositories Our technique was partially inspired by the work of Zimmermann et al and Y ing et al 17 on the mining of association rules in change history As described in Section 1 we sought to expand the technique to be able to recommend larger but less precise clusters of elements to guide program navigation Bouktif et al also investigated how to recommend cochanges in software development As opposed to the work cited above Bouktif et al used change patterns instead of association rules Also their approach does not attempt to reconstruct transactions and can consider associated 002les that were changed in different transactions ChangeDistiller is a tool to classify changes in a transaction into 002ne-grained operations e.g addition of a method declaration and determines how strongly the change impacts other source code entities Our approach uses similar repository analysis techniques but is focused on providing task-related information as opposed to an overall assessment of a system's evolution Finally repository mining can also be used to detect aspects in the code In this conte xt aspects are recurring sets of changed elements that exhibit a regular structure Aspects differ from the clusters we detect in the regular structure they exhibit which may not necessarily align with the code that is investigated as part of change tasks Clustering Analysis The classical application of clustering for reverse engineering involves grouping software entities based on an analysis of various relations between pairs of entities of a given version of the system Despite its long and rich history  e xperimentation with this approach continues to this day For example Andreopoulos et al combined static and dynamic information K uhn et al used a te xtual similarity measure as the clustering relation and Christl et al used clustering to assist iterative semi-automated reverse engineering The main dif ferences b e tween most clusteringbased reverse engineering techniques and the subject of our investigation is that the entities we cluster are transactions rather than software entities in a single version of a system For this reason our analysis is based strictly on the evolving parts of the system Both Kothari et al and V an ya et al 15 recently reported on their use of clustering to study the evolution of software systems The idea of using change clusters is the same in both works and ours but the purpose of the work is different Kothari et al use change clusters to uncover the types of changes that happened e.g feature addition maintenance etc during the history of a software system Vanya et al use change clusters which they call evolutionary clusters to guide the partitioning of a system that would increase the likelihood that the parts of the system would evolve independently In contrast we cluster transactions based on overlapping elements not 002les to recommend clusters to support program navigation as opposed to architectural-level assessment of the system Finally Hassan and Holt evaluated on 002ve open source systems the performance of several methods to indicate elements that should be modi\002ed together This study found that using historical co-change information as opposed to using simple static analysis or code layout offered the best results in terms of recall and precision The authors then tried to improve the results using 002ltering heuristics and found that keeping only the most frequently cochanged entities yielded the best results As opposed to our approach the evaluated 002ltering heuristics were only applied on entities recovered using association rules and not using clustering techniques The focus of their study was also more speci\002c as they recommend program elements that were strictly changed  as opposed to recommending elements that might be inspected by developers 6 Conclusion Developers often need to discover code that has been navigated in the past We investigated to what extent we can bene\002t from change clusters to guide program navigation We de\002ned change clusters as groups of elements that were part of transactions or change sets that had elements in common Our analysis of close to 12 years of software change data for a total of seven different open-source systems revealed that less than 12 of the changes we studied could have bene\002ted from change clusters We conclude that further efforts should thus focus on maximizing the quality of the match between the current task and past transactions rather than 002nding many potential matches Our study has already helped us in this goal by providing reliable evidence of the effectiveness of some 002ltering heuristics and useful insights for the development of additional heuristics Acknowledgments The authors thank Emily Hill and Jos  e Correa for their advice on the statistical tests and the anonymous reviewers for their helpful suggestions This work was supported by NSERC 
25 
25 
25 
25 
25 


References  B Andreopoulos A An V  Tzerpos and X W ang Multiple layer clustering of large software systems In Proc 12th Working Conf on Reverse Engineering  pages 79ñ88 2005  S Bouktif Y G Gu  eh  eneuc and G Antoniol Extracting change-patterns from cvs repositories In Proc 13th Working Conf on Reverse Engineering  pages 221ñ230 2006  S Breu and T  Zimmermann Mining aspects from v ersion history In Proc 21st IEEE/ACM Int'l Conf on Automated Software Engineering  pages 221ñ230 2006  A Christl R K oschk e and M.-A Store y  Equipping the re\003exion method with automated clustering In Proc 12th Working Conf on Reverse Engineering  pages 89ñ98 2005  D 020 Cubrani  c G C Murphy J Singer and K S Booth Hipikat A project memory for software development IEEE Transactions on Software Engineering  31\(6 465 2005  B Fluri and H C Gall Classifyi ng change types for qualifying change couplings In Proc 14th IEEE Int'l Conf on Program Comprehension  pages 35ñ45 2006  A E Hassan and R C Holt Replaying de v elopment history to assess the effectiveness of change propagation tools Empirical Software Engineering  11\(3 2006  D H Hutchens and V  R Basili System s tructure analysis Clustering with data bindings IEEE Transactions on Software Engineering  11\(8 1985  D Janzen and K De V older Na vig ating and querying code without getting lost In Proc 2nd Int'l Conf on AspectOriented Software Development  pages 178ñ187 2003  J K ot hari T  Denton A Shok ouf andeh S Mancoridis and A E Hassan Studying the evolution of software systems using change clusters In Proc 14th IEEE Int'l Conf on Program Comprehension  pages 46ñ55 2006  A K uhn S Ducasse and T  G  021rba Enriching reverse engineering with semantic clustering In Proc 12th Working Conf on Reverse Engineering  pages 133ñ142 2005  M P  Robillard T opology analysis of softw are dependencies ACM Transactions on Software Engineering and Methodology  2008 To appear  M P  Robillard and P  Mangg ala Reusing program in v estigation knowledge for code understanding In Proc 16th IEEE Int'l Conf on Program Comprehension  pages 202 211 2008  J Sillito G Murph y  and K De V older Questions programmers ask during software evolution tasks In Proc 14th ACM SIGSOFT Int'l Symposium on the Foundations of Software Engineering  pages 23ñ34 2006  A V an ya L Ho\003and S Klusener  P  v an de Laar and H van Vliet Assessing software archives with evolutionary clusters In Proc 16th IEEE Int'l Conf on Program Comprehension  pages 192ñ201 2008  N W ilde and M C Scully  Softw are reconnaissance Mapping program features to code Software Maintenance Research and Practice  7:49ñ62 1995  A T  Y ing G C Murph y  R Ng and M C Chu-Carroll Predicting source code changes by mining change history IEEE Transactions on Software Engineering  30\(9 586 2004  A Zeller  The future of programming en vironments Integration synergy and assistance In Proceedings of the 29th International Conference on Software Engineering The Future of Software Engineering  pages 316ñ325 2007  T  Zimmermann and P  W eiﬂgerber  Preprocessing C VS data for 002ne-grained analysis In Proc 1st Int'l Workshop on Mining Software Repositories  pages 2ñ6 May 2004  T  Zimmermann P  W eiﬂgerber  S Diehl and A Zeller  Mining version histories to guide software changes In Proc 26th ACM/IEEE Int'l Conf on Software Engineering  pages 563ñ572 2004 A Clustering Algorithm This algorithm is not sensitive to whether a given program element exists or not in a given version of a program For example if method m exists in one version it is considered a valid program element even if it is removed in a later version In the rest of this section we use the term program element to refer to the uniquely identifying representation of the element e.g a Java fully-quali\002ed name Let T be a transaction modeled as a set of program elements changed together during the history of a software system Let T be a sequence of transactions In this algorithm a cluster is also modeled as a set of elements 1 Input  T  A sequence of transactions 2 Parameter  M IN O VERLAP  A positive non-zero value indicating the minimum overlap between two transactions in a cluster 3 Var  C  A set of clusters initially empty 4 for all T i 2 T do 5 MaxOverlap  0 6 MaxIndex  000 1 7 for all C j 2 C do 8 if j C j  T i j  MaxOverlap then 9 MaxOverlap  j C j  T i j 10 MaxIndex  j 11 end if 12 end for 13 if MaxIndex   0  MaxOverlap 025 M IN O VERLAP  then 14 C MaxIndex   C MaxIndex  T i  15 else 16 NewCluster  T i 17 C  C  f NewCluster g 18 end if 19 end for 20 return C B Systems Analyzed System home pages last veri\002ed 7 May 2008 Ant ant.apache.org Azureus azureus.sourceforge.net Hibernate www.hibernate.org JDT-Core www.eclipse.org/jdt/core JDT-UI www.eclipse.org/jdt/ui Spring springframework.org Xerces xerces.apache.org 
26 
26 
26 
26 
26 


