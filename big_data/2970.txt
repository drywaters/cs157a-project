Proceedings of the Seventh Internationa l Conference on Machine Learning and Cybernetics, Kunming, 12-15 July 2008  978-1-4244-2096-4/08/$25.00 ©2008 IEEE 3991  INCREMENTALLY FAST UPDATED SEQUENTIAL PATTERN TREES TZUNG-PEI HONG 1 HSIN-YI CHEN 2 CHUN-WEI LIN 3 SHENG-TUN LI 4  1 Department of Computer Science and Information Engineering National University of Kaohsiung, Kaohsiung, 811, Taiwan, R.O.C 2 Advanced Master Business Administration, National Cheng Kung University, Tainan, 701, Taiwan, R.O.C 
 3 Department of Computer Science and Information Engineering  National Cheng Kung University, Tainan, 701, Taiwan, R.O.C 4 Institute of Information Management, National Cheng Kung University, Tainan, 701, Taiwan, R.O.C E-MAIL: tphong@nuk.edu.tw, rd696404@mail.ncku.edu.tw p7895122@mail.ncku.edu.tw, stli@mail.ncku.edu.tw Abstract In the past, the FUFP-tree maintenance algorithm is proposed to efficiently handle the association rules in incremental mining. In this paper, we attempt to modify the FUFP-tree maintenance algorithm for maintaining sequential 
patterns based on the concept of pre-large sequences to reduce the need for rescanning original databases in incremental mining. A fast updated sequential pattern trees \(FUSP trees structure and the maintenance algorithm are proposed, which makes the tree update process become easier. It does not require rescanning original customer sequences until the accumulative amount of newl y added customer sequences exceed a safety bound, which depends on database size. The proposed approach thus becomes efficiently and effectively for handling newly added customer sequences Keywords Data mining; sequential pattern; FUSP tree; large 
sequence; pre-large sequence; incremental mining  1  Introduction Mining useful information and helpful knowledge from these large databases has thus evolved into an important research area [1  3   7 D e p e nd ing on  the classes of knowledge sought, mining approaches may be classified as finding associa tion rules, classification rules clustering rules, and sequential patterns, among others   Among them, finding sequential patterns in temporal transaction databases is important since it allows modeling of customer behavior [4  1 4   15  
Mining sequential patterns was first proposed by Agrawal et al in 1995 no n-triv ial task Although customer behavior models can be efficiently extracted by the mining algorithm in t o  assi st m a nager s  in making correct and effective decisions, the sequential patterns discovered may become invalid when new customer sequences occur. Developing efficient approaches to maintain sequential patterns is thus very important to real-world applications. Lin et al proposed the FASTUP algorithm [14 to  m a in tain seq u e n tial p a ttern s b y ex tend ing  the FUP algorithm r 
approach works well except when newly coming candidate sequences are not large in the original database. If this occurs frequently, the performance of the FA STUP algorithm will correspondingly decrease  Han et al thus proposed the Frequent-Pattern-tree FP-tree\ture for effici ently mining association rules without generation of candidate itemset  T h e F P t re e was used to compress a database into a tree structure which stored only large items. It was condensed and complete for finding all the frequent patterns. They showed the approach 
could have a better performance than the Apriori approach Cheng et al proposed the IncSpan \(Incremental mining of sequential pattern\m for efficiently mining sequential patterns from tree structure [8 It was  used to compress a database into a tree structure which stored not only the frequent sequences but also the semi-frequent sequences. However, the IncSpan algorithm consider only when newly added customer sequences which not applicable in the real-world  In the past, Hong et al modified the FP-tree structure and designed the fast updated frequent pattern trees 
FUFP-trees fici ently handle newly inserted transactions based on the FUP concept [3  The F U F P t ree  structure was similar to the FP tree structure except that the links between parent nodes and their child nodes were bi-directional. Besides, the counts of the sorted frequent items were also kept in the Header_Table of the FP-tree algorithm. Experimental results showed that the FUFP-tree maintenance algorithm could achieve a good performance for handling the new inserted transactions  Hong et al also proposed a novel and efficient 


Proceedings of the Seventh Internationa l Conference on Machine Learning and Cybernetics, Kunming, 12-15 July 2008 3992 incremental mining algorith m capable of updating sequential patterns based on the concept of pre-large sequences  1 1 1 2  A  p r e-l a r g e se que n ce i s n o t t r ul y large, but nearly large. A lower support threshold and an upper support threshold are used to realize this concept Since the database grows huge, the proposed algorithm becomes increasingly efficien t especially useful for real-world applications In this paper, we thus attempt to modify the FUFP-tree maintenance algorithm to make the updated efficiently based on pre-large concepts for sequential patterns. A fast updated sequential pattern trees \(FUSP tree\proposed which will make the tree update easier. It is extended from the FUFP-tree structure, simila rly to FP-tree structure. An incremental FUSP-tree maintenance algorithm is also proposed for processing newly added customer sequences The proposed algorithm does not require rescanning the original database to construct the FUSP tree until a number of new transactions have been processed 2  Review of Related Works 2.1  The FUP-tree algorithm The FUFP-tree construction algorithm i s base d on  the FP-tree algorithm h e links between parent nodes and their child nodes are, however, bi-directional Bi-directional linking will help fasten the process of item deletion in the maintenance process. Besides, the counts of the sorted frequent items are al so kept in the Header_Table An FUFP tree must be built in advance from the original database before new transactions come. When new transactions are added, the FUFP-tree maintenance algorithm will process them to maintain the FUFP tree. The entire FUFP tree can then be re constructed in a batch way when a sufficiently large number of transactions have been inserted 2.2 The prelarge sequences algorithm Maintaining sequential patterns is much harder than maintaining association rules since the former must consider both itemsets and sequences. The pre-large concept is used here to postpone original small sequences directly becoming large and vice-versa when new transactions are added. When new transactions are added to a database, they can be divided into two classes Class 1:new transactions by old customers already in the original database Class 2:new transactions by new customers not already in the original database Newly added transactions ar e first transformed into customer sequences, and those belonging to class 1 mentioned above are merged with corresponding customer sequences in the original data base. Considering an original customer sequences and newly merged customer sequences in terms of the two support thresholds, the nine cases illustrated in Figure 1 may occur Large Large Pre-large  Original database New transactions Small Small Case 1      Case 2      Case 3 Case 4      Case 5      Case 6 Case 7      Case 8      Case 9 Pre-large Large sequences Large Pre-large Original customer sequences Newly merged customer sequences Small Small Case 1      Case 2      Case 3 Case 4      Case 5      Case 6 Case 7      Case 8      Case 9 Pre-large sequences sequences sequences sequences sequences  Figure 1. Nine cases arising from adding new customer sequences to an existing database  Cases 1, 5, 6, 8 and 9 will not affect the final large sequences according to the weighted average of the counts Cases 2 and 3 may remove existing large sequences, and Cases 4 and 7 may add new large sequences. It has been formally shown that the sequences in Case 7 cannot possibly be large for the entire updated database as long as the number of customer sequen ces is small compared to the number of customer sequences in the original database. The formula is shown below t   u u u l u S qS S d S S     1 1   1 where t is the number of the newly added customer sequences, and q be the number of newly added customer sequences belonging to old customers S u is the upper threshold S l is the lower threshold, and d is the number of customer sequences in the original database 3  The proposed FUSP-tree maintenance algorithm In the past, Cheng et al proposed the IncSpan Incremental mining of sequential pattern\gorithm for efficiently mining sequential patte rns from tree structure  It was used to compress a database into a tree structure which stored not only the frequent sequences but also the semi-frequent sequences. The mined sequential patterns are constructed into tree stru cture by the features of SES   sequence-extended sequence d IES  itemset-extended sequence a sequence belongs to SES the connected nodes are marked as s otherwise, marked as i IncSpan algorithm does not deal the problem of newly added customer sequence which alread y existing in the original 


Proceedings of the Seventh Internationa l Conference on Machine Learning and Cybernetics, Kunming, 12-15 July 2008 3993 database In this paper, the FUSP tree is proposed to handle the sequential patterns in increm ental mining. The FUSP tree must be built in advanced from the initially original database before new customer sequences come. Its initial construction is similar to an FP tree [9 tree [13  The original customer sequences is first scanned to find the large 1-sequences and pre-la rge 1-sequences with their supports large than the predefined upper threshold S u  and the lower threshold S l Next, the large and pre-large sequences are sorted in descending order by their frequency to construct the Header_Table and Pre_Header_Table respectively. At last, the orig inal customer sequences are scanned again to construct the FUSP tree according to the sequences order in the original customer sequences. If an itemset is contained in a sequence, the itemset is sorted by their frequency in descending order from Header_Table and Pre_Header_Table. When the li nking between the nodes is the sequence-extended sequence  SES he linking is marked as s otherwise, when the linking between the nodes is the itemset-extended sequence  IES the linking is marked as i The construction process is executed tuply by tuply, from the first customer sequences to the last one After all customer sequences are processed, the FUSP tree is completely constructed  Besides, the index table is constructed by composing all 1-sequences in the origin al customer sequences. For each 1-seqeunces, there is a co rresponding list of customer IDs in which the 1-sequence is presented. The index table  helps to efficiently find the small 1-sequences in the original customer sequences when the rescanning the original customer sequences is needed. Two global variables c and b are used to accumulate, respectively, the number of newly added customer sequences and the number of newly added customer sequences belonging to old customers since the last re-scan of the original database The detail of the proposed algorithm is described below  The FUSP-tree maintenance algorithm INPUT: A set of large and pre-large sequences in the original database D consisting of d  c ustomer sequences, its corresponding Header_Table and Pre_Header_table which sorting the frequent 1-sequences and pre-large 1-sequences initially in descending order, its corresponding FUSP tree, a lower support threshold S l an upper support threshold S u the index table for all 1-sequences with their corresponding customer IDs from the original customer sequ ences, the accumulative amount b of new customer sequences belonging to old customers, and a set of t newly added customer sequences transformed from new transactions OUTPUT A new FUSP tree for the updated databases by using the FSUP-tree ma intenance algorithm STEP 1: Calculate the value of the first term in Formula 1 1 as  f   u l u S d S S   1    STEP 2: Merge the newly added customer sequences with the old sequences in the original database and count the value q which is the number of the newly added customer sequences belonging to old customers STEP 3: Set b  b  q and calculate the second term u u S bS  1  in Formula 1 as  h  u u S bS  1  where b is the accumulative amount of q since the last re-scan STEP 4: Scan the merged sequences to get all the 1-sequences and their counts STEP 5: Divide the sequences in the newly added customer sequences into three parts according to whether they are large, pre-large or small in the original customer sequences STEP 6 For each sequence I which is large in the original customer sequences, do the following substeps  Cases 1  2 and 3  Substep 6-1 Set the new count S U  I f I in the entire updated database as S U  I  S D  I  S T  I  where S D  I of I in the Header_Table \(original database and S T  I he count of I in the newly customer sequences Substep 6-2 If S U  I   d  c  t b   S u update the count of I in the Header_Table as S U  I and put I in the set of Insert_Seqs which will be further processed in STEP 10; Otherwise if S u   S U  I   d  c  t b   S l remove I from the Header_Table, put I in the head of Pre_Header_Table with its updated frequency S D  I and keep I in the set of Insert_Seqs  Otherwise, sequence I will become small after the database is updated remove I from the Header_Table and connect each parent node of I  directly to its child node in the FUSP tree 


Proceedings of the Seventh Internationa l Conference on Machine Learning and Cybernetics, Kunming, 12-15 July 2008 3994 STEP 7 For each sequence I which is pre-large in the original database, do the following substeps  Cases 4  5 and 6  Substep7-1: Set the new count S U I\f I in the entire updated database as S U  I  S D  I  S T  I  Substep 7-2 If S U  I   d  c  t b   S u sequence I  will be large after the database is updated; remove I from the Pre_Hedaer_Table, put I with its new frequency S D  I in the end of Header_Table, and put I in the set of Insert_Seqs Otherwise, if S u  S U I  d  c  t b   S l sequence I is still pre-large after the database is updated; update I with its new frequency S D  I the Pre_Header_Table and put I in the set of Insert_Seqs Otherwise remove item I from the Pre_Header_Table and connect each parent node of I directly to its child node in the FUSP tree STEP 8 For each sequence I which is neither large nor pre-large in the original database but large or pre-large in the new transactions Cases 7 and 8  put I in the set of Rescan_Seqs which is used when rescanning the original customer sequences in STEP 9 is necessary  STEP 9 If c  t   f  h or Rescan_Seqs is null then do nothing; Otherwise, do the following substeps for each sequence I in the set of Rescan_Seqs  Substep9-1: Rescan the original customer sequences to decide the original count S D  I f I  Substep 9-2: Set the new count S U  I f I in the entire updated database as  S U  I  S D  I  S T  I  Substep 9-3 If S U  I   d  c  t b   S u sequence I  will become large after the database is updated; put I in both the sets of Insert_Seqs and Branch_Seqs and insert the sequ ence in the Branch_Seqs to the end of the Header_Table according to the descending order of their updated counts; Otherwise, if S u  S U  I   d  c  t b   S l sequence I will become pre-large after the database is update; put I in both the sets of Insert_Seqs and Branch_Seqs and insert the sequences in the Branch_Seqs to the end of the Pre_Header_Table according to the descending order of their updated counts. Otherwise, do nothing Substep 9-4 For each original customer sequences with a sequence I existing in the Branch_Seqs  finding the corresponding sequences from the index table If I  has not been at the corresponding branch of the FUSP tree for the customer sequences, insert I at the end of the branch and set its count as 1; Otherwise, add 1 to the count of the node I  STEP 10: For each new customer sequences with a sequence I existing in the Insert_Seqs do the following substeps Substep 10-1: For the new customer sequences which already ex isting in the original database, If sequence I has not been at the corresponding branch of FUSP tree, insert I at the end of the branch and set its count as 1; Otherwise, add 1 to the count of the node I  Substep 10-2: For the new customer sequences which are new customer transactions, if I has not been at the corresponding branch of the FUSP tree for the new tran saction, insert I  at the end of the branch and set its count as 1; Otherwise, add 1 to the count of the node I  STEP 11: If c  t  f  h then set d  d  c  t  c 0 and b  0; otherwise, set c  c  t  In STEP 9, a corresponding branch is the branch generated from the large seque nces in the transaction and corresponding to the order of sequences in the databases After STEP 11, the final updated FUSP tree by using the maintenance algorithm is constr ucted. The new transactions can be integrated in to the original database. Based on FUSP tree, the desired large sequences for the updated database can be determined by using FP-growth mining approach as proposed in   4  An example In this section, an exampl e is given to illustrate the proposed incremental mining approach for sequential 


Proceedings of the Seventh Internationa l Conference on Machine Learning and Cybernetics, Kunming, 12-15 July 2008 3995 patterns based on FUSP tree. Table 1 shows a database to be used in the example. It contains 10 customer sequences and 9 items, denoted a to i The index table is also constructed in Table 2 after scanning the original customer sequences  Table 1. The customer sequences Cust_id Customer sequence 1 a   b  2 c  d   a   e  f  g  3 a  h  g  4 a   e  g   b  5 b   c  6 a   b  c  7 a   b  c  d  8 e  g  9 f   i  10 h  i   Table 2. The index table 1-seqeunces Corresponding customer IDs  a  1, 2, 3, 4, 6, 7  b  1, 4, 5, 6, 7  c  2, 5, 6, 7  d 7  e 4, 8  f 9  g  2, 3, 4, 8  h 10  i 10  Assume S l is set at 30% and S u is set at 50%. Here, not only the frequent 1-sequences ar e kept in the FUSP tree but also the pre-large 1-sequen ces. The FUSP tree is then formed from the database, the Header_Table and the Pre_Header_Table. The results are shown in Figure 2 root a:5 b:3 c:1 a:1 g:1 e:1 g:1 e:1 b:1 b:1 c:1 c:2 g:1 e:1 s s s sss s s i g:1 i s i i i s Null s Null s Null s Null s Null s Null s Header_Table Sequences Frequency Head a\>            6 b\>            5 Pre_Header_Table Sequences Frequency Head c\>          4 g 4 e \           3  Figure 2. The Header_Table, Pre_Header_Table and the FUSP tree constructed  Assume the three new cust omer sequences shown in Table 3 appear. The proposed FUSP tree maintenance algorithm proceeds as the following. The global variables c  and b are initially set at 0  Table 3. Three newly added customer sequences Cust_id Customer sequence 5 g  11 a   b   g   i  12 a   f  h   i   The value of the first term in Formula 1 is calculated as f  4 5  0 1 10  3  0 5  0  1         u l u S d S S   The three new sequences in Table 3 are merged with their corresponding old sequences in Table 1. Since only the customer sequence with Cust_id 5 in Table 3 belongs to old customers in Table 1 q is thus set as 1 b  b  q 0 + 1 1. The value of the second term in Form is calculated as h 1 5  0 1 5  0  1 1     u u S bS  The merged customer sequences first scanned to get the 1-sequences and their counts. The counts are actually the count increments due to insertion of newly customer sequences. After that, all the sequences a to i are divided into three parts, according to whether they are large appearing in Header_Table pre-large \(appearing in Pre_Header_Table\all in the original customer sequences. Each part is pro cessed according the proposed FUSP-tree maintenance algorith m. The final results after STEP 11 are shown in Figure 3 Note that the final value of c is 3, and b is 1 in this exampl e. The new value of b and c  will be used for processing next new custom er sequences Based on the FUSP tree shown in 3, the desired large sequences then be found by the FP-Growth mining approach as proposed in [1   root a:7 b:4 c:1 a:1 g:1 g:1 b:1 b:1 c:1 c:2 g:1 s s sss s s g:1 i s i s Null Null s Null s Null s Null s Null s Header_Table Sequences Frequency Head a\>            8 b\>            6 g\>            6 Pre_Header_Table Sequences Frequency Head c\          4 s g:1 s g:1 s Null s  Figure 3. The final FUSP tree 


Proceedings of the Seventh Internationa l Conference on Machine Learning and Cybernetics, Kunming, 12-15 July 2008 3996 5  Conclusions In this paper, we have proposed a novel FUSP-tree structure and maintenance al gorithm to efficiently and effectively handle newly added customer sequences in incremental mining. The cons truction of FUSP tree is extended from FUFP tree, whic h similarly to the FP tree When new customer sequences are added, the proposed incremental maintenance algo rithm processes them to maintain the FUSP tree. It fi rst partitions 1-sequences into nine parts according whether they are large, pre-large or small in the original customer sequences and in the newly added customer sequences. Each part is processed in its own way. The proposed approach can thus achieve a good trade-off between execution time and tree complexity  Acknowledgements This research was supporte d by the National Science Council of the Republic of China under contract NSC 96-2221-E-390-003 References 1  R. Agrawal, T. Imielinksi and A. Swami, “Mining association rules between sets of items in large database“, The ACM SIGMOD Conference, pp 207-216, Washington DC, USA, 1993 2  R. Agrawal, T. Imielinksi, and A. Swami, “Database mining: a performance perspective”, IEEE Transactions on Knowledge and Data Engineering Vol. 5, No. 6, pp. 914-925, 1993 3  R. Agrawal and R. Srikant Fast algorithm for mining association rules”, The Inte rnational Conference on Very Large Data Bases, pp. 487-499, 1994 4  R. Agrawal and R. Srik ant, ”Mining sequential patterns”, The Eleventh IEEE International Conference on Data Engineering, pp. 3-14, 1995 5  R. Agrawal, R. Srikan t, and Q. Vu, “Mining association rules with ite m constraints”, The Third International Conference on Knowledge Discovery in Databases and Data Mining, pp. 67-73, Newport Beach, California, 1997 6  M. S. Chen, J. Han, and P S. Yu, “Data mining: An overview from a database perspective”, IEEE Transactions on Knowledge and Data Engineering Vol. 8, No. 6, pp. 866-883, 1996 7  D. W. Cheung, J. Han, V. T. Ng, and C. Y. Wong Maintenance of discovered association rules in large databases: An incremental updating approach”, The Twelfth IEEE Internationa l Conference on Data Engineering, pp. 106-114, 1996 8  H. Cheng, X. Yan, and J. Han, “IncSpan: incremental mining of sequential patterns in large database”, The ACM SIGKDD international conference on Knowledge discovery and data mining, pp.527-532 2004 9  J. Han, J. Pei and Y. Yin, “Mining frequent patterns without candidate gene ration”, The 2000 ACM SIGMOD International Conference on Management of Data, pp. 1-12, 2000 1  T. P. Hong, C. Y. Wang, and Y. H. Tao, “Incremental data mining based on two support thresholds”, The Fourth International Conference on Knowledge-Based Intelligent Engineerin g Systems & Allied Technologies, 2000 1  T. P. Hong, C. Y. Wang and Y. H. Tao, “A new incremental data mining al gorithm usin g pre-large itemsets”, Intelligent Data Anal ysis, Vol. 5, No. 2, pp 111-129, 2001 1  T. P. Hong, C. Y. Wang, and S. S. Tseng Incremental data mining for sequential patterns using pre-large sequences”, The fifth world multi-conference on Systemics, Cybernetics and Informatics, 2001 1  T. P. Hong, C. W. Lin, a nd Y. L. Wu, “Incrementally fast updated frequent pattern trees”, Expert Systems with Applications , Vol. 34, Issue 5, pp. 2424-2435 2008 1  M. Y. Lin and S. Y. Lee, “Incremental update on sequential patterns in large databases”, The Tenth IEEE International Conference on Tools with Artificial Intelligence pp. 24-31, 1998 1  R. Srikant and R. Agra wal, “Mining sequential patterns: generalizations and performance improvements”, The Fifth International Conference on Knowledge Discovery and Data Mining \(KDD’95\, pp 269-274, 1995 


D j 222 38 
Return 
Figure 5 Algorithm for reassessing clusters composition for dynamic XML documents  6. Experimental results  To test our proposed method we used XML documents \(20kB and 50kB\xtracted from the   with an average number of levels of 4 Firstly, we clustered the documents to get the initial clusters composition \(Step 1 in framework in Section 3\, using minimum pair-wise distances; at this stage we also stored the distances between documents in the clustering solution together with the set of operations corresponding to each minimum distance. Then, in order to assess the efficiency of Step 2, we applied different percentages of changes to the documents in the clustered solution, in order to obtain new versions The purpose of the tests was to compare, after each set of changes, the time required to reassess the distance between documents using the same method as for the initial clustering \(i.e. full pair-wise comparison of the XML documents\ to the time of reassessing each distance using the method proposed in this paper and formulas in Definitions 5a, 5b and 5c  Figure 6 Test results for 50kB doc \(part 1  We show in Figures 6, 7, 8 and 9 some of the obtained results. They demonstrate clearly that our proposed technique to reassess the distances in dynamic XML clusters is much faster than performing a full pair-wise comparison on all new versions of the clustered documents. This can be explained by our technique: \(i\rforming only a minimum number of calculations and \(b\ reassessing distances only for those pairs of XML documents where at least one of them has changed Figure 8 Test results for 20kB doc \(part 1    Figure 9 Test results for 20kB doc \(part 2   Also, from Figures 6, 7, 8 and 9 it can be noticed that the difference between the full pair-wise and our proposed technique is more evident for higher number of documents modified or for higher percentages of changes applied                  V arious number of medium-sized documents \(50kB affected by 10% changes 0 20 40 60 80 100 51020 number of documents time\(second s    pair-w ise f ull comparison   proposed reassessing technique                50 small-sized documents \(20kB\ affected by various percentages of changes 0 50 100 150 10 20 50 percentage of change time\(second s    pair-w ise f ull comparison   proposed reassessing technique                  20 medium-sized documents \(50kB\ affected by various percentages of changes 0 50 100 150 3 5 10 25 percentage of change time\(second s    pair-w ise f ull comparison   proposed reassessing technique              V ar ious number of small documents \(20kB\ affected by 15% changes 0 10 20 30 40 50 60 51020 number of documents time\(second s    pair-w ise f ull comparison   proposed reassessing technique  
End if 
002 
37 prune edge D i 222 C\222={C 1 222,C 2 222,\205C n\222 222  ______________________________  
 Figure 7 Test results for 50kB doc \(part 2   
39 D i 222,D j 222 40 
 
Next 
455 
455 


 7. Conclusions  In this paper we have proposed an intelligent and efficient technique to reassess the distances between dynamic XML documents when one or all of the initially clustered documents have changed. After the changes, the initial clustering solution might become obsolete - the distances between clustered XML documents might have changed more or less depending on the degree of modifications \(insert update, delete\hich have been applied. Re-running full pair-wise comparisons on the entire set of modified documents is not a viable option, because of the large number of redundant operations involved Our proposed technique allows the user to reassess the pair-wise XML document distances, not by fully comparing each new pair of versions in the clustering solution, but by determining the effect of the temporal changes on the previously known distances between them. This approach is both time and I/O effective, as the number of operations involved in distance reassessing is greatly reduced  References  1  Beringer, J. and H\374llermeier, E., Online clustering of parallel data streams Data and Knowledge Engineering 58\(2\,  2006, 180-204 2  Catania, B. and Maddalena A., A Clustering Approach for XML Linked Documents, Proceedings of the 13th International Workshop on Database and Expert Systems Applications \(DEXA\22202\, IEEE 2002 3  Chen, M.S., Han, J. and Yu, P., Data Mining: An Overview from Database Perspective, IEEE Transactions on Knowledge and Data Engineering vol. 8, 1996, 866-883 4  Cormen, T., Leiserson, C. and Rivest, R Introduction to algorithms, MIT Press, 1990 5  Costa, G., Manco, G., Ortale, R. and Tagarelli, A., A tree-based Approach to Clustering XML documents by Structure, PAKDD 2004, LNAI 3202, 137-148 Springer 2004 6  Dalamagas, T., Cheng, T., Winkel, K.J. and Sellis, T 2004, Clustering XML documents by Structure SETN 2004, LNAI 3025, 112-121, Springer 2004 7  Ester, M., Kriegel, H.P., Sander, J., Wimmer,M. and Xu, X., Incremental Clustering for Mining in a Data Warehousing Environment, Proc.of the 24 th VLDB Conference, New York, USA, 1998 8  Garofalakis, M., Rastogi, R., Seshadri, S. And Shim K., Data Mining and the Web: Past, Present and Future Proceedings of WIDM 99 Kansas, US, ACM 1999 9  Mignet, L., Barbosa, D. and Veltri, P., The XML web : a first study, In Proceedings of the 12 th  International Conference on WWW, 500-510 2003   Nayak, R., Xu, S., XCLS: A Fast and Effective Clustering Algorithm for Heterogeneous XML Documents, In Proceedings of the 10 th Pacific-Asia Conference on Advances in Knowledge Discovery and Data Mining, Singapore, LNCS 3918, 2006   Rusu, L.I., Rahayu, W. and Taniar, D., A methodology for Building XML Data Warehouses International Journal of Data warehousing Mining, 1\(2 67-92, 2005   Rusu, L.I., Rahayu, W. and Taniar D.,  Maintaining Versions of Dynamic XML Documents, In Proceedings of the 6th International Conference on Web Information Systems Engineering, New York NY, USA, November 20-22, 2005, LNCS 3806   Rusu, L.I., Rahayu, W. and Taniar, D., Warehousing Dynamic XML Documents, In Proceedings of the 8 th  International Conference on Data Warehousing and Knowledge Discovery \(DaWaK 2006 LNCS 4081 Springer, 175-184, 2006   Shen, Y. and Wang, B., Clustering Schemaless XML documents, CoopIS / DOA/ODBASE 2003, LNCS 2888, 767-784, Springer 2003   Yoon, J. P., Raghavan, V., Chakilam, V., and Kerschberg, L., BitCube: A Three-Dimensional Bitmap Indexing for XML Documents J. Intel. Inf Syst 17, 2-3 \(Dec. 2001\, 241-254   XML data repository, online at http www.cs.washington.edu / research / projects / xmltk xmldata  
456 
456 


5 Related Work There exists extensive previous work on both the mining of software repositories and on the use of clustering algorithms in software engineering This discussion focuses on the most similar and recent work in the area of software evolution Mining Software Repositories Our technique was partially inspired by the work of Zimmermann et al and Y ing et al 17 on the mining of association rules in change history As described in Section 1 we sought to expand the technique to be able to recommend larger but less precise clusters of elements to guide program navigation Bouktif et al also investigated how to recommend cochanges in software development As opposed to the work cited above Bouktif et al used change patterns instead of association rules Also their approach does not attempt to reconstruct transactions and can consider associated 002les that were changed in different transactions ChangeDistiller is a tool to classify changes in a transaction into 002ne-grained operations e.g addition of a method declaration and determines how strongly the change impacts other source code entities Our approach uses similar repository analysis techniques but is focused on providing task-related information as opposed to an overall assessment of a system's evolution Finally repository mining can also be used to detect aspects in the code In this conte xt aspects are recurring sets of changed elements that exhibit a regular structure Aspects differ from the clusters we detect in the regular structure they exhibit which may not necessarily align with the code that is investigated as part of change tasks Clustering Analysis The classical application of clustering for reverse engineering involves grouping software entities based on an analysis of various relations between pairs of entities of a given version of the system Despite its long and rich history  e xperimentation with this approach continues to this day For example Andreopoulos et al combined static and dynamic information K uhn et al used a te xtual similarity measure as the clustering relation and Christl et al used clustering to assist iterative semi-automated reverse engineering The main dif ferences b e tween most clusteringbased reverse engineering techniques and the subject of our investigation is that the entities we cluster are transactions rather than software entities in a single version of a system For this reason our analysis is based strictly on the evolving parts of the system Both Kothari et al and V an ya et al 15 recently reported on their use of clustering to study the evolution of software systems The idea of using change clusters is the same in both works and ours but the purpose of the work is different Kothari et al use change clusters to uncover the types of changes that happened e.g feature addition maintenance etc during the history of a software system Vanya et al use change clusters which they call evolutionary clusters to guide the partitioning of a system that would increase the likelihood that the parts of the system would evolve independently In contrast we cluster transactions based on overlapping elements not 002les to recommend clusters to support program navigation as opposed to architectural-level assessment of the system Finally Hassan and Holt evaluated on 002ve open source systems the performance of several methods to indicate elements that should be modi\002ed together This study found that using historical co-change information as opposed to using simple static analysis or code layout offered the best results in terms of recall and precision The authors then tried to improve the results using 002ltering heuristics and found that keeping only the most frequently cochanged entities yielded the best results As opposed to our approach the evaluated 002ltering heuristics were only applied on entities recovered using association rules and not using clustering techniques The focus of their study was also more speci\002c as they recommend program elements that were strictly changed  as opposed to recommending elements that might be inspected by developers 6 Conclusion Developers often need to discover code that has been navigated in the past We investigated to what extent we can bene\002t from change clusters to guide program navigation We de\002ned change clusters as groups of elements that were part of transactions or change sets that had elements in common Our analysis of close to 12 years of software change data for a total of seven different open-source systems revealed that less than 12 of the changes we studied could have bene\002ted from change clusters We conclude that further efforts should thus focus on maximizing the quality of the match between the current task and past transactions rather than 002nding many potential matches Our study has already helped us in this goal by providing reliable evidence of the effectiveness of some 002ltering heuristics and useful insights for the development of additional heuristics Acknowledgments The authors thank Emily Hill and Jos  e Correa for their advice on the statistical tests and the anonymous reviewers for their helpful suggestions This work was supported by NSERC 
25 
25 
25 
25 
25 


References  B Andreopoulos A An V  Tzerpos and X W ang Multiple layer clustering of large software systems In Proc 12th Working Conf on Reverse Engineering  pages 79–88 2005  S Bouktif Y G Gu  eh  eneuc and G Antoniol Extracting change-patterns from cvs repositories In Proc 13th Working Conf on Reverse Engineering  pages 221–230 2006  S Breu and T  Zimmermann Mining aspects from v ersion history In Proc 21st IEEE/ACM Int'l Conf on Automated Software Engineering  pages 221–230 2006  A Christl R K oschk e and M.-A Store y  Equipping the re\003exion method with automated clustering In Proc 12th Working Conf on Reverse Engineering  pages 89–98 2005  D 020 Cubrani  c G C Murphy J Singer and K S Booth Hipikat A project memory for software development IEEE Transactions on Software Engineering  31\(6 465 2005  B Fluri and H C Gall Classifyi ng change types for qualifying change couplings In Proc 14th IEEE Int'l Conf on Program Comprehension  pages 35–45 2006  A E Hassan and R C Holt Replaying de v elopment history to assess the effectiveness of change propagation tools Empirical Software Engineering  11\(3 2006  D H Hutchens and V  R Basili System s tructure analysis Clustering with data bindings IEEE Transactions on Software Engineering  11\(8 1985  D Janzen and K De V older Na vig ating and querying code without getting lost In Proc 2nd Int'l Conf on AspectOriented Software Development  pages 178–187 2003  J K ot hari T  Denton A Shok ouf andeh S Mancoridis and A E Hassan Studying the evolution of software systems using change clusters In Proc 14th IEEE Int'l Conf on Program Comprehension  pages 46–55 2006  A K uhn S Ducasse and T  G  021rba Enriching reverse engineering with semantic clustering In Proc 12th Working Conf on Reverse Engineering  pages 133–142 2005  M P  Robillard T opology analysis of softw are dependencies ACM Transactions on Software Engineering and Methodology  2008 To appear  M P  Robillard and P  Mangg ala Reusing program in v estigation knowledge for code understanding In Proc 16th IEEE Int'l Conf on Program Comprehension  pages 202 211 2008  J Sillito G Murph y  and K De V older Questions programmers ask during software evolution tasks In Proc 14th ACM SIGSOFT Int'l Symposium on the Foundations of Software Engineering  pages 23–34 2006  A V an ya L Ho\003and S Klusener  P  v an de Laar and H van Vliet Assessing software archives with evolutionary clusters In Proc 16th IEEE Int'l Conf on Program Comprehension  pages 192–201 2008  N W ilde and M C Scully  Softw are reconnaissance Mapping program features to code Software Maintenance Research and Practice  7:49–62 1995  A T  Y ing G C Murph y  R Ng and M C Chu-Carroll Predicting source code changes by mining change history IEEE Transactions on Software Engineering  30\(9 586 2004  A Zeller  The future of programming en vironments Integration synergy and assistance In Proceedings of the 29th International Conference on Software Engineering The Future of Software Engineering  pages 316–325 2007  T  Zimmermann and P  W eißgerber  Preprocessing C VS data for 002ne-grained analysis In Proc 1st Int'l Workshop on Mining Software Repositories  pages 2–6 May 2004  T  Zimmermann P  W eißgerber  S Diehl and A Zeller  Mining version histories to guide software changes In Proc 26th ACM/IEEE Int'l Conf on Software Engineering  pages 563–572 2004 A Clustering Algorithm This algorithm is not sensitive to whether a given program element exists or not in a given version of a program For example if method m exists in one version it is considered a valid program element even if it is removed in a later version In the rest of this section we use the term program element to refer to the uniquely identifying representation of the element e.g a Java fully-quali\002ed name Let T be a transaction modeled as a set of program elements changed together during the history of a software system Let T be a sequence of transactions In this algorithm a cluster is also modeled as a set of elements 1 Input  T  A sequence of transactions 2 Parameter  M IN O VERLAP  A positive non-zero value indicating the minimum overlap between two transactions in a cluster 3 Var  C  A set of clusters initially empty 4 for all T i 2 T do 5 MaxOverlap  0 6 MaxIndex  000 1 7 for all C j 2 C do 8 if j C j  T i j  MaxOverlap then 9 MaxOverlap  j C j  T i j 10 MaxIndex  j 11 end if 12 end for 13 if MaxIndex   0  MaxOverlap 025 M IN O VERLAP  then 14 C MaxIndex   C MaxIndex  T i  15 else 16 NewCluster  T i 17 C  C  f NewCluster g 18 end if 19 end for 20 return C B Systems Analyzed System home pages last veri\002ed 7 May 2008 Ant ant.apache.org Azureus azureus.sourceforge.net Hibernate www.hibernate.org JDT-Core www.eclipse.org/jdt/core JDT-UI www.eclipse.org/jdt/ui Spring springframework.org Xerces xerces.apache.org 
26 
26 
26 
26 
26 


