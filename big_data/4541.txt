 978-1-4244-7330-4/10/$26.00  2010 IEEE 1594  A new algorithm for discovering association rules Kan Jin Dept. of Software Engineering, Jina n University, Guangzhou, P.R. China E-mail: Jinkan1988@qq.com   Abstract Efficiency is quite important for an algorithm to find frequent patterns from a large da tabase. A new algorithm called LogECLAT algorithm which is enlightened by ECLAT algorith m uses special candidates to find frequent patterns from a continually updating database containing e ssential information about frequent pattern s.  LogECLAT algorithm can find several k-itemsets in one time of scanning database and thus the times of establishing new databases is reduced. For Apriori algorithm is widely applied to many fields, the comparison of performance is between LogECLAT algorithm and Apriori algorithm. This paper 
proves that LogECLAT algorithm can find fre quent patterns correctly and performs bette r than Apriori algorithm theoretically an d practically. The good performance of LogECLAT algorithm indicates th at by using the special candidates can reduce the times of producing new database, and in this way effici ency of finding frequent patterns improves Key Words Data mining, association rules ECLAT algorithm, Apriori algorithm  I  I NTRODUCTION  Online shopping is quite popular nowadays, for the commodities sold online are usually cheaper than those sold by stores, and online markets also provide a wider variety of products for customers to choose from. Although shop keepers always provide customers with some detailed information about a product such as photos shot by cameras from most angles, it is 
still difficult for customers to make a decision on purchasing products. And the database of an online market is so huge that customers may lose patient in searching appropriate goods from thousands of similar products. So it is very important for a customer to get recommendations from other customers Traditionally goods which sell we ll in the recent quarter are recommended to customers. Such a recommendation does not always satisfy customers’ need exactly, for people who do the same kind of job or live in the same town always have a similar purchasing preference, and in this way a best sold product is not always the most suitable product to be recommended for a certain customer. Data mining can find the highest possibility product for a customer to purchase by making full use of the 
customer’s purchasing preference The first algorithm mining association rule was proposed by Agrawal, Imielinski, and Swami  1  in 1993. Apriori algorithm which is accepted as the funda mental algorithm of finding frequent patterns was presented by Agrawal and Srikant  2   Then Paul W.Purdom, Dirk Van Gucht and Dennis P.Groth  3   analyze the performance of Apriori algorithm by using mathematical and experimental method. ECLAT \(Equivalence CLASS Transformation\algorithm which is an algorithm derived from Apriori algorithm was developed by Zaki  4   Another frequent itemset mining method called FP-growth 
algorithm was raised as an alternative in contrast to the Apriori-based approach. FP-growth algorithm, a pattern-growth approach for mining frequent itemsets without candidate generation, was presented by Han, Pei, and Yin  5   Most algorithms raised in the field of association rule are enlightened by either Apriori algorithm or FP-growth algorithm LogECLAT algorithm proposed in this paper is enlightened by ECLAT algorithm and the algor ithm shares the similar theoretical base with Apriori algorithm ECLAT algorithm and its probl ems will be introduced in chapter 2. And in chapter 3 the correctness of LogECLAT algorithm will be proved, the implementation of the algorithm is 
presented, and the result of the comparison between Apriori algorithm and LogECLAT algorithm will also be revealed. And the final conclusion is drawn in chapter 4 II  E CLAT A LGORITHM A ND I TS D EFECTS  ECLAT algorithm uses candidates to explore frequent patterns from a continually updating database. ECLAT algorithm derives from Apriori algorithm, so both two algorithms share the same theoretical base a subset of a frequent pattern can be a frequent pattern. And the only difference between two algorithms is that Apriori scan the original database, while 
ECLAT algorithm scans a continually updating database and then updates the database The detailed procedure of ECLAT algorithm is as follows ECLAT algorithm employs an iterative approach known as level-wise search, where k-ite msets are used to explore k+1\temsets. Firstly, the set of frequent 1-itemsets is found by scanning the database to accumulate the count for each item and collecting those items which satisfy minimum support denoted 1 L And then update the database as following principle for every itemset in 1 L if an itemset can be found in a certain TID, then denote the TID to the itemset. Secondly, produce 
candidates from 1 L and then use candidates to search updated database to find 2 L And update the database according to 2 L Continue the procedure for 2 L to find 3 L until no more frequent patterns can be found. The detailed procedure of ECLAT algorithm is encoded as pseudocode in a book named Data Mining, Concepts and Techniques  6   


  1595 Although ECLAT algorithm solves the problem that Apriori algorithm has done too much unnecessary scanning, updating the database is also a huge project. In the worst situation updating the database consumes no less time than scanning the original database. However, updating the database in most time is not quite unnecessary, if a candidate is split in a proper manner. For example, to accumulate the count of 4-itemset {I1 I2, I4, I6}, ECLAT algorithm may count the number of TIDs which both exist in 3-itemsets {I1, I2, I4} and {I2, I4, I6 However, there is another way to determine whether 4-itemsets I1, I2, I4, I6} is a frequent patte rn. 4-itemset {I1, I2, I4, I6} can also be split in two 2-itemsets {I1, I2} and {I4, I6}. In this way it is not necessary to update database for 3-itemset. Although some TIDs can be excluded by updating the database of 3-itemset, updating a database always cost more time than avoiding unnecessary scanning. Therefore if proper split manner is used, the performance of finding frequent patterns can be improved III  L OGECLAT A LGORITHM  A  Theoretical support for LogECLAT algorithm In order to find frequent patterns ranging from 1 k L to k L 2  LogECLAT algorithm uses candidates selected from combinations which are produced by every two different itemsets in k L to scan database k D The following part is to explain why LogECLAT algorithm can find all the frequent patterns ranging from 1 k L to k L 2  To prove the fact that LogECLAT algorithm can find frequent patterns correctly, two statements as follows should be true The first fact is that the combinations used by LogECLAT algorithm to scan database can be one of i-itemset i L   k i k 2 1 For two itemsets are different and one itemset is composed of k items therefore in one itemset there are j k j 1 s which is different from the other itemset and the combination of two different k-itemsets is composed of i k i k 2 1 tems. And Frequent patterns have a property, that is if an itemset is a frequent pattern, its subset must be frequent patterns. In this way, this fact is well proved The second fact is that any combinations of items which are not produced by LogECLAT algorithm can not be frequent patterns For a combination of items which is not a frequent pattern, its subset can not be frequent patterns. Apparently, those unqualified combinations of items are the subset of combinations of items which are not frequent patterns, and none of frequent patterns will be missed From two facts above, it is easy to get the conclusion that LogECLAT algorithm can find all the frequent patterns correctly B  The implementation of LogECLAT algorithm The procedure to implement LogECLAT algorithm is as follows a\reate a new database denoted 1 D to store TIDs for each item in database of transactions denoted D. Scan database D, for every item in database D, records corresponding TID for the item to 1 D and increments the count for the item. Collect those items which satisfy minimum support, denoted 1 L and get rid of all the recordings of TIDs not related to item in 1 L from 1 D  b i D to get frequent patterns from 1 i L to i L 2  Combine every different two i-itemset i L and find which combinations should be used to scan database i D and denote those combinations as candidates. For a combination 3 I produced by two i-itemsets each denoted 1 I and 2 I  and 3 I is composed of n n n i 2 1 s only two requirements are met 3 I would be used to scan database i D The two requirements are if numbers are applied to stand for every item, then every item which belongs to the set of the smallest i n items in 1 I is smaller than any item in 2 I  and every item which belongs to the largest n i 2 items in 1 I can also be found in the set of the smallest n i 2 items in 2 I And in this way, redundant combinations can be avoided to scan database i D  c\Create a new database denoted i D 2 to hold TIDs for 2k-itemset. Scan database i D by using candidates which are produced by step \(b\set 3 I above is one of such combinations, then different actions should be done according to the number of items which compose 3 I If 3 I is made up of i 2 different items, records corresponding TIDs to i D 2 and accumulates the count of 3 I from i D If 3 I does not satisfy minimum support, eliminate all the recordings of 3 I  in i D 2 While if 3 I is made up of j n j i 2 1 s, just accumulates the count of 3 I And for every candidate which satisfies minimum support, add the combination to corresponding frequent patterns which are made up of the same number of items with the candidate, thus frequent patterns from 1 i L to i L 2 are found d\sets in i L 2 that means all frequent patterns have found, so terminate the algorithm. Or back to do step b and c recursively, until the requirement of terminating the algorithm in step d is met 


  1596 C  Pseudocode of LogECLAT algorithm Input D, a database of transactions Min_sup, the minimum support count threshold Output: L, frequent itemsets in D Method Allocate memory for database 1 D  1 L find_frequent_1-itemsets \(D 1 D Recording_of_TID 1 L D  i=1; //i denoted to be the times of scanning database While i L   i L I 1  i L I 2  2 1 3 I I item I  Length=number_of_item 3 I  Scan_flag=continue_to_scan 1 I  2 I length,i If \(Scan_flag  If \(Length=2*i  i D 2 Recording_of_TID 3 I  i D  If  sup _ _ _    3 Min ns transactio of number D I count i  i L 2  3 I  Else i D 2 Recording_of_TID 3 I  i D   Else If sup _ _ _    3 Min ns transactio of number D I count i  length L  3 I   i=i*2   Program continue_to_scan For \(j=0; j<length-i; ++j If  0    2 1 I j I  For \(k=0; k<i-j; ++k If     2 1 k I j k I  Return true D  Example of LogECLAT algorithm TID is denoted to be the serial number of transactions. There are four transactions and they are denoted T100, T200, T300 and T400.ITEM is the name of commodities. Seven items which are A, B, C, D, E, F and H exist in the database. And the value of min_sup \(minimum support is 0.75, so only if an itemset appears at least three times in the database D \(table  minimum support is satisfied T ABLE  D ATABASE D TID ITEM T100 A,B,D,F,H T200 A,C,D,E,F T300 B,D,E,F,H T400 B,D,E,F In the first time of scanning database D, LogECLAT algorithm collects the count of items \(table ng recordings for every item in database D to a new database 1 D  T ABLE  C OUNT F OR E ACH I TEM  ITEM count A 2 B 3 C 1 D 4 E 3 F 4 H 2 Compare the count of each item \(table with minimum support, and1-itemset 1 L table s produced. According to the item in 1 L database 1 D removes unnecessary recordings and in this way database 1 D is formed \(table  T ABLE  R ESULT O F T HE F IRST S CAN  1 L  count B 3 D 4 E 3 F 4 T ABLE  N EW D ATABASE 1 D  ITEM recording B T100,T300,T400 D T100,T200,T300,T400 E T200,T300,T400 F T100,T200,T300,T400 Before the second time of scanning database, LogECLAT algorithm uses a program to se lect which combination \(table  should be used to scan database 1 D  T ABLE P RODUCING T HE C OMBINATION  1 I  2 I  3 I  B D BD 


  1597 B E BE B F BF D E DE D F DF E F EF LogECLAT algorithm gets 2-itemset 2 L table using candidates to scan database 1 D And all the recordings of itemsets which belong to 2 L add to a new database 2 D table  T ABLE  R ESULT O F T HE S ECOND S CAN  2 L  count BD 3 BF 3 DE 3 DF 4 EF 3 T ABL  N EW D ATABASE 2 D  itemset recording BD T100,T300,T400 BF T100,T300,T400 DE T200,T300,T400 DF T100,T200,T300,T400 EF T200,T300,T400 Before the third time of scanning database, LogECLAT algorithm uses a program to se lect which combination \(table  should be used to scan database 2 D  T ABLE  P RODUCING T HE C OMBINATION  1 I  2 I  3 I  BD DE BDE BD DF BDF BD EF BDEF DE EF DEF LogECLAT algorithm gets 3-itemset 3 L and 4-itemset 4 L table using candidates to scan database 2 D For 4 L is NULL no recording should be added to database 3 D so there are no recording in database 3 D LogECLAT algorithm also should be terminated for there is no itemset in 4 L In this way, all the frequent patterns are found T ABLE R ESULT O F T HE T HIRD S CAN  3 L  count 4 L  count BDF 3   DEF 3   E  Comparison between LogECLAT algorithm and Apriori algorithm Although LogECLAT algorithm is enlightened by ECLAT algorithm, Apriori algorithm is more commonly used by software to mine associations So comparing the efficiency of LogECLAT algorithm with Apriori algorithm is more meaningful than compari ng with ECLAT algorithm Apriori algorithm uses candidates 1 k C which is produced by k-itemset k L to explore \(k+1\temsets 1 k L from database while LogECLAT algorithm uses combinations produced by two k-itemsets k L to find frequent patterns ranging from k+1\set 1 k L to 2k-itemset k L 2 by scanning a continually updated database. In the real envi ronment, database is usually very large, so the comparison of two algorithms is performed on a large database environment A large database means that th ere are a lot of items in one transaction and the number of transactions is huge. For the average number of items in one transaction is large, it is quite possible to produce an itemset which is composed of a lot of items. A 10-itemset means to produce almost 10 2 frequent patterns, so the database of frequent patterns is also composed of large number of data The comparison of two algorithms focused on the procedure of scanning two databases \(the da tabase of transactions, the database of frequent patterns other databases directly related to the two databases such as the database of candidates, for those procedure consumes most time for the algorithm. And the principles of the comparison are as follows a\e consumption of two algorithms is not known, when it is sure that the increase of time consumption for A algorithm is less than B algorithm’s, A algorithm is more efficient than B algorithm b\Different kind of actions done to the same size of memory space one time consumes the equal time for a computer, and denotes the time as one unit time c\To simplify the procedure of comparing LogECLAT algorithm with Apriori algorithm, assume that all the candidates in Apriori algorithm is composed of the same number of itemsets and equal number of frequent patterns exist in every two different i-itemset i L  d\The comparison between LogECLAT algorithm and Apriori algorithm chooses one section wh ich is usually happened in LogECLAT, that is frequent patterns exist in 2k-itemset k L 2 That means Apriori algorithm should be used k times of scanning database to reach the effect of one time of scanning database for LogECLAT algorithm Symbols used to compare the time consumption between Apriori algorithm and LogECLAT algorithm are listed as follows   k L Num the number of itemsets in k L  


  1598                   k C Num the number of itemsets in k C    n transactio Num the number of transactions in the database Min_sup the minimum support of itemsets to be frequent patterns a positive number and its concrete number is unknown In one time of scanning database for Apriori algorithm, the combinations of every two different itemset in k-itemset k L is used to produce candidates 1 k C thus consumes        2 1 1 k k L Num C Num k   1   time unit. And then Apriori algorithm uses candidates 1 k C to scan database consuming       2 1 1 1 n transactio Num C Num k k 2 time unit. However, Apriori algorithm should find frequent patterns ranging from 1 k L to k L 2 so all the time consumption above for Apriori algorithm should be multiplied by k While LogECLAT algorithm selects candidates from combinations which are combin ed by every two different k-itemsets k L and it consumes  1     2    2 1 k k L num L Num k 3 time unit. And then LogECLAT algorithm uses those candidates to scan database k D to get frequent patterns Candidates in LogECLAT are composed of three parts: all the candidates ranging from 1 k C to k C 2 in Apriori algorithm combinations mistakenly produced by the way of selecting candidates in LogECLAT algorithm and combinations falsely caused for lacking of enough information of other frequent patterns. Combination 3 I is combined by two k-itemsets each denoted 1 I and 2 I and combination 3 I is composed of i different items. In the situation, the possibility that combination 3 I can not be a frequent pattern and combination 3 I is produced by using the method to select candidates in LogECLAT algorithm to scan database is i i A 1  The possibility that combination 3 I can be a frequent pattern according to k-itemset k L and combination 3 I can not be a frequent pattern according to \(i-1\set 1 i L  k i 1  decided according the concrete va lue in the database. So time consumption of scanning database is    2 sup _ 3       1 n transactio Num Min C Num k k 4 Situation 1: increasing the database of transactions. Compare \(2 in Apriori algorithm with \(4\ LogECLAT algorithm, if the value of Min_sup is less than 0.67, then LogECLAT algorithm performs better than Apriori al gorithm. And for such a large value of Min_sup, it is quite impossible for common database to produce a large database of candidates. So the value of Min_sup is much smaller than 0.67, and the time consumption of LogECLAT algorithm goes up slower than that of Apriori algorithm when the database of transaction increases Situation 2: increasing the database of frequent patterns. \(1 Apriori algorithm is certainly lager than \(2\ LogECLAT algorithm. So Apriori consumes more time than LogECLAT algorithm when the database of frequent patterns increases So the performance of LogECLAT algorithm is indeed better than Apriori algorithm in a large database environment F  Comparisons in real environment Experiments are undertaken to test the performance of LogECLAT algorithm under the environment of diversity number of transactions and support threshold All the experiments are performed on a AMD Athlon 64*2 Dual core processor 3800+ PC machine with 1G main memory running on Microsoft Windows XP. All the programs are written in Microsoft Visual C++6.0. Experimental data is generated by software which pr oduces random data to simulate the database existing in the real environment, and in this way the experiment can well reflects the performance commonly happened in all kinds of database. One databa se is generated to test the performance of Apriori algorithm, FP-growth algorithm and LogECLAT algorithm, and the number of items which compose the database is 39 The first experiment is done under the environment that the count of transactions is different but with the same support Figure Relationship Of The Number Of Transactions With Time Consumption threshold 20% \(show in Figure Figure it is easy to get the conclusion that although the performance of LogECLAT algorithm is affected by the number of transactions, but the influence from the number of transaction is not seriously in comparison with Apriori algorithm and FP-tree algorithm 


  1599 Another experiment tests how tim e consumption is influenced by different support thresholds \(Figure  number of transaction is 500. According to Figure  LogECLAT algorithm performs well in aspect of time consumption and is not easily influenced by the change of support threshold            F IGURE  R ELATIONSHIP O F S UPPORT T HRESHOLD W ITH T IME C ONSUMPTION  IV  C ONCLUSION  LogECLAT algorithm combines ECLAT algorithm and a method that uses special candidates to find frequent patterns from database. In this way, LogECLAT algorithm can extract necessary information from the database with fewer times of creating a new database. LogECLAT  algorithm also performs well with the change of number of transactions and support thresholds in experiment. So LogECLAT can find frequent patterns efficiently from a large database R EFERENCES  1  R. Agrawal, T. Imielinski, A. Swam i, Mining association rules between sets of items in large databases, In Proc. 1993 ACM-SIGMOD Int. Conf Management of Data \(SIGMOD’93\, pp. 207–216, 1993 2  R. Agrawal, R. Srikant, Fast algorith ms for mining association rules, In Proc. 1994 Int. Conf. Very Large Data Bases \(VLDB’94\, pp. 487–499 1994 3  Paul W.Purdom, Dirk Van Gucht, Dennis P.Groth, Average Case Performance of the Apriori Algorithm, SIAM journal on computing, Vol.33, No. 5, pp. 1223-1260, 2004 4  M. J. Zaki, Scalable algorithms for association mining, IEEE Trans Knowledge and Data Engin eering. 12, pp. 372–390, 2000 5  J. Han, J. Pei, B. Mortazavi-Asl Q. Chen, U. Dayal, and M.-C. Hsu FreeSpan: Frequent pattern-projected sequential pattern mining, In Proc 2000 ACM SIGKDD Int. Conf. Knowledge Discovery in Databases KDD’00 355–359, 2000 6  Z.Liu, Analysis Optimization and Application on the Algorithms of Mining Association Rules, Shuzhou, 2007 7  J.Han, M.Kamber: Data Mining, Concepts and Techniques \(Second Edition\, University of Illinois at Urbana-Champaign, 2006 8  J.Han, H.Cheng, D.Xin X.Yan, Frequent pattern mining: current status and future directions, Springer Scie nce+Business Media, LLC, Data Min Knowl Disc \(2007\,  Vol. 15, pp.55–86, Springer, Urbana , 2007    


Capacity for analysis and synthesisŽ, Research skills Capacity to learn 4   Interpersonal skills LeadershipŽ, Interpersonal skillsŽ, Ability to communicate with non-expertsŽ, Oral and written communications in native languageŽ, Critical and self-critical capabilityŽ, Teamworking 5   Personal skills Ability to work autonomously Problem solvingŽ, Capacity to adapt to new situations Knowledge of a second languageŽ, Concern for qualityŽ, Will to succeedŽ, Elementary computing skillsŽ, Capacity for applying knowledge in practice Decision makingŽ, Project design and management Information management skills Table 7 shows the mean importance of each gr oup of competences by stakeholder group for the First Cycle Degree respondents. For the employers the personal skills are the most importance group followed by professional skills and interpersonal skills. The table confirms that employers rank internationalisation and entrepreneurship lowest. Academics agree with the order of the competence groups but rate all of them more strongly important than employers. Students also rank the competence groups in the same order but rate internationalisation slightly higher than employers and entrepreneurship very slightly lower Analysis of the level of development of the competenceas shows that there is good agreement that Professional skills are the best developed of the skill groups followed by Personal skills and Interpersonal skills. As with importance the Entrepreneurship and Internationalisation skill groups are developed the least. There is clearly a difference between the rated importance and level of development of these groups in that the Personal skills group is rated most important but the Professional skills group is developed the most. Other than that the general structure of the supply demand balance of the generic competences is quite well aligned V  CONCLUSIONS AND RECOMMENDATIONS  The objective of this study was to apply the Tuning Methodology to the EIE discipline set to test the alignment between the views of the importance and level of development of sets of competences between students, academics and employers. The results of this study show that the Tuning Methodology is a useful tool for assessing alignment in these subjects  TABLE VII  MEAN IMPORTANCE OF EACH GROUP BY STAKEHOLDER  Competence Group Academic Employer Student Internationalization 2.86 2.63 2.79 Entrepreneurship 3.07 3.05 3.02 Interpersonal skills 3.23 3.09 3.06 Professional skills 3.36 3.29 3.13 Personal skills 3.44 3.30 3.29  In total 3,275 questionnaires have been collected from the stakeholder groups from a range of European countries. The number of responses from each c ountry is variable and a full by country analysis is not possible with the responses currently available, that said a range of analyses have been carried out Tests of the homogeneity of the responses across all countries show that there are country differences in some analyses and some of these are explored, others merit further investigation. Many of the analyses presented in this paper are aggregated results and therefore potentially suffer clustering problems. This too is a topic of further investigation The following is a summary of the key conclusions drawn from the analyses presented Consistent top of importance of the generic competences for all stakeholders is Problem solvingŽ. Second in the ranking for students is Elementary computing skillsŽ. Comparatively students under rate the importance of this skill, perhaps it is taken for granted in students than in academics and employers The results show employers value it more than students and this message could be communicated to students A number of gaps exist between the importance and level of development between the stakeholders. The largest gap is Knowledge of a second languageŽ and the evidence from the languages section suggests this view is strongly aimed at English The generic competences group into 5 sets with Personal skillsŽ rated consistently as the most important set. This is followed, in descending order of importance, by Professional skillsŽ, Interpersonal skillsŽ, InternationalisationŽ and EntrepreneurshipŽ. The smallest mean Internationalisation is just over midway between weakŽ and considerableŽ. Given the European Unions desire to see greater student and employee mobility across Europe, it is clear there is scope for scope for improvement in the value placed in this skill set by curriculum designers Curriculum designers and academics can take comfort in the finding that Professional skillsŽ are the best developed of the skill gr oups followed by Personal sk illsŽ and Interpersonal skillsŽ. This not only aligns with the views of employers but aligns with anecdotal evidence on the real purpose of EIE education programmes. That said there is a trend in a number of countries across Europe away from large firm employment towards a Small to Medium Sized Enterprise culture. Curriculum designers may wish to reflect on the fact that entrepreneurial skills are very low in the list and perhaps merit more attention and emphasis in the curricula In general the different stakeholders rate the importance and level of development on average differently. This difference has been taken into account in the conclusions drawn. The general unevenness in ranking reflects different perspectives and is, in itself not considered a major issue, of concern are the relative positions of competences and the relative gaps. In general and even allowing for this employers and academics tend to rate competences higher in importance than students and graduates a number of specific instances of differences are drawn out in section 8 73 


After the text edit has been completed, the paper is ready for the template. Duplicate the template file by using the Save As command, and use the naming convention prescribed by your conference for the name of your paper. In this newly created file, highlight all of the contents and import your prepared text file. You are now ready to style your paper; use the scroll down window on the left of the MS Word Formatting toolbar A CKNOWLEDGMENT  The authors acknowledge the funding provided by the European Union for this project and to the members of the project team for help in collecting questionnaires R EFERENCES   1  European Association for Education in Electrical and Information Enginering http://www.eaeeie.org  2  EIE-Surveyor project http://www.eie-surveyor.org  3  Tuning Report http://tuning.unideusto.org/tuningeu/index.php?option=content&task=vi ew&id=172&Itemid=205  4  Overview of the Bologna Process … Implementation in Europe in Electrical and Informaiton EngineetringŽ, ISBN 2-9516740-3-1, pp 542  74 


              


   


                        





