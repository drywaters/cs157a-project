TCP-to-SCTP Translation using Dynamic Rules-table Jiemin Liu Department of Electronic Information Northeastern University at QinHuangDao QinHuangDao, China Liujm@mail.neuq.edu.cn  Yuchun Ma\(Corresponding Author Hainan Key Laboratory of Embedded Systems QiongZhou University SanYa, China walker_ma@163.com    Abstract\227 Using the application of bulk data transfer, we investigate the performance of existing TCP-to-SCTP Translation shim scheme under the scenario of shim rules-table is static \(i.e., manual\e find that a potential problem named stale shim rules-table value 
caused by shim rules-table static configuration, which induces TCP-to-SCTP Translation does not startup in time. Based on this, we present a suggestion called Dynamic Rules-Table \(DRT\r TCP-to-SCTP Translation to implement the real-time startup and to improve the throughput of SCTP association. A demonstrate using simulation is provided showing how application performance in terms of responsiveness and throughput using the shim and SCTP is equivalent to or better than performance when application operate using TCP-toSCTP translation shim as originally designed Keywords-TCP-to-SCTP Translation; shim rules-table 
Dynamic Rules-Table \(DRT I  I NTRODUCTION  SCTP [1 i s  a co nne ct i o n-o r i e nt e d  r e l i a b l e   m e ssa ge d ba sed general purpose transport protocol with congestion control similar to that used by TCP, supporting advanced features unavailable such as fault tolerance [1 d co n c u r ren t  m u ltip a t h  transfer \(CMT\ [2  in TC P o r UD P   By now, the motivation for TCP-to-SCTP Translation design and implementation of shim layer, including the general approach taken, the functionality of the major components, the implementation details and the experimental evaluation performed on the shim and the results have been first described 
in [3  Our research focuses on the policy selection of shim rulestable configuration for transparent TCP-to-SCTP translation Our goal is to find a new scheme of shim rules-table configuration to further improve the performance of TCP-toSCTP translation by modify original scheme of TCP-to-SCTP translation. This paper introduces a transparent TCP-to-SCTP translation using Dynamic Rules-Table \(DRT\ to prevent the potential problem named stale shim rules-table value and to avoid  that TCP-to-SCTP translation does not startup in time caused by stale refresh to rules-table The rest of the paper is organized as follows. Section II 
describes current scheme of transparent TCP-to-SCTP translation shim layer, emphasize on the disadvantage of shim rules-table static configuration scheme, and then presents Dynamic Rules-Table \(DRT\cheme. And a series of simulations and results are discussed in Section III. We conclude the paper with future work in Section IV II  D YNAMIC R ULES T ABLE DRT A  Problem Description Figure 1 illustrates the relationship between a normal TCP socket and its hidden SCTP socket, as well as the corresponding protocol switch structures    
  
 Figure 1  Normal TCP socket with hidden SCTP socket The basic building block of the shim control system is a rule object, consisting of an IP address, a subnet mask and two port numbers Previously, the shim rules-table is only refreashed using manual, the original command list of shim rules-table is illustrated in the following table TABLE I   C OMMAND L IST FOR 
S HIM R ULES TABLE  command list Usage:shimrules-[AD c  c ha in  p  poli c y   r u le s p ec i f i c at i o n   shimrules-L[-c<chain p<policy  shimrules-[F  shimrules-G-c<chain shimrules-S-c<chain>-p<policy Commands A Add rule D Delete rule L List rules F Flush all rules G Get default policy S Set default policy H Show usage information 978-1-4244-3709-2/10/$25.00 \2512010 IEEE 


Table I shows shim rules-table is only configured ordinarily which induces blindness for an association of TCP-to-SCTP translation shim layer For example, here we assume remote-enable is {IP address 10.1.2.0/24, Port 21} in shim rules-table, the shim layer attempt to startup TCP-to-SCTP translation when application call remote IP address 10.1.2.20, if remote server does not support SCTP \(i.e., support TCP only in the best case i.e., minimum RTO = 1s, PMR = 5  it will take at least \(1 + 2 + 4 + 8 + 16 32\ = 63s to detect failure In the worst case i.e., maximum RTO = 1s, PMR = 5\, failure detection requires 6*60 = 360s B  Update Command List and Modify Shim-rule Structure In FreeBSD, most tunable operating system parameters are implemented as sysctls. The sysctl interface allows an administrator to configure the system’s kernel variables dynamically [4 S i n c e n e t w or k pr ot oc ol s t y pi ca l l y h a v e a l a rg e  number of tunable parameters, the sysctl interface facilitates adjusting system properties without requiring editing of source code and kernel recompilation. We use sysctls for many of the shim’s dynamic configuration variables As table II shows, in our design, two new commands such as C Auto configuration and B forbidden Auto Dynamic Configuration are added, and two new correspond socket options such as SO_SHIM_RULE_AUTO_EN and SO_SHIM_RULE_AUTO_DIS are also added as table III shows TABLE II  C OMMAND L IST FOR S HIM R ULES TABLE WITH A DDED C OMMAND C AND C OMMAND B command list   C Auto configuration B forbidden Auto Dynamic Configuration TABLE III  A DDED S OCKET O PTIONS  Socket selection                               System call             Function    SO_SHIM_RULE_AUTO_EN  setsockopt sosetopt SO_SHIM_RULE_AUTO_DIS      setsockopt  setsockopt  SO_SHIM_RULE_AUTO_EN indicates startup auto configuration process, and SO_SHIM_RULE_AUTO_DIS  shows dis-startup auto configuration process.   After C Auto configuration is configured by shimrules tool  in the kernel will add a flag of SO_SHIM_RULE_AUTO_EN in the header of shimrules_config_queue, then this flag will notifiy shimrules_auto_config, so   stores inquired shim rules content in the queue. The queue stuucture of shimrules_config_queue is illustrated  in Figure 3 Here, original shim_rule structure is modified by us, four fields shcu as date, date_call_times, fail_times and call_time  are added Date field indicates shim_rule is refeshed currently date_call_times field shows call count today fail_times  indicates failure count today, it shows some rules will be deleted from shim_rule and add to remote_disable  when   Figure 2  Queue structure for Shimrules_config_queue C  Implementation of TCP-to-SCTP translation using DRT  Figure 3  A typical Client / Server Connection  for SRDC operation III  P ERFORMANCE A NALYSIS AND E VALUATIONS  A  Simulation Setup For our experiments, we measure the total time required to transfer files of various sizes using the SSH suite’s SCP tool when running over a normal TCP connection and when running over the shim using an SCTP association. We compare the transfer times for TCP and the existing shim rules-table scheme at a variety of loss rates Each experiment required three nodes: a server machine running the SSH/SCP service, an SCP client, and an intermediate node running Dummynet  t o si m u l a t e  bandwidth, propagation delay, and loss rate configurations. The 


intermediate Dummynet router node was configured with a tail-drop queue of 50 packets and performed uniform random loss at the rates described above. Each node was a Pentium 4 system running FreeBSD 4.10 with a KAME kernel supporting SCTP. The SCTP version used was patch level 25, released in February 2005. To prevent the experiments with the shim from naturally taking advantage of the ability of SCTP multihoming and using other paths not part of the simulation topology, we disabled all interfaces besides the ones attached to the Dummynet-simulated network on the client and server systems before beginning the experiments. Disabling the alternate interfaces allowed for a fair comparison between TCP and the shim because SCTP was restricted to the simulated network and was unable to use any alternate paths between the client and server nodes Each run of the experiment involved measuring the total time required to issue the SCP command to retrieve a single file on the client system, and then transfer the entire file from the server, including the SSH key exchange overhead. We used a public-key authentication configuration rather than passwords with SSH to allow the experiments to be run in a noninteractive batch mode. Every combination of file size and loss rate was run with the 1.5 Mbps/35 ms bandwidth-delay configuration a total of 30 times, except the 50K file experiments which were run 90 times per loss rate due to higher variance in the transfer times. Thus, each data point in the graphs shown in Section III-B is the average of 30 \(or 90 runs of the same file size/loss rate configuration B  Experimental Results Figures 4, 5, 6, and 7 display our recorded transfer times for each simulated loss rate for 50 KB, 500 KB, 5 MB, and 25 MB files, respectively. In situations where SCTP is available on both peer endpoints, the shim adds no significant communications overhead beyond the inherent differences in the transport layer protocols being used or substituted. The case where SCTP is unavailable on the remote system can be a source of overhead during the connection establishment process because at least one additional RTT is required to 50 KB Transfer: 1.5 Mbps/35 ms 000\023 000\025 000\027 000\031 000\033 000\024\000\023 000\024\000\025 000\024\000\027 000\024\000\031 000\023\000\010 000\025\000\010 000\027\000\010 000\031\000\010 000\033\000\010 000\024\000\023\000\010 Loss Rate File Transfer time \(sec  TCP Shim/SCTP DRT  Figure 4  Transfer Time vs. Loss Rate for 50 KB file transfer over 1.5 Mbps/35 ms delay link in different polices 500 KB Transfer: 1.5 Mbps/35 ms 000\023 000\024\000\023 000\025\000\023 000\026\000\023 000\027\000\023 000\030\000\023 000\031\000\023 000\032\000\023 000\033\000\023 000\023\000\010 000\025\000\010 000\027\000\010 000\031\000\010 000\033\000\010 000\024\000\023\000\010 Loss Rate File Transfer time \(sec  TCP Shim/SCTP DRT  Figure 5  Transfer Time vs. Loss Rate for 500 KB file transfer over 1.5 Mbps/35 ms delay link in different polices 5 MB Transfer: 1.5 Mbps/35 ms 000\023 000\024\000\023\000\023 000\025\000\023\000\023 000\026\000\023\000\023 000\027\000\023\000\023 000\030\000\023\000\023 000\031\000\023\000\023 000\032\000\023\000\023 000\023\000\010 000\025\000\010 000\027\000\010 000\031\000\010 000\033\000\010 000\024\000\023\000\010 Loss Rate File Transfer time \(sec  TCP Shim/SCTP DRT  Figure 6  Transfer Time vs. Loss Rate for 5 MB file transfer over 1.5 Mbps/35 ms delay link in different polices 25 MB Transfer: 1.5 Mbps/35 ms 000\023 000\030\000\023\000\023 000\024\000\023\000\023\000\023 000\024\000\030\000\023\000\023 000\025\000\023\000\023\000\023 000\025\000\030\000\023\000\023 000\026\000\023\000\023\000\023 000\026\000\030\000\023\000\023 000\023\000\010 000\025\000\010 000\027\000\010 000\031\000\010 000\033\000\010 000\024\000\023\000\010 Loss Rate File Transfer time \(sec  TCP Shim/SCTP DRT  Figure 7  Transfer Time vs. Loss Rate for 25 MB file transfer over 1.5 Mbps/35 ms delay link in different polices 


detect that SCTP is unavailable before reverting to TCP and starting data transfer. However, because the nodes in our experiment support SCTP and both the SSH/SCP client and server have the shim enabled, no additional overhead is introduced by using the shim. The differences in transfer times are entirely due to the specific features and implementations of the underlying transport protocols, not the translation process The graphs yield two main observations about application throughput over a TCP connection versus the shim with an SCTP association. First, in situations without any networkinduced loss, TCP and the shim perform with different rulestable policy such as existing and we support approximately equivalently. Although not visible in the graphs, TCP had a slight edge with average transfer times between 4 and 240 ms faster than the shim at 0 percent loss across all four file sizes tested. This difference is likely a result of SCTP’s more complex four-way association establishment handshake compared to TCP’s three-way handshake, and SCTP’s more expensive CRC32 checksum. The second observation is that for all runs with loss rates greater than 1 percent, the shim running over SCTP outperforms TCP by an increasing margin as loss rates increase. The trend of the shim providing better application throughput at all loss rates greater than 1 percent holds across all files sizes, with longer transfers \(i.e., 25 MB files\ seeing a greater improvement than short transfers \(i.e., 50 KB files\. We argue that the greater throughput afforded by the shim in high loss conditions is due to the advanced congestion control features in SCTP, such as Limited Transmit Appropriate Byte Counting, and Selective Acknowledgments that are not present in FreeBSD 4.10’s version of TCP \(New Reno\ [6  Ou r res u l t s f r o m e x pe rim e n tin g  w ith S C P ov er t h e shim confirm the same trends at high loss rates as earlier work 6 h ich ex p e rim e n t e d w ith v a ri o u s im p l em en tati o n s o f F T P running over SCTP. We speculate that if TCP were to incorporate the same congestion control features that SCTP currently supports, throughput for applications running over both the shim and normal TCP connections would be similar at all loss rates We feel our experimental results show the transparent TCPto-SCTP translation shim with DRT policy is technically feasible, functions effectively with common network applications under realistic conditions, and provides performance \(measured in terms of application throughput\that is equivalent to or better than what is possible using TCP and existing TCP-to-SCTP translation scheme IV  C ONCLUSIONS AND F UTURE W ORK  The transparent TCP-to-SCTP translation shim allows legacy TCP applications to enjoy SCTP’s multihoming advantages \(i.e., fault tolerance and potentially concurrent multipath transfer\ithout requiring any modifications to the legacy applications themselves. Additionally, in nonmultihoming situations, the shim encourages increased SCTP deployment by providing a path for gradual migration from legacy TCP applications to native SCTP applications, solving the incremental deployment problem typically experienced with new protocols Experimental results presented in Section III illustrate that not only is the shim approach an interesting theoretical concept but that the shim with DRT policy is technically feasible in practice with real applications under typical network conditions. The hope of this work is that users and developers alike will begin to appreciate how the advanced features provided by SCTP can be valuable for network applications By ensuring that existing legacy TCP applications can seamlessly interact with new SCTP counterpart applications the shim encourages innovation and the increased deployment of SCTP throughout the Internet In the future work, it would be interesting to looking for a new scheme of transparent TCP-to-SCTP translation shim using parallel TCP and SCTP connection when TCP connection and SCTP association co-exists A CKNOWLEDGMENT  This work is supported by the “11th Five-Year Project” of Chinese Association of Higher Education \(Grant No. 06AIJ0240070\and Ph.D. Programs Foundation of Qiongzhou University \(Grant No. QYXB201007 R EFERENCES  1  R. Stewart, Q. Xie, K. Morneault, C. Sharp, H. Schwarzbauer, T. Taylor I. Rytina, M. Kalla, L. Zhang, and V. Paxson. Stream Control Transmission Protocol. RFC 2960, Internet Engineering Task Force October 2000 2  J. Iyengar, K. Shah, P. Amer, and R. Stewart. Concurrent Multipath Transfer Using SCTP Multihoming. In SPECTS 2004 3  R. Bickhart, P. Amer, R.Stewart.TCP-to-SCTP translation shim layer in the FreeBSD kernel, EuroBSDCon2007, Copenhagen, May 2007 4  The FreeBSD Project. SYSCTL\(8\reeBSD System Manager’s Manual, March 2002 5  L. Rizzo. Dummynet: A Simple Approach to the Evaluation of Network Protocols. In ACM Computer Communication Review,January 1997 6  P. Natarajan, P. Amer, R. Bickhart, and S. Ladha. Corrections on Improving Multiple File Transfers Using SCTP Multistreaming Corrections to  Prot oc ol E n gin eeri n g L a b  J u n e 20 05  http://pel.cis.udel.edu/poc/index.html  7  S. Ladha and P. Amer. Improving Multiple File Transfers Using SCTP Multistreaming. In IPCCC 2004, Phoenix, April 2004  


4  Yuming Qu. “One method to improve the efficiency of Apriori algorithm.”  Computer Engineering and Design, vol25, 2004 5  R. Agrawal. “Database Ming: A Performance Prospective.” IEEE Transaction on knowledge and data engineering, May 1993,pp.914-925    
4089 
4089 


N 005 002 005 200 400 600 800 1000 2 0.22 0.44 0.67 0.88 1.11 3 0.33 0.66 0.97 1.32 1.65 5 0.55 1.08 1.64 2.14 2.75 10 1.2 2.2 3.2 4.3 5.5 20 2.1 4.3 6.5 8.7 10.8 TABLE I T IME S ECONDS  USED BY ALL PARTIES FOR DATA ENCRYPTION 003 200 400 600 800 1000 Time 0.15 0.32 0.48 0.63 0.8 TABLE II T IME S ECONDS  USED BY EACH MODERATOR that these computational costs do not include the overhead of key generation and computing two parameters 032 and 033  However generating these parameters belongs to the preparation period of the mining process Therefore it can be implemented before the protocol is executed without affecting the computation time of the protocol For evaluating the ef“ciency of the protocol in practice we build an experiment on the privacy preserving frequency mining in C environment which runs on a laptop with CPU Pentium M 1.8 GHz and 1GB memory The used cryptographic functions are derived from Open SSL Library To measure the computation cost of the frequency mining protocol in worst case we assume that all parties involve in the protocol except the miner are the moderators We measure the computation cost of the frequency mining protocol for 10 parties Before executing the protocol we generate a pair of keys for each party with the size of public keys set at 512 bits Table 1 illustrates our measurements of all partiess computation time in the submission phase it is in regard to 010 and 010 017 010  for a typical scenario where 010 003 004\005\005\005  010 017 010 003\002\005 The computation time of all parties is about 10.8 seconds Table 2 illustrates our measurements of a moderators computation time it is linear in 010 and does not depend on  and 010 017 010 For a typical scenario where 010 003 004\005\005\005  the computation time of a moderator is about 0.8 seconds The miners computation time it is linear in 010  010 017 010  and   However it is very small it only is 021\020 0126 when 010 003 004\005\005\005\005  010 017 010 003\002\005  and  003\004\005  V P RIVACY PRESERVING FOR CLASSIFICATION RULES LEARNING IN TWO DIMENSION DISTRIBUTED SETTING A Privacy preserving association rules mining 1 Association rules and frequent itemset The association rules mining problem can be formally stated in Let  003  002 006 005 006 007\007\007\006  002 003 be the set of all items Let 002\003 a transaction database where each transaction 020 is a set of items such that 020 012   Associated with each transaction is a unique identi“er denoted by 020&\002  We say that a transaction 020 contains  a set of some items in  if  012 020  The problem is to nd the association rules that have an implication of the form  016  014 6\006  015  where  012    012   and  017  003 7  The support 6 and the con“dence  of the rule  016  are de“ned as 6 003 014 006  020  007\003 020 006  020  007 010 002\003 010  003 014 006  010  007\003 020 006  020  007 020 006  007 Where 020 006  007 stands for the number of transactions containing the set  in 002\003 and 010 002\003 010 denotes the total number of transactions in 002\003  The strong association rules are required to meet a minimum support  6 021\003\014  and a minimum con“dence   021\003\014  de“ned by the miner A set of items is referred as an itemset An itemset that contains 016 items is a 016 itemset The support count of an itemset is the number of transactions containing the itemset The minimum support count is de“ned as 6 021\003\014 010 002\003 010 An itemset is frequent if its support count is not less than the minimum support count Association rule mining is a twostep process 1 Finding all frequent itemsets 2 Generating strong association rules from the frequent itemsets Agrawal et al 2 presented the Apriori algorithm to ef“ciently identify frequent itemsets for boolean association rules The name of the algorithm is based on the fact that the algorithm uses the Apriori property i.e all nonempty subsets of a frequent itemset must also be frequent 2 Finding a frequent itemset Assume that the transactions set 002\003 is two-dimension distributed into 011\012 parties as in Section 002 007\005  Each party 014 003\004  015 003\004 006 007\007\011\006 016 003\004 006 007\007\006 012 wns 002\003 003\004 that contains information about certain attribute set  003 004 004 and certain records Given a candidate set  of the 016 items the parties wish to cooperatively nd whether or not the candidate set is frequent from the joint transaction set  002\003  without disclosing each partys individual transactions and even the local frequent itemsets Assume that  is partitioned into parts  004  where 016 011 017  S 012\002 004 006 007\007\006 012 003  Each  004 consists of items 011  003 004 004  Note that if  is frequent in 002\003  it is frequent in at least one horizontal partition 002\003 003  where 002\003 003 003 002\003 003 002 020 007\007\007 020 002\003 003\021  In addition if  004 is frequent in 002\003 003 every  004  016 011 017  is frequent in 002\003 003\004  Considering a map from each 002\003 003\004 to a binary number that is done by each 014 003\004 as follows 8 003\004 003 002 004 006 if  004 is frequent in 002\003 003\004  005 006 otherwise Thus 002\003 is mapped to the binary matrix 011 004 012    Hence  is frequent in at least one horizontal partition 0029 003 as long as at least a row 015 in  with all elements are 004  As the result 8 003 003 003 004 004 010 8 003\004 013\010 017 010 003\005  Clearly using frequency mining can allow the miner to nd a random permutation of  031 036 002   031 036 012  Therefore the miner can identify whether  is frequent or not without knowing  be frequent in which 002\003 003  3 Finding all frequent itemsets and their support counts In the classic Apriori algorithm The k e y issue is computing the support of an itemset To nd out if a particular itemset is frequent we count the number of records where the values for all the attributes in the itemset are 1 Thus the 
101 


problem is to compute the frequency of values tuples that all values in the tuple are 004  The privacy preserving protocol for nding frequent itemsets and support counts follows Apriori algorithm as below 1 002 Finding an item 004 Itemsets is frequent 003 2 022 002 003  3 The miner sets  002 003 021 4 for each  011 022 002 do 5 The miner uses the frequency mining protocol to identify whether or not  is frequent 6 if  is frequent then 7 The miner does  002 003  002 020  8 Let  011  003 004 004  the miner broadcasts the requirement for computing 017\024++;\036 006  007 to all 014 003\004  015 011\002 004 006 007\007\007\006 011 003  9 All parties involve in frequency mining protocol to compute 017\024++;\036 006  007 10 end if 11 end for 12 for 002  003\002   037 005 002 006 003 021  016\016 003 do 13 The miner does 022 037 Approri-gen  037 005 002  14 for each  011 022 037 do 15 The miner uses the frequency mining protocol to identify whether or not  is frequent 16 if  is frequent then 17 The miner does  037 003  037 020  18 Let  consists of items partitioned into the sets  004  where 016 011 017  017 007\002 004 006 007\007\007\006 012 003  the miner broadcasts the requirement for computing 017\024++;\036 006  007 to all 014 003\004  016 011 017  19 The miner and the parties involve in frequency mining protocol to compute 017\024++;\036 006  007 20 end if 21 end for 22 end for 4 Analysis of protocol Statement 1 Correctness If all participants follow the protocol then the miners result is the frequent itemsets and the support count of each frequent itemset Proof Candidate itemsets are generated by the Apriorigen procedure The correctness of that procedure has proved  The 022 037 sets are generated correctly as long as the input to the procedure is correct We show by induction that the  037 sets are generated correctly At steps 004 013 022 with  003\004   002 is correctly generated by the frequency mining protocol Assume that  037 005 002 has been correctly generated then 022 037 is correctly generated by Apriorigen procedure Since frequency ming protocol is correct the support count of each  011 022 004 005 002 is computed correctly Hence  037 is generated correctly from  037 005 002  The entire frequent itemsets and the support counts gives correct results Statement 2 Privacy The protocol preserves the privacy of the honest users against the miner and up to 011\012 013 002 corrupted parties as long as there is at least an honest be the moderator Proof Since all support count computations and frequent itemsets identi“cation are done independently using frequency mining This statement follows immediately from Theorem 2 5 Evaluation of complexity The communication analysis critically depends on the number of frequency computations called We incur the cost of privacy preserving frequency mining for each call Let 036 be the maximum size of a frequent itemset and let 022 003  015 003\004 006 007\007\007\006 036  and  003  015 003\004 006 007\007\007\006 036  represent the number of candidate itemsets and the found number of frequent itemsets at each round the total communication consists of cost of nding frequent and the cost of the support counts computation that is 022 003 003 012 003 006\002 006\020  016\002 022 003 007 0114 016\006\020  016\002  003 007 0104 bits Similarity the computational complexity is 5 006 003 012 003 006\002 006\006  016 022 003 007 011 016\006  016  003 007 010 007 modular exponentiations B Privacy preserving learning of ID3 tree in two-dimension distributed data Using the primitive of proposed privacy-preserving frequency mining we can learn ID3 trees in two-dimension distributed data without loss of accuracy The miners algorithm has the same complexity as the original ID3 tree algorithm except for an additional linear overhead factor Which has a value determined by the number of times frequency mining protocol using to compute gain 1 ID3 decision tree learning we rstly present a brief review of ID3 decision trees An ID3 tree is a rooted tree containing nodes and edges Each internal node is a test node and corresponds to an attribute The edges going out of a node correspond to the possible values of that attribute The ID3 algorithm works as follows The tree is constructed top-down in a recursive fashion At the root each attribute is tested to determine how well it alone classi“es the samples The best attribute is then chosen and the samples are partitioned according to this attribute The ID3 algorithm is then recursively called for each child of this node using the corresponding subset of data Thus major problem of the algorithm is choosing the best attribute that can achieve the maximum information gain at each node Clearly the problem of choosing the best attribute can be reduced to computing entropies that require computation of the frequency of tuples of va 2 Protocol of privacy-preserving ID3 tree learning Let 002\003 be a data set that has the set of non-class attributes 005 003 002 005 002 006 007\007\006 005  003 and  the class attribute Without loss of generality we assume that all attributes have the same domain size d 002 037 002 006 007\007\007\006 037 002 003  002\003 is two-dimension distributed into 011\012 parties as in Section 002 007\005  Each party 014 003\004  015 003 004 006 007\007\011\006 016 003\004 006 007\007\006 012 wns 002\003 003\004  There are 011 parties 014 003\021  015 003\004 006 007\007\011 007 holding the classi“cation attribute   The parties wish to cooperatively build the 002 023 decision tree classi“er from the joint data set of all parties without disclosing each partys individual transactions and even the number of the local records Assume that parties have set a system as the computation model described in Section 023  In this section we use frequency protocol as the primitive to design the privacy protocol for building decision tree following the ID3 
102 


Algorithm PrivacyPreservingID3 006 005\006 006 002\003 007 1 If 005 is empty return a leaf-node with the class value assigned to the most of all transactions in 002\003  2 Use the privacy preserving method to count the number of records with each class label If 002\003 consists of records which have the same class label 8  return a leaf node with 8  3 Otherwise Determine the best attribute 005 003 for 002\003 using the privacy-preserving method For 005 003 003 002 037 002 006 007\007\007\006 037 002 003 let 002\003 006 037 002 007  002\003 006 037 002 007 be a partition of 002\003 that every record in 002\003 006 037 005 007 has attribute value 037 005  Return a tree whose root is labeled 005 003  the root has outgoing edges labeled 037 002  037 002 s.t each edge 037 005 goes to the tree 014 036\0158\037"\033\014 036\6\\0368\015\011\031&\002 023\006 005 013 005 003 006\(\006\002\003 006 037 005 007\007 007 3 Analysis of protocol The communication/computation depends on the number of records number of vertically partition number of attributes number of attribute values per attribute number of classes and complexity of the tree For a rough analysis the cost of computation involves in terms of the time number of frequency mining protocol called to build the tree Assume that there are 036 nodes in nal classi“cation tree In total each node needs  006\004 016 004 007 the calls of frequency mining protocol All node of the tree need 036 006\004 016 004 007 the frequency computation Therefore in total the entire classi“cation process will require O 036\004<\010 006  016 010 017 010 007  encryptions and O 036\004<\010 006  016 010 017 010 007 4  bits communication VI C ONCLUSION In this paper we proposed a method for privacy-preserving classi“cation learning in two-dimension distributed data which has not been investigated previously Basically the proposed method is based on the ElGamal encryption scheme and it ensures strong privacy without loss of accuracy We illustrated the applicability of the method by applying it to design the privacy preserving protocol for some learning methods such as association rules mining decision tree learning We conducted experiments to evaluate the complexity of the protocols The experimental results showed that the protocols are ef“cient and practical R EFERENCES  A Evmie vski R Srikant R Agra w al and J Gehrk e Pri v ac y preserving mining of association rules In Proc of the Eighth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining ACM Press pp 217-228 2002  C C Aggarw al P S Y u Eds Pri v ac y-Preserving Data Mining Models and Algorithms Series Advances in Database Systems Springer Vol 34 2008  D Agra w al and C Aggarw al On the design and quanti“cation of pri v ac y preserving data mining algorithms In Proc ACM SIGMOD pp 247-255 2001  D Boneh The decision Dif fe-Hellman problem In ANTS-III V o l 1423 of LNCS pp 48-63 1998  F  W u J Liu and S Zhong An ef cient protocol for pri v ate and accurate mining of support counts Pattern Recognition Letters Vol 30 Issue 1 1 pp 80-86 2009  O Goldreich F oundations of Cryptography  B asic T ools V o l 1 Cambridge University Press 2001  H Martin and S Kazue Ef cient receipt-free v oting based on homomor phic encryption In Proc of Advances in Cryptology-Eurocrypt 2000  J Benaloh and D T uinstra Receipt-free secretballot elections e xtended abstract In Proc of the 26th Annual ACM Symposium on Theory of Computing ACM Press pp 544-553 1994  J V aidya and C Clifton Pri v ac y preserving nai v e Bayes classi“er for vertically partitioned data In Proc of the 2004 SIAM Conference on Data Mining 2004  J V aidya and C Clifton Pri v ac y preserving association rule mining in vertically partitioned data In Proc of the eighth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining pp 639-644 2002  Luong T D Ho T B 2010 Pri v ac y Preserving Frequenc y M ining in 2-Part Fully Distributed Setting IEICE Trans Information Systems to appear  M Kantarcoglu and J V aidya Pri v ac y preserving nai v e Bayes classi“er for horizontally partitioned data In IEEE ICDM Workshop on Privacy Preserving Data Mining pp 3-9 2003  M.Freedman K.Nissim and B.Pinkas Ef cient pri v ate matching and set intersection In Proc of Eurocrypt Vol 3027 of LNCS Springer-Verlag pp 1-19 2004  R Agra w a l a nd R Srikant Pri v ac y preserving data mining In Proc of ACM SIGMOD Conference on Management of Data pp 439-450 2000  R Agra w al R Srikant and D Thomas Pri v ac y preserving OLAP  I n Proc of the 2005 ACM SIGMOD International Conference on Management of Data SIGMOD 05 ACM pp 251-262 2005  R Agra w a l a nd R Srikant Pri v ac y-preserving data mining In Proc of the ACM SIGMOD Conference on Management of Data ACM Press pp 439-450 2000  R.Agra w al T  Imielinski and A.Sw ami Mining association rules between sets of items in large databases In Proc of the 1993 ACM SIGMOD international Conference on Management of Data 207-216 1993  S Zhong Z Y a ng and T  Chen k-Anon ymous data collection Journal of Information Sciences Vol 179 Issue 17 pp 2948-2963 2009  V S V e rykios E Bertino I.N F o vino L.P  Pro v e nza Y  Saygin and Y Theodoridis State-of-the-art in privacy preserving data mining ACM SIGMOD Record Vol 3 No 1 pp 50-57 2004  Y  Lindell B Pinkas Pri v ac y preserving data mining In Adv ances in Cryptology Crypto2000 Vol 1880 of LNCS Springer-Verlag pp 36-53 2000  Y  Tsiounis and M Y ung On the security of ElGamal-based encryption In Public Key Cryptography98 Vol 1431 of LNCS pp 117-134 1998  Z Y a ng S Zhong R.N Wright Pri v ac y-preserving classi“cation of customer data without loss of accuracy In Proc of the 2005 SIAM International Conference on Data Mining SDM pp 21-23 2005  W  Du and Z Zhan Using randomized response techniques for pri v ac y preserving data mining In Proc of the Ninth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining ACM Press pp 505510 2003  W  Du and Z Zhan Building decision tree classi“er on pri v ate data In Proc of IEEE International Confonference on Privacy Security and Data Mining pp 1-8 2002 
103 


              


   


                        





