 1 Using XML Configuration-Driven Development to Create a Customizable Ground Data System Brent Nash, Martha DeMore Jet Propulsion Laboratory and Calif ornia Institute of Technology 4800 Oak Grove Drive Pasadena, CA  91109 bnash@jpl.nasa.gov, mdemore@jpl.nasa.gov  Abstract 227The Mission data Processing and Control Subsystem \(MPCS\eing developed as a multi-mission Ground Data System with the Mars Science Laboratory MSL\he first fully supported mission.  The MPCS team started development for MSL in 2005 and will continue to support MSL through its 2011 launch and beyond, until the end of life of the mission \(approximately two years after landing on the surface of Mars 
currently provides varying degrees of support to other projects including the Mars Exploration Rovers \(MER\he Diviner instrument on the Lunar Reconnaissance Orbiter LRO\the DAWN mission, and has future plans to support the Soil Moisture Active Passive \(SMAP\ mission in the 2010-2013 timeframe.  The MSL mission will be the first operational usage of MPCS 12  MPCS is a Java-based Ground Data System \(GDS\for telecommanding and telemetry processing that has been developed using a Configuration-Driven Development CDD configuration files written in the eXtensible Markup Language \(XML\L is the ideal language for CDD because it is human-readable easily editable, and backed by a World Wide Web 
Consortium \(W3C\standard.  The CDD approach adopted by MPCS minimizes changes to compiled code by using XML to create a series of configuration files that provide total control over all aspects of GDS operation The MPCS development team has implemented a generic hierarchical architecture for specification of and access to configuration information that allows configuration parameters to be specified at the system, mission, and user levels.  In addition, MPCS has implemented an internal software architecture based on well-known software design patterns that utilizes configuration files to provide a great deal of flexibility in adapting MPCS to different missions and mission phases.  The resulting implementation is an 
XML-based design that is useful not only for MPCS or ground data systems in particular, but for any application While using XML-based CDD allows MPCS to have an exoteric functional interface that can be easily reconfigured at runtime instead of comp ile time, the challenges of developing a sufficiently flexible configuration and software architecture are signifi cant.  In order to create a 1  1 978-1-4244-2622-5/09 25.00 \2512009 IEEE 2 IEEEAC paper #1256, Version 3, Updated January 25, 2009 reusable multi-mission GDS, it is necessary to balance the added complexity of developi 
ng configuration-driven code with the ability to create an overall configuration strategy that both develope rs and users can understand and utilize effectively This paper will discuss the configuration and development strategies employed by the MPCS development team, the general MPCS software architect ure as influenced by CDD and the associated lessons learned in developing an XML configuration-driven GDS to be used for the life of the MSL mission and future missions T ABLE OF C ONTENTS  1  I NTRODUCTION  1 
 2  C ONFIGURATION D RIVEN D EVELOPMENT CDD 2  3  MPCS AND CDD  4  4  C ONCLUSIONS  11  5  A CKNOWLEDGEMENTS  12  R EFERENCES  13 
 B IOGRAPHY  13  1  I NTRODUCTION  The Mission data Processing and Control Subsystem MPCS\s the next-generation Ground Data System \(GDS under development for the 2011 launch of the Mars Science Laboratory \(MSL\ In addition to being a large component of the ground system for MSL, MPCS is also in varying degrees of use on the Mars Exploration Rovers \(MER\he Diviner instrument on the Lunar Reconnaissance Orbiter LRO\he DAWN mission as well as other internal projects MPCS is being developed as a multi-mission ground system 
that will experience its first operational use on MSL, but has been developed with expansion to future missions in mind MPCS is responsible for the re liable interpretation, realtime distribution, and archival of spacecraft information for a wide range of science and operations customers.  This information includes spacecraft telecommand data 223uplink\224\etry \(\223downlink\224 MSL, MPCS has two distinct targets for telecommanding and telemetry receipt 
200  Flight Software \(FSW into the flight hardware that controls the MSL vehicle throughout the mission lifecycle 


 2 200  Simulation and Support Equipment \(SSE software interface into the Ground Support Equipment \(GSE\hat is only part of the mission lifecycle up until the launch MPCS is responsible for spacecr aft telemetry processing in all phases of the MSL mission and spacecraft telecommanding in all phases up until operations 3 MPCS will be used throughout the entire mission lifecycle of FSW development, test, and operations in a variety of venues 200  WorkStation TestSet \(WSTS\Individual FSW developers and other spacecr aft team testers work on their individual development workstations telecommanding to and receiving telemetry from a flight system emulator 200  Mission Testbeds \226 FSW developers and spacecraft team testers do in tegration, verification and validation procedures with various subcomponents of the actual flight system hardware 200  Assembly, Test and Launch Operations \(ATLO\\226 The FSW and GDS systems are integrated with the assembled flight hardware in a flight-like test environment 200  Operations \226 The various phases of the operational mission from launch to the end of life of the mission on the surface of Mars Each venue offers a distinct set of challenges in terms of adaptation, performance and functionality and plays a key role in proving the robustness of MPCS to MSL mission planners and managers Each venue has its own performance requirements and many of the Application Programming Interfaces \(APIs\transmitted data formats change based on the venue.  The WSTS and Testbed venues have relatively low numbers of concurrent users, but run at high data rates and produce significant amounts of data during tests that run on the order of a few hours.  The ATLO venue is much more intense and can run tests for hours or days while providing telemetry insight for twenty or more users simultaneously.  The performance and scalability requirements of MSL Operations are actually less demanding than the Testbed and ATLO venues, so by spending adequate time soaking in these test venues the MPCS team can ensure that MPCS will be a robust and stable product by the time MSL reaches Operations The major challenge for MPCS is to provide a single software package that can be flexible enough to support all the different venues in all the different phases of the MSL mission.  Furthermore, MPCS must not only handle the 2  3 Due to project scope and budget con cerns, MPCS will not be used for telecommanding in the MSL Operations phase complex requirements of the various phases of the MSL mission, but it must be agile enough to be easily adapted to future missions In tackling these significant software development challenges, MPCS has adopted an XML-based Configuration Driven Development \(CDD 7 approach for writing object-oriented software which has been extremely useful in providing a product flexible enough to be used in a variety of scenarios and agile enough to quickly adapt to new requirements and new missions.  The following sections will first describe CDD as an abstract objectoriented software design methodology, then describe the basic MPCS software architecture and finally explain how a CDD strategy has helped MPCS meet its customers\222 needs 2  C ONFIGURATION D RIVEN D EVELOPMENT CDD   Overview The following section provides an overview of the benefits of adopting a CDD-based approach to software development and then discusses how to use CDD including how to choose a configuration representation, what information should be placed in the configuration and how code should be written to best leverage the configuration Why CDD As the name implies, CDD places the primary focus of software development on configuration written outside of the code.  Just as models are built first in Model-Driven Development or tests are written first in Test-Driven Development, CDD involves writing basic configuration file structure and content before developing the business code that utilizes the configuration.  By writing configuration first, developers are forced to focus on what information can be represented independently of the code that will operate on it. Developers must also determine if any pertinent information is already present in existing configuration and can thereby avoid duplicating information and processing logic.  Another benefit of CDD is that configuration files are easy to manage from a Configuration Management \(CM because they can be sourcecontrolled and stored in a versioning system, such as the Concurrent Versions System \(CVS\on, in the same way that source code is managed.  CDD is not tied to one specific programming language either; because configuration is represented in a neutral format, the same configuration files can be used across a number of different programming languages.  The biggest advantage of CDD is that the behavior of the software may be drastically altered without having to recompile or redeliver code 


 3 Configuration Strategies The first major choice to make when adopting a CDD approach is deciding how configuration information will be represented.  There is no single representation used unilaterally for configuration, but the most popular choices are 200  Environment Variables \226 Configuration information is specified at the Operating System OS\evel. Environment variables are useful in making the same information available to a number of disparate processes, but can cause consistency issues between different users, shells, and environments 200  Homegrown Formats \226 Configuration information is specified in a format created by the developers who have complete control over the format and content restrictions of the configuration.  The main disadvantage of a homegrown configuration format is that the parsing and validation business logic must generally be written from scratch, adding to development time.  In addition, the format is difficult to share with other development teams when integration becomes necessary 200  Keyword-Value Format \226 Configuration information is specified in a simple name=value  format.  Keyword-value formats are generally very easy to read, write, and interpret and most programming languages have existing parsers for keyword-value formats.  The main disadvantage is that keyword-value is a loosely defined format and it can be difficult to enforce organizational restrictions or validate the values of particular configuration entries 200  XML Format \226 Configuration information is specified in a World-Wide Web Consortium W3C\andard language that has a wellunderstood format and wide user base.  Software for writing and parsing XML is widely available in most programming languages.  XML also provides the ability to do schema-based validation that can be used to restrict configuration format and even restrict values on particular entries.  The main disadvantage is that XML is a verbose language that causes configuration file size to expand quickly and its syntax can be confusing to users who are not familiar with XML The choice of a configuration representation format is important because it will affect the entire future of the CDD project.  Once a configuration format is chosen, it can be difficult and costly to change formats further down the road Once the choice has been made on what configuration representation to use, the next issue is to decide what should actually be placed in the configuration What To Configure One of the most difficult parts of CDD is determining what information should be made configurable and what should be implemented in code.  Some general classes of information that should be made into configuration values are 200  Common Information \226 Information that is repeated in multiple places in the code and has a nonzero chance of changing at some point in the software\222s lifetime. By pointing all code to a single location for a common piece of information developers ensure that the software\222s behavior will remain consistent when the information needs to change 200  Default Information \226 Info rmation that represents part of the standard out-of-the-box behavior of the software.  By putting default values in the configuration, the out-o f-the-box functionality of the software may be adjusted with little effort 200  Unstable Information \226 Information that is unknown or in flux at the time of development This information has a high likelihood of changing once the software has been delivered 200  Configuration-Dependent Information \226 Information that is depe ndent on another piece of information already presen t in the configuration In addition, there are general classes of information that should not be made configurable 200  Static Information \226 Information that has no likelihood of changing throughout the life of the software.  Adding values that will never change to the configuration clutters the configuration while providing no tangible benefit 200  Compound Information \226 Information whose value can be completely determined based on other information already represented in the configuration.  This information can easily be represented in software whereas representing it in configuration can lead to conflicting configuration values 200  Complex Logic \226 Configuration values are information that can be used in code to alter basic software flow and operation, but it is not the job of configuration to provide any type of logical assertions that would normally be written in code 


 4 Unfortunately, not all information falls nicely into one of these prescribed categories and in many cases CDD becomes a process of trial a nd error to determine what works well in configuration a nd what should remain written in code.  As developers become more comfortable with CDD, the distinction between what should be configurable and what should not becomes clearer.  In CDD, a developer should always err on the side of configurability rather than hard-coding information into code In conjunction with deciding what information should be made configurable, the development team must also make the decision of how configuration should be stored represented and accessed from within the software itself Though CDD can be used with any type of programming language, the focus of the following discussion will be on object-oriented software design Software Design Patterns for CDD As object-oriented programming languages have grown in popularity, a number of useful development paradigms known as design patterns 4 6  for solving recurring objectoriented design problems have arisen.  In CDD, external configuration files will grow in size over the life of the project and the configuration information they contain will be needed in many different places in the code, so it is important to implement the configuration representation in software in a way that is both efficient and scalable.  There are numerous ways to represent configuration in code, but some of the most popular strategies are described by the following design patterns 200  Singleton \226 Read the configuration into a single shared object that is globa lly accessible to all other objects.  Also known as a \223single object model.\224 4  200  Engineering, Housekeeping, and Analysis \(EHA\\226 Also known as \223channels\224, EHA data describes measurements of hardware and software state \(e.g attitude pointing, temperature readings, etc 200  Event Records \(EVRs\ data describes both expected and unexpected ev ents that have occurred 200  Dependency Injection \226 Read the configuration into one or more configuration objects and pass a configuration object to any other object that needs it 3  200  Monostate/Borg \226 Read the configuration into an internal state that is shared between a set of configuration objects that behave as though they were a single object 6  Using any of these design patterns will provide a uniform method of accessing configurati on information in code Representing the configuration in code is the core of CDD but there are also other design pa tterns, such as the Abstract Factory \(a.k.a. Kit 4 that harmonize well with the use of a CDD strategy The Abstract Factory pattern provides an interface for creating sets of objects without specifying their concrete classes.  The power of the Ab stract Factory design pattern in object-oriented languages such as Java is based on the use of reflective programming 5 Many popular objectoriented programming languages, such as C++, C Smalltalk, Java, Python 8 and Ruby, support a reflectiveprogramming interface that allows objects to be dynamically instantiated at runtime by providing information to identify the object \(e.g. the name of the object\222s class rectly instantiating the object itself.  By supplying reflection information in the configuration, reflective programming can be used to dynamically determine what objects to instantiate at runtime based on configuration informa tion rather than hard-coding the instantiation of one particular type of object.  With an Abstract Factory pattern, a calling object can pass in relevant information to the factory, the factory can look up the name of the class to instantiate in configuration, and then using reflection the requested object can be instantiated dynamically and handed back to the caller. Many objectoriented software projects, such as the popular open source Spring Framework 9 use the notion of supplying reflection information in a configuration file in order to achieve greater flexibility in code  3  MPCS AND CDD   Overview The following section provides an overview of the MPCS software system by explaining the MPCS data flow providing an overview of the MPCS software architecture describing the MPCS configuration file format and structure, and then discussing how MPCS uses a configuration-oriented approach to achieve added flexibility.  Though MPCS is used in both uplink and downlink scenarios, for brevity the following discussion will focus solely on the MPCS downlink telemetry flow MPCS Input Stream Spacecraft produce a great deal of telemetry with varying characteristics according to the type of mission and stage in the mission lifecycle.  Data is generally transmitted from the spacecraft via transfer frames th at are encoded to prevent data corruption during transmission.  Transfer frames contain data packets that in turn contain varying types of telemetry information.  Each packet has an Application Identifier \(APID\at specifies what type of telemetry it contains.  There are three ma jor types of telemetry read from packets and processed by MPCS 


 5 onboard the spacecraft in the form of humanreadable strings with an a ssociated severity level 200  Data Products \226 Products are files containing science or engineering data such as images and instrument measurements that are represented and transmitted as a single binary object MPCS receives either transfer frames or packets, in various forms, as telemetry input and must extract and interpret the telemetry items within the frames and packets to make them available to end-users.  MP CS provides a realtime interface via a Java Messaging Service \(JMS\bus 2 and a historical interface via a relational database.  In addition, received data products are also placed on a Network File System NFS\ distribu tion.  MPCS performs many other functions during data processing, such as marking EHA channels with alarms to indicate potential anomalies but these more in-depth functions are outside the scope of this discussion A small sample end-user display of EHA and EVR telemetry from the realtime JMS bus is shown in Figure 1 above \(note that the data in Figure 1 has been artificially constructed for the sake of this example\op portion of Figure 1 shows the values of three different voltage readings from the spacecraft The \223ID\224 and \223Title\224 columns are used to identify the measur ement, the \223Raw\224, \223Value\224 and \223Unit\224 columns are used to read the actual measurement and the \223ERT\224 and \223SCET\224 times are used to identify when the measurement was taken.  The bottom portion of Figure 1 shows four different EVRs that were generated by the spacecraft.  The \223Name\224 is used to identify th e event, the 223Level\224 indicates the severity of the event, the \223Message\224 describes the event that occurre d and the \223ERT\224 is used to identify when the ev ent occurred.  In both cases, the Earth Receive Time \(\223ERT\224\telemetry item was received on the earth and Spacecraft Event Time 223SCET\224\is the time at which the event occurred onboard the spacecraft As a tool that is used throughout every stage of the mission lifecycle from low-level tests through operations, MPCS is built with data retention and archival in mind.  During a telemetry processing run of MPCS, all information that appears on the realtime displays, such as the display in Figure 1, is also stored in a relational database 4 To assist in the organization of data archives and the identification of specific test runs, the MPCS development team created a per-test identifier known as a \223session.\224 MPCS Sessions All tests run with MPCS are stored in relational databases so that past results may be re analyzed and past tests may be re-run.  The MPCS development team devised the notion of a \223session\224 to store all of the specific information that would be needed to recreate a given test \(e.g. telemetry dictionaries used, host where th e test was run, etc.\In addition, an MPCS session also has metadata, such as a test name, that allows users to add identifying information to sessions to assist in finding th e historical session later Each session is also tagged with a unique identifier by MPCS so that all sessions are uniquely identified in the relational database.  At the beginning of every run of the MPCS software, users supply session information that MPCS uses for a variety of purposes including determining what venue \(e.g. WSTS, Testbed, ATLO\t is running in The session information supplied by the user becomes an input to MPCS and is important in controlling MPCS\222 processing behavior MPCS High-Level Architecture Once the MPCS session has been established, the session information and all of the configuration files are used as 5  4 Information such as raw binary frames and packets that do not get published to the realtime JMS bus are also stored in the relational database Figure 1 \226 Sample MPCS Monitor Display 


 6 inputs to launch MPCS.  In the context of telemetry processing, MPCS consists of two main processes:  a downlink process responsible for doing the actual telemetry processing and a monitor process responsible for displaying telemetry information to end-users.  A small sample instance of the monitor process is shown in Figure 1 As shown in Figure 2 below, the MPCS downlink receives input data from a telemetry source, such as a spacecraft emulator in the WSTS venue or the Deep Space Network DSN\in Operations, and processes the telemetry into a human-readable format.  The other inputs to MPCS are the user input session information and the set of MPCS configuration files.  Once all of the session information and configuration has been loaded, the MPCS downlink will process all of the input telemetry from the telemetry source and write the resulting information to an NFS disk, a relational database, and a JMS message bus  Figure 2 \226 MPCS High-Level Architecture The MPCS downlink and MPCS monitor share session information and configuration information, but otherwise the only communication between the two processes is done via the JMS message bus.  The MPCS team intentionally chose to separate the processing of telemetry from its display in order to achieve greater flexibility by isolating the telemetry processing business logic in the MPCS Downlink from the user inte rface logic in the MPCS Monitor.  In some MSL ve nues, such as ATLO, where many users wish to monitor an ongoing test, there will generally be only two instances of the MPCS Downlink process 5 one for FSW and one for SSE, and a large number 6  5 The MSL spacecraft actually has three separate telemetry streams.  A Time Zero \(TZ\ is connected until launch, a Launch Vehicle \(LV stream is connected from the launch vehicle and a Selected Active \(SA stream is the radio frequency communica tion to be used for the life of the MPCS Monitor processes.  The MPCS Monitor has been briefly discussed for context, but for simplicity and clarity the remainder of the MPCS architectural discussion will focus on the internal archit ecture of the MPCS Downlink process MPCS Downlink Architecture The MPCS Downlink architecture was designed to handle the pipeline-style, unidirec tional nature of spacecraft telemetry processing.  The MPCS Downlink is built as a series of pipelined adapters, each of which handles a processing stage in the telemetry pipeline, and all adapters communicate with one another via an internal message bus The general telemetry processing architecture of MPCS is shown in Figure 3 The internal message bus allows the MPCS adapters to register interest in certain pieces of telemetry information e.g. Packets, EVRs, etc of information become available.  Although it is described as a \223message bus\224, the internal message bus designed by MPCS is actually an implementation of the well-known Observer design pattern 4 that promotes loose coupling between communicating object s in an object-oriented system.  By registering interest in information with the internal message bus and allowing the message bus to deliver that information when it becomes available, the various MPCS adapters become easier to modify and replace.  In this fashion each adapter can act as an independent entity by recei ving and publishing messages with no knowledge of what other adapters have been loaded In addition to the internal message bus, the other key concept in the MPCS Downli nk architecture is that the various adapters, shown in Figure 3, can be dynamically loaded from configuration information rather than be hardcoded.  MPCS uses its configuration files to determine what adapters should be loaded and then uses the Abstract Factory design pattern and reflective programming to dynamically load the desired adapters on startup. The detailed process of how MPCS determines which adapters to load and how the adapters themselves are loaded will be described in detail later The overall MPCS downlink arch itecture can appear as a completely new design paradigm, but it is actually an amalgamation of well-understood software design patterns and programming techniques that have been combined in a useful way.  By using configuration to dynamically load adapters and using an internal message bus to loosely couple the adapters, the MPCS downlink achieves a great   mission.  All three streams deliver th e same telemetry from the FSW, but via different hardware paths.  Oftentim es, two or three of these streams are run simultaneously for verification of hardware and each stream requires its own MPCS Downlink process 


 7 deal of flexibility that is very useful in adapting MPCS to new venues and new missions  Sample MPCS Telemetry Flow Though the flow of telemetry through the MPCS downlink appears complicated, there is a predictable set of steps that occur whenever telemetry is received.  Figure 3 above shows the input and output messages from all of the adapters in the telemetry fl ow and each adapter\222s place in the downlink flow can be determined on the basis of what messages it subscribes to and what messages it publishes 200  The Raw Input Adapter receives input telemetry from a telemetry source as unsynchronized raw data, frames or packets and then publishes the corresponding type of data to the internal message bus as \223Raw Data\224, \223Frame\224, or \223Packet\224 messages 200  The Frame Sync Adapter subscribes to \223Raw Data\224 messages on the internal message bus and performs frame synchronization on unsynchronized raw data it receives.  The Frame Sync Adapter publishes a 223Frame\224 message to the internal message bus for each frame it finds in the raw data stream.  This step only occurs if unsynchronized raw data is received from the telemetry source 200  The Packet Extract Adapte r subscribes to \223Frame\224 messages on the internal message bus and extracts the packets contained w ithin the frames.  The Packet Extract Adapter publishes a \223Packet\224 message to the internal message bus for each packet it extracts.  This step only occurs if unsynchronized raw data or transfer frames are received from the telemetry source 200  The EVR Adapter subscribes to \223Packet\224 messages on the internal message bus and uses the APID of the packet to determine if it contains EVR data The EVR Adapter either extracts the EVRs contained within the packet or ignores the packet if it does not contain EVR data.  The EVR Adapter publishes an \223EVR\224 message to the internal message bus for each EVR it extracts 200  The EHA Adapter subscribes to \223Packet\224 messages on the internal message bus and uses the APID of the packet to determine if it contains EHA data The EHA Adapter either extracts every EHA measurement contained w ithin the packet or ignores the packet if it does not contain EHA data Figure 3 \226MPCS Downlink Architecture and Flow 


 8 The EHA Adapter publishes an \223EHA\224 message to the internal message bus for each EHA measurement it extracts 200  The Data Product Adapter subscribes to \223Packet\224 messages on the internal message bus and uses the APID of the packet to determine if it contains data product information.  The Data Product Adapter either extracts the data product information contained within the packet or ignores the packet if it does not contain data product information.  The Data Product Adapter publishes a \223Product\224 message to the internal message bus for each piece of data product information it extracts.  The Data Product Adapter also writes data product files to the NFS disk as they are constructed 200  The Database Adapter subscribes to \223Frame\224 223Packet\224, \223EVR\224, \223EHA\224, and \223Product\224 messages on the internal message bus and stores the associated information from all these different messages into a relational database.  The Database Adapter does not publish to the internal bus 200  The JMS Bus Adapter subscribes to \223EVR\224 223EHA\224, and \223Product\224 messages on the internal message bus and publishes XML-based representations of the info rmation in each of these messages to a JMS Message Bus 6 The JMS Bus Adapter does not publish to the internal bus As described earlier, the Session Information is constructed from user input and the GDS Configuration is constructed from the system, project, and user configuration files.  Both the Session Information and GDS Configuration are read on startup and made globally available to all of the adapters in the downlink processing flow before any telemetry is received The set of adapters shown in Figure 3 is just one sample set of adapters that can constitute the MPCS telemetry flow The key to the MPCS downlink architecture is using configuration files to determin e what adapters are necessary for the given venue and teleme try input format.  Because adapters can act as independent entities, adapting MPCS to new mission venues and mission becomes a task of creating new adapters where necessary MPCS Mission Adaptation When MPCS is adapted to a specific mission, the MPCS team first determines what adapters are needed for processing the new mission\222s telemetry.  Some functionality, such as the p acket extraction done by the Packet Extra Adapter, is ba sed on a Consultative Committee 8  6 Currently only telemetry items such as EVRs, EHA, and Data Products are published to the JMS message bus Frames and packets are not published for bandwidth reasons for Space Data Systems \(CCSDS not change from one mission to the next.  Some processing such as extracting EVRs from packets as done by the EVR Adapter, however, is generally mission-dependent and it is likely that each mission will need its own custom EVR Adapter.  By using the notion of adapters to partition telemetry processing into independent pieces, MPCS can quickly adapt to new missions by simply building the necessary new adapters.  If a new mission has similar telemetry to an existing mission already supported by MPCS then the MPCS team can minimize the adaptation cost by reusing existing adapters In general, the set of adapte rs that are loaded each time MPCS runs is determined by three factors 1  The mission being run \(e.g. MSL 2  The venue specified by the user in the session information \(e.g. ATLO 3  Special override values in the MPCS configuration Using these three pieces of in formation, MPCS will look in its configuration files to determ ine what adapters are needed to process telemetry in the current test or operational scenario.  Beyond just adapting to a specific mission\222s telemetry processing needs, the MPCS downlink architecture is also well suited to adapting to different enterprise architectures MPCS Enterprise Adaptation The MPCS Downlink architectur e can be easily integrated into any existing Service-Orie nted Architecture \(SOA other enterprise architecture by providing service interfaces as adapters on the internal message bus.  As shown in Figures 2 and 3, the two major service interfaces currently provided by MPCS are a realtime messaging interface via a JMS message bus \(served by the JMS Bus Adapter\and a historical relational databa se interface \(served by the Database Adapter\ As telemetry processing is done, all relevant telemetry is made available to end-users via both of these interfaces Due to the loosely coupled design of the adapters in the MPCS Downlink, it is easy to add other external interface adapters that could function as service interfaces in an enterprise architecture.  A dding another external interface adapter, such as a Representa tional State Transfer \(REST adapter or a Simple Object Access Protocol \(SOAP for an SOA, is a simple task.  The new adapter would subscribe to relevant information on the internal message bus such as EVRs, EHA, and Products, and make them available via an external in terface.  These new service interface adapters can be added as subscribers on the internal message bus without aversely affecting the operation of any existing adapters.  The MPCS software architecture was designed with service-orientation in mind 


 9 and can therefore be easily m odified to fit into most enterprise architectures.  Like all other adapters in MPCS the new external adapters w ould also have access to the MPCS configuration files a nd therefore the external interfaces themselves could also be controlled via configuration.  In general, the key to the flexibility of the MPCS infrastructure is the use of XML configuration files to modify processing behavior MPCS Configuration File Format The MPCS XML configuration files contain the core set of information that drives the behavior of the MPCS Downlink such as information about what adapters to load on startup The MPCS team chose XML becau se of its well-structured format and its human-readability.  It was the belief of the MPCS team that if an intuitive XML layout structure could be defined for the configurati on, individual end-users would be able to easily edit parts of the configuration to customize their use of MPCS The actual structure of the MPCS configuration was designed so that related configuration values could be organized into hierarchical subgroups in the configuration structure itself.  The minimalist schema for the MPCS configuration defines only three types of configuration entries 200  Configuration Block \226 Used to define a subgroup in the configuration with no associated value 200  Configuration Value \226 Used to define a configuration entry with a single value that can be read from the configuration and used in code 200  Configuration List \226 Used to define a configuration entry with a set of values that can be read from the configuration and used in code Each type of configuration element is given a unique name to identify it in the context of the global configuration.  A small sample MPCS configuration file is shown in Figure 4 to the right  The MPCS configuration file organization, shown in Figure 4, uses <configBlock> elements to group related configuration values together and uses <configList> and config> elements to provide actual configurable values To represent a simple configuration entry with a single value, a <config> element is us ed. In the example in Figure 4, the property named \224propertyName\224 has a value of 223value1\224.  Similarly, to represent a simple list of values, a configList> element and <listItem> subelements can be used.  In the example in Fi gure 4, the \223listPropertyName\224 property provides a list of two values \223value2\224 and \223value3\224 that can be read as an array of values in code  GdsConfiguration config name=\224propertyName\224>value1</config configList name=\224listPropertyName\224 listItem>value2</listItem listItem>value3</listItem configList configBlock name=\224blockName\224 config name=\224nestedPropertyName\224>value4</config configBlock configBlock name=\224outer\224 configBlock name=\224inner\224 config name=\224myProperty\224>value5</config configBlock configBlock GdsConfiguration  Figure 4 \226 Sample MPCS Configuration File  For more complex cases, confi guration values can be placed into configuration block s ubgroups to provide a namespace mechanism that will prevent naming conflicts and allow hierarchical organization of properties.  Configuration properties defined within conf iguration blocks have names that are prefaced with the c onfiguration block name and a 223.\224 character.  In the exampl e in Figure 4, the property 223blockName.nestedPropertyName\224 would have a value of 223value4\224.  Configuration blocks can be nested arbitrarily deep and properties in the nested blocks will follow the same name prefixing conventi on as described above.  To access the value of \223myProperty\224 in the example in Figure 4, the property name \223outer.inner.myProperty\224 would be used to retrieve the value \223value5.\224 MPCS Configuration File Hierarchy As a multi-mission product used by many different users in a number of different environments, it is important for MPCS to provide a simple way for different users and different missions to have their own configuration values that override the default values put in place by the generic MPCS system configuration.  Rather than use a single central configuration file, the MPCS team chose to use a hierarchy of configuration files to increase flexibility.  The MPCS software can be configur ed at the system level, the project/mission level, and the user level. The hierarchy of MPCS configuration files is shown in Figure 5 


 10  Figure 5 \226 MPCS Configuration Hierarchy The system configuration file contains the complete set of all configurable values that are defined for MPCS Everything that is made configur able is always placed in the system configuration file.  The project configuration file contains a subset of the contents of the system configuration file.  If the same property is defined in the system configuration and project configuration, the value from the project configuration will be used.  Finally, MPCS provides the ability for users to specify a user configuration file that can override both the project and system configurations This capability allows individual users to tweak MPCS behavior to suit their own testing and development needs The system configuration is the only file that is absolutely necessary for MPCS to run; the project and user configurations are optional.  Furthermore, the user configuration file may be disabled for controlled environments like flight operations where it is undesirable to allow users to override normal software behavior MPCS Configuration In Action The overall structure of the MPCS code mirrors the structure of the configuration files at the system and project level.  The majority of the MPCS code is written as a common, mission-independent core that uses dynamically instantiated adapters to handle venue-specific or missionspecific business logic MPCS uses the Singleton design pattern discussed earlier to represent its configuration in code.  The Singleton configuration allows any piece of code to be able to easily pull information out of the MPCS configuration and because the majority of the MP CS design is single-threaded the scalability and synchronization issues of the Singleton pattern are minimized The earlier discussion of the MPCS Downlink architecture described how the MPCS Downlink uses a series of adapters to perform various sequential tasks in the telemetry processing chain.  To determine what adapters should be instantiated before telemetry processing begins, MPCS uses the notion of a supervisory \223Downlink Manager\224 object The Downlink Manager is the bootstrap object in code that is responsible for examining the session information and MPCS configuration and instantiating all of the necessary telemetry processing adapters.  The Downlink Manager will load all relevant adapters and attach them to the internal message bus before any processing of telemetry begins The first adapter to be instantiated is the Raw Input Adapter that will read raw telemetry fro m an input source.  The Raw Input Adapter to load is not known until runtime because it is dependent on the venue and data format information supplied by the user via the MPCS session.  MPCS has the ability to ingest a wide array of data formats and can read its input data from a file, a network socket, or a number of other APIs such as the Telemetry Delivery Subsystem TDS\ponent of the Deep Space Network \(DSN\where telemetry will be received operationally for MSL.  The MPCS Downlink Manager uses an Abstract Factory design pattern that examines the session information and the configuration and then dynamically instantiates the proper input adapter for the given scenario.  For example, in the MSL WSTS venue, the Downlink Manager must instantiate an adapter to ingest transfer frames from a network socket whereas in the MSL Testbed and ATLO environments the Downlink Manager must instantiate an adapter to ingest transfer frames from an API to the hardware that emulates the DSN.  As part of the Abstract Factory pattern, all implementations of the Raw Input Adapter share a common interface and are therefore in terchangeable in the MPCS telemetry flow The Frame Sync Adapter and Packet Extract Adapter work in a different paradigm than the Raw Input Adapter.  Frame synchronization and packet extraction are based on CCSDS standards, so they are multi-mission adapters that will generally not change based on a particular mission.  Based on the format of the input data, however, one or both of these adapters may be superfluous.  The MPCS Downlink Manager looks at the input data format in the session information and then checks the configuration to determine if frame synchronization or packet extraction is necessary for that particular data format.  For instance, if MPCS is configured to read a stream of data packets \(recall that data packets are normally extracted from frames\e synchronization and packet extraction are both unnecessary since they have already been performed prior to the data reaching MPCS.  Through configuration, MPCS is able to 


 11 determine that based on a packet input format it should not instantiate these two adapters that would serve no purpose The EVR, EHA, and data product adapters follow yet another configuration strategy to determine when and how they should be loaded.  As mentioned previously, extracting and constructing EHA measurements, EVRs, and data products from packets is generally a mission-specific operation.  In the MPCS system configuration, there is a property specifying a default ad apter for processing each of these types of telemetry, but MPCS needs the ability to override what adapter is loaded based on the mission Using the MPCS project conf iguration file, each mission can specify its own adapter to instantiate based on its own processing needs.  The MPCS Downlink Manager uses an Abstract Factory design pattern to examine the configuration properties that specify the names of the EVR EHA, and data product adapters, and then uses reflective programming to instantiate the proper adapters for the given mission.  Figure 6 below demonstrates how the MPCS Downlink Manager instantiates the proper EVR Adapter with the help of an Abstract Factory object  Figure 6 \226 MPCS EVR Adapter Instantiation Another feature of the MPCS configuration is the control of whether EVR, EHA, or data product processing is done at all.  At the system and project levels of the MPCS configuration, all of the EVR, EHA, and data product processing are always enabled 7 At the user level, however the configuration entries may be overridden to force MPCS 11  7 The MPCS adaptations for Diviner and DAWN only process EHA telemetry, so no EVR or data product processing adapters exist not to process particular telemetry items.  For instance, if a user is only interested in EVRs then that user can use the MPCS user configuration file to disable EHA and data product processing to reduce the MPCS processing load and improve throughput The remaining adapters, the Database Adapter and the JMS Bus Adapter, are a hybrid of the previously discussed scenarios.  Like the Frame Sy nc Adapter and Packet Extract Adapter, the Database Adap ter and JMS Bus Adapter are generally not overridden on a per-mission basis, and like the EVR Adapter, EHA Adapter, and Data Product Adapter, the Database Adapter and JMS Bus Adapter are generally desirable, so they are enabled by default at the system and project levels.  In certain testing and debugging scenarios however, it is desirable to disable one or both of these adapters.  Enabling and disabling database and JMS usage can be done using the MPCS user configuration file similar to the way EVR, EHA, and data product processing can be enabled and disabled By using the MPCS configuration files to determine what adapters should be loaded at runtime and to configure the behavior of particular adapters, the MPCS Downlink Manager can dynamically alter every aspect of MPCS telemetry processing 4  C ONCLUSIONS  Over the course of its development, MPCS has found CDD an invaluable strategy for maintaining flexibility in a constantly growing and evolving software architecture MPCS is currently in use for testing in many stages of the MSL lifecycle including the WSTS, Testbed and ATLO venues and is also in use in various non-operational venues on other projects such as MER, Diviner, and DAWN.  In supporting this wide variety of mission venues and missions, the MPCS development team has had to be able to drastically alter telemetry processing behavior between software releases to keep up with its customers\222 constantly evolving needs.  There have been numerous occasions where MPCS has been able to quickly adapt to feature requests and bug fixes solely based on editing entries in a configuration file.  The MPCS team has been able to save a lot of time and effort by making fixes via configuration so that the MPCS software does not have to be redelivered to customers Although CDD has proven very useful in maintaining an agile software development process, the added flexibility and adaptability comes at a high initial cost.   Developing a configuration-driven architecture involves spending upfront time and effort designing a configuration file format and developing software infrastructure.  Once the infrastructure is in place, how ever, massive changes can be made to functionality in a much smaller timeframe.  For inexperienced developers or developers new to MPCS 


 12 however, there is also a steep learning curve. Using CDD effectively involves developers adhering to particular design patterns and coding standards and it can take developers time to become accustomed to the rigors of CDD CDD as a design strategy states that configuration structure and content should be written prior to writing any business logic in code, but the MPCS team has discovered that CDD is better utilized as an iterative process.  Developers will initially examine configuration files and potentially make additions prior to doing code development, but it is impossible to know everything to put in the configuration before any development has been done.  The MPCS team has found that the best practice is to write basic configuration, write the business logic to leverage the configuration, and then iteratively refactor the code and configuration simultaneously to achieve as much flexibility as possible From a coding standpoint, CDD has also proven valuable in allowing the technology base of MPCS to expand.  The majority of the MPCS code is written solely in the Java programming language, but in the past year MPCS has also developed an automated scripting tool using the Python 6  scripting language.  Although MPCS is now composed of two distinct programming languages, Java and Python, both languages still easily share the same set of XML configuration files for modifying their functionality Changes to the MPCS configuration affect both the Java and Python code uniformly. Another coding advantage of CDD has been avoiding code duplication in the MPCS environment.  By pulling common values out into the configuration, MPCS has been able to greatly cut down on the \223ripple effect\224 of small changes propagating throughout the software One major concern that has arisen is that the MPCS configuration files have grown very large.  The split of the MPCS hierarchy out into system, project, and user configuration files has helped contain some of the configuration bloat, but as MPCS continues to grow in size and scope, the configuration files continue to grow with it For the future of MPCS as we ll as any other projects that plan on using a CDD strategy, it would be beneficial to split up configuration across a dy namically sizeable set of configuration files rather than trying to concentrate all configuration information into a fixed number of files.  The MPCS team has also found that configuration files need occasional reexamination and pruning to prevent them from becoming bloated with redundant or vestigial information One of the more surprising limitations of the MPCS CDD approach has been the reluctan ce of users to take advantage of the user configuration override capability. By using XML, an inherently human-readable format in conjunction with the ability to adjust software behavior based on a usersupplied configuration file, MPCS expected to have users easily modify the behavior of the software on their own with little or no intervention from the MPCS team.  In reality, however, MPCS has found that the average end-user is still averse to delving into XML configuration files. A helpful strategy has been to provide a set of user configuration files for common override behaviors and allow users to simply copy these files for their own use Any needed user configuration overrides that do not fall into this category are rare and have been handled on a caseby-case basis by the development team Overall, the benefits of the MPCS CDD strategy have greatly outweighed the issues that have been encountered The high up-front cost of developing configuration infrastructure has been offset by the relative ease of writing configurable code later in development.  A CDD strategy has helped MPCS become flexible enough to adapt to a number of different missions and agile enough to keep up with constantly evolving customer needs 5  A CKNOWLEDGEMENTS  The authors would like to thank the past and current MPCS team members Jesse Wright, Jim McKelvey, Mark Palm Josh Choi, Clark Williams, Ashley Shamilian, Kyran OwenMankovich, Dan Allard, Lloyd DeForrest, Michael Tankenson, Kelly Clarke and Jordan Lei of the Jet Propulsion Laboratory for their contributions The work described in this paper was conducted at the Jet Propulsion Laboratory \(JPL\Institute of Technology, under contract with the National Aeronautics and Space Administration \(NASA 


 13 R EFERENCES   Aerospace Conference W e bs ite http://www.aeroconf.org  Dan Al l a rd, \223Devel opm ent of a Ground Dat a M e ssagi ng Infrastructure for the Mars Science Laboratory and Beyond,\224 2008 IEEE Aerospace Conference Proceedings March 1-8, 2008  M a rt i n Fowl er, Inversi on of C ont rol C ont ai ners and t h e Dependency Injection Pattern, MartinFowler.com http://martinfowler.com/articles/injection.html, January 23, 2044   Eri c h Gam m a R i chard Hel m R a l ph Johnson, and John M. Vlissides, Design Patterns: Elements of Reusable Object-Oriented Software, Addison-Wesley Professional 1994  Jacques M a l e nfant R e fl ect i on i n Logi c, Funct i onal and Object-Oriented Programming: A Short Comparative Study, 1995 IJCAI Workshop on Reflection and Metalevel Architectures and Their Applications in AI August 20-25, 1995  Robert C. M a rtin, The Prin ciples, Patterns, and Practices of Agile Software Development, Prentice Hall, 2002  St eve M c Duff, \223C onfi gurat i on Dri v en Devel opm ent  A practical approach to code modification and duplication\224 IBM DeveloperWorks http://www.ibm.com/developerworks/library/waconfigdev/, December 12, 2006  e bsite http://www.python.org  Spring Fram ework W e bsite http://www.springsource.org B IOGRAPHY  Brent Nash has been a software engineer at the Jet Propulsion Laboratory \(JPL\ for three years He currently works on the MPCS Ground Data System for the Mars Science Laboratory and other missions.  He has also worked on a framework for agent-based systems and researched enterprise architecture best practices. He has a BS in Computer Science and Computer Engineering as well as an MS in Computer Science from the University of Southern California    Marti DeMore is a software engineer at JPL and is currently the cognizant engineer for the MPCS Ground Data System for the Mars Science Laboratory and other missions She has 23 years of experience in software architecture, design, and development, primarily in the areas of enterprise messaging and distributed data and device management.  She has a B.S. in Computer Science from California State Polytechni c University at Pomona 


Operation and Maintenance Engineering in 2005 both from Lulea University of Technology Lulea Sweden ACKNOWLEDGEMENTS The authors would like to thank Mr Christian Delmas Director of Maintenance Program Engineering Airbus S.A.S who gave us the opportunity to start this collaboration and Mr Jeremie Neveux and Mr Raphael Laforgue who identified the need to investigate this subject and for their time and useful comments given on drafts of this paper The authors also would like to thank Professor Uday Kumar Lule'a University of Technology for his valuable discussion and guidance 14 


  15 R EFERENCES    http://www.w3.org/XML/Schema   eb Orchestration with BPEL\224 http://www.idealliance.org/pa pers/dx_xml03 papers/0406-01/04-06-01.html  Hi bernat e hom e page www.hibernate.org   Al l a rd, Dan and Hut c herson, Joe, \223C om m uni cat i ons Across Complex Space Networks\224, IEEE Aerospace Conference, March 1-8, 2008  W e b Servi ce Defi ni t i on Language http://www.w3.org/TR/wsdl   B a uer, C h ri st i a n and Ki ng Javi n Java Persi s t e nce for Hibernate, New York: Manning Publications, 2007 7] \223Software Agents An Overview\224 http://www.sce.carleton.ca/netm anage/docs/AgentsOverview ao.html  e thodology.org  http://www.riaspot.com artic les/entry/What-is-Ajax  http://www.json.org 11 h ttp to m cat.ap ach e.o r g   12] http://java.sun com/products/servlet  http://www.w3.org/Sty le/CSS    B IOGRAPHY  Dan Allard has worked as a software engineer at the Jet Propulsion Laboratory for the past 17 years.   He currently leads the development of core JPL accountability systems applications and infrastructure Other recent work includes the development of a message-based ground data system for the Mars Science Laboratory as well as research and development of ontologybased distributed communications     Dr. Charles D \(Chad\ards, Jr received his A.B degree in Physics from Princeton University in 1979 and his Ph.D. in Physics from the Calif ornia Institute of Technology in 1984.  Since then he has worked at NASA\222s Jet Propulsion Laboratory, where he currently serves as Manager of the Mars Network Office and as Chief Telecommunications Engineer for the Mars Exploration Program, leading the development of a dedicated orbiting infrastructure at Mars providing essential telecommunications and navi gation capabilities in support of Mars exploration.  Prior to that he managed the Telecommunications and Mission Operations Technology Office, overseeing a broad program of research and technology development in support of NASA\222s unique capabilities in deep space communications and mission operations.  Earlier in his career, Dr. Edwards worked in the Tracking Systems and Applications section at JPL where he carried out research on novel new radio tracking techniques in support of deep space navigation, planetary science, and radio astronomy  


  16  


Thank you Questions 


 18  Astronautical Congress Valencia, 2006 27  Bu reau  In tern atio n a l d e s Po ids et Mesures. \(2 008  August\SI Base Units. [On http://www.bipm.org/en/si/base_units   B IOGRAPHY  Author, Karl Strauss, has been employed by the Jet Propulsion Laboratory for over 22 years.  He has been in the Avionics Section from day One.  He is considered JPL\222s memory technology expert with projects ranging from hand-woven core memory \(for another employer\o high capacity solid state designs.  He managed the development of NASA\222s first Solid State Recorder, a DRAM-based 2 Gb design currently in use by the Cassini mission to Satu rn and the Chandra X-Ray observatory in Earth Orbit.  Karl was the founder, and seven-time chair of the IEEE NonVolatile Memory Technology Symposium, NVMTS, deciding that the various symposia conducted until then were too focused on one technology.  Karl is a Senior IEEE member and is active in the Nuclear and Plasma Scie nce Society, the Electron Device Society and the Aerospace Electronic Systems Society Karl is also an active member of SAE Karl thanks his wonderful wife of 28 years, Janet, for raising a spectacular family: three sons, Justin, Jeremy Jonathan.  Karl\222s passion is trains and is developing a model railroad based upon a four-day rail journey across Australia\222s Northern Outback   


 19 Bollobs, B. 2001. Random Graphs. Cambridge University Press; 2nd edition. 500pp  Cawley, G. C., B. L. C. Talbot, G. J. Janacek, and M. W Peck. 2006. Sparse Bayesian Ke rnel Survival Analysis for Modeling the Growth Domain of Microbial Pathogens  Chiang C. L. 1960. A stochastic study of life tables and its applications: I. Probability distribution of the biometric functions. Biometrics, 16:618-635  Cox,  D. R. 1972. Regression models and life tables J. R Stat. Soc. Ser. B 34:184-220  Cox, D. R. 1975.   Partial likelihood Biometrika 62:269276  Cox, D. R. & D. Oakes. 1984 Analysis of Survival Data  Chapman & Hall. London  Cressie, N. A. 1993 Statistics for Spatial Data John Wiley Sons. 900pp  Duchesne, T. 2005. Regression models for reliability given the usage accumulation history. In "Modern Statistical and Mathematical Methods in Reliability". Edited by A. Wilson N. Limnios, S. Kelly-McNulty Y. Armijo. pp.29-40. World Scientific, New Jersey  Eleuteri, A., R. Tagliaferri, L. Milano, G. Sansone, D D'Agostino, S. De Placido,  M. Laurentiis. 2003.  Survival analysis and neural networks. Proceedings of the International Joint Conference on Neural Networks, Vol. 4 20-24 July 2003 Page\(s\:2631 - 2636  Ellison, E., L. Linger, and M Longstaff. 1997.  Survivable Network Systems: An Emerging Discipline, Carnegie Mellon, SEI, Technical Report CMU/SEI-97-TR-013, 1997  Fleming, T. R. & D. P. Harrington. 1991. Counting process and survival analysis. John Wiley & Sons. 429pp  Graver, J. and M. Sobel 2005. You may rely on the Reliability Polynomial for much more than you might think Communications in Statistics: Theory and Methods  34\(6\1411-1422  Graves, T. and M. Hamada. 2005. Bayesian methods for assessing system reliability: models and computation. In Modern Statistical and Mathematical Methods in Reliability". Edited by A. Wilson, et al. pp.41-53  Grimmett, G. 2006 The Random-Cluster Model Springer  Grimmett, G. 1999 Percolation Springer  Hougaard, P. 2000. Analysis of Multivariate Survival Data Springer. 560pp  Ibrahim, J. G., M. H. Chen and D. Sinha. 2005. Bayesian Survival Analysis.  Springer. 481pp  Jin Z. 2005. Non-proportional semi-parametric regression models for censored data. In "Modern Statistical and Mathematical Methods in Reliability". Edited by A. Wilson N. Limnios, S. Kelly-McNulty, Y. Armijo. pp.279-292 World Scientific  Kalbfleisch, J. D. & R. L. Prentice. 1980 The Statistical Analysis of Failure Time Data John Wiley & Sons.  New York. 1980  Kalbfleisch, J. D. &  R. L. Prentice, 2002. The Statistical Analysis of Failure Time Data.  Wiley-InterScience, 2nd ed 462pp  Lisboa, P. J. G. and H. Wong. 2001. Are neural networks best used to help logistic regression? Proceedings of International Joint Conference on Neural Networks, IJCNN 01. Volume 4, 15-19,  July 2001. Page\(s\:2472 - 2477 vol.4  Kauffman, R. J. and B. Wang. 2002. Duration in the Digital Economy. Proceedings of th e 36th Hawaii International Conference on System Sciences \(HICSS03\ Jan 2003  Kaplan, E. L. & P.  Meier.  1958.  Nonparametric estimation from incomplete observations J. Amer. Statist. Assoc  53:457-481  Klein, J. P. and P. K. Goel 1992. Survival Analysis: State of the Art.  Kluwer Academic Publishes. 450pp  Klein, J. P. and  M. L Moeschberger. 20 03. Survival analysis techniques for ce nsored and truncated data Springer  Krings, A. and Z. S. Ma. 2006.  "Fault-Models in Wireless Communication: Towards Survivable Ad Hoc Networks MILCOM 2006, Military Communications Conference, 2325 October, 7 pages, 2006  Krings, A. W. 2008.  Survivable Systems.  in Information Assurance: Dependability and Security in Networked Systems Yi Qian, James Joshi, David Tipper, and Prashant Krishnamurthy, Morgan Kaufmann Publishers. \(in press  Lawless, J. F. 1982. Statistical models and methods for lifetime data.  John Wiley & Sons. 579pp  Lawless, J. F. 2003. Statistical models and methods for lifetime data.  John Wiley & Sons. 2nd ed. 630pp  Li, M. and P. Vitanyi. 1997. Introduction to  Kolmogorov Complexity and Its Applications. 2nd ed, Springer  Ma, Z. S. 1997.  Survival analysis and demography of Russian wheat aphid populations.  Ph.D dissertation, 307pp University of Idaho Moscow, Idaho, USA 


 20 Ma, Z. S., and E. J. Bechinski. 2008.  Developmental and Phenological Modeling of Russian Wheat Aphid Annals of Entomological Soc. Am In press  Ma, Z. S. and A. W. Krings. 2008a. The Competing Risks Analysis Approach to Reliability Survivability, and Prognostics and Health Management.  The 2008 IEEEAIAA AeroSpace Conference. BigSky, Montana, March 18, 2008. \(In Press, in the same volume  Ma, Z. S. and A. W. Krings 2008b. Multivariate Survival Analysis \(I\e Shared Frailty Approaches to Reliability and Dependence Modeling. The 2008 IEEE-AIAA AeroSpace Conference. BigSky Montana, March 1-8, 2008 In Press, in the same volume  Ma, Z. S. and A. W. Krings. 2008c. Multivariate Survival Analysis \(II\ Multi-State Models in Biomedicine and Engineering Reliability. 2008 IEEE International Conference on Biomedical Engineering and Informatics BMEI 2008\27th-30th, 2008 Accepted   Mani, R., J. Drew, A. Betz, P. Datta. 1999. Statistics and Data Mining Techniques for Lifetime Value Modeling ACM Conf. on Knowledge Discovery and Data Mining  Mazzuchi, T. A., R Soyer., and R. V Spring. 1989. The proportional hazards model in reliability. IEEE Proceedings of Annual Reliability and Maintainability Symposium pp.252-256  Meeker, W. Q. and L. A. Escobar. 1998. Statistical Methods for Reliability Data. Wiley-Interscience  Munson, J. C. 2003. Software Engineering Measurement Auerbach Publications  Nelson, W. 1969. Hazard plotting for incomplete failure data J. Qual. Tech 1:27-52  Nakagawa, T. 2006.  Shock and Damage Models in Reliability Theory. Springer  Osborn, B. 2005. Leveraging remote diagnostics data for predictive maintenance.   In "Modern Statistical and Mathematical Methods in Reliability". Edited by A. Wilson N. Limnios, S. Kelly-McNulty, Y. Armijo. pp. 353-363  Pena, E. A. and E. H. Slate. 2005. Dynamic modeling in reliability and survival analysis. In "Modern Statistical and Mathematical Methods in Reliability". Edited by A. Wilson N. Limnios, S. Kelly-McNulty, Y. Armijo. pp.55-71  Reineke, D. M., E. A. Pohl, and W. P. Murdock. 1998 Survival analysis and maintenance policies for a series system, with highly censore d data.  1998 Proceedings Annual Reliability and Maintainability Symposium. pp 182-188  Schabenberger, O. and C. A. Gotway. 2005. Statistical Methods for Spatial Data Analysis.  Chapman & Hall/CRC  Severini, T. A. 2000. Likelihood methods in statistics Oxford University Press  Shooman, M. L. 2002. Reliability of Computer Systems and Networks: Fault Tolerance, Analysis and Design. John Wiley and Sons. 551pp  Stillman, R. H. and M. S. Mack isack, B. Sharp, and C. Lee 1995. Case studies in survival analysis of overhead line components. IEE Conferen ce of the Reliability and Distribution Equipment. March 29-31, 1995. Conference Publication No. 406. pp210-215  Therneau, T. and P. Grambsch. 2000 Modeling Survival Data: Extending the Cox Model Springer  Wilson, A.  N. Limnios, S Kelly-McNulty, Y. Armijo 2005. Modern Statistical and Mathematical Methods in Reliability. World Scientific, New Jersey  Xie, M. 1991. Software Reliability Modeling. World Scientific Press    B IOGRAPHY   Zhanshan \(Sam\ Ma holds a Ph.D. in Entomology and is a Ph.D. candidate in Computer Science at the University of Idaho. He has published approximately 30 journal and 30 conference papers, mainly in the former field.  Prior to his recent return to academia, he worked as senior network/software engineers in software industry.  His current research interests include reliability and survivability of wireless sensor networks, fault tolerance survival analysis, evolutionary game theory, evolutionary computation and bioinformatics  Axel W. Krings is a professor of Computer Science at the University of Idaho.  He received his Ph.D. \(1993\ and M.S 1991\ degrees in Computer Science from the University of Nebraska - Lincoln, and his M.S. \(1982\ in Electrical Engineering from the FH-Aachen, Germany.  Dr. Krings has published extensively in the area of Computer Network Survivability, Security, Fault-Tolerance and Realtime Scheduling. In 2004/2005 he was a visiting professor at the Institut d'Informatique et Mathmatiques Appliques de Grenoble, at the Institut National Polytechnique de Grenoble, France.  His work has been funded by DoE/INL DoT/NIATT, DoD/OST and NIST 


